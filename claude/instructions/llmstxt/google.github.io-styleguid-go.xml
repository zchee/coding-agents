<onefilellm_output>
<source type="web_crawl" base_url="https://google.github.io/styleguide/go/">
<page url="https://google.github.io/styleguide/go/">
<title>Go Style | styleguide</title>
<content><heading level="1">Go Style</heading><paragraph>https://google.github.io/styleguide/go</paragraph><paragraph>Overview | Guide | Decisions | Best practices</paragraph><heading level="2">About</heading><paragraph>The Go Style Guide and accompanying documents codify the current best approaches for writing readable and idiomatic Go. Adherence to the Style Guide is not intended to be absolute, and these documents will never be exhaustive. Our intention is to minimize the guesswork of writing readable Go so that newcomers to the language can avoid common mistakes. The Style Guide also serves to unify the style guidance given by anyone reviewing Go code at Google.</paragraph><table><thead><tr><th>Document</th><th>Link</th><th>Primary Audience</th><th>Normative</th><th>Canonical</th></tr></thead><tbody><tr><td>Style Guide</td><td>https://google.github.io/styleguide/go/guide</td><td>Everyone</td><td>Yes</td><td>Yes</td></tr><tr><td>Style Decisions</td><td>https://google.github.io/styleguide/go/decisions</td><td>Readability Mentors</td><td>Yes</td><td>No</td></tr><tr><td>Best Practices</td><td>https://google.github.io/styleguide/go/best-practices</td><td>Anyone interested</td><td>No</td><td>No</td></tr></tbody></table><heading level="3">Documents</heading><list type="ol"><item>The Style Guide outlines the foundation of Go style at Google. This document is definitive and is used as the basis for the recommendations in Style Decisions and Best Practices.</item><item>Style Decisions is a more verbose document that summarizes decisions on specific style points and discusses the reasoning behind the decisions where appropriate. These decisions may occasionally change based on new data, new language features, new libraries, or emerging patterns, but it is not expected that individual Go programmers at Google should keep up-to-date with this document.</item><item>Best Practices documents some of the patterns that have evolved over time that solve common problems, read well, and are robust to code maintenance needs. These best practices are not canonical, but Go programmers at Google are encouraged to use them where possible to keep the codebase uniform and consistent.</item></list><paragraph>The Style Guide outlines the foundation of Go style at Google. This document is definitive and is used as the basis for the recommendations in Style Decisions and Best Practices.</paragraph><paragraph>Style Decisions is a more verbose document that summarizes decisions on specific style points and discusses the reasoning behind the decisions where appropriate.</paragraph><paragraph>These decisions may occasionally change based on new data, new language features, new libraries, or emerging patterns, but it is not expected that individual Go programmers at Google should keep up-to-date with this document.</paragraph><paragraph>Best Practices documents some of the patterns that have evolved over time that solve common problems, read well, and are robust to code maintenance needs.</paragraph><paragraph>These best practices are not canonical, but Go programmers at Google are encouraged to use them where possible to keep the codebase uniform and consistent.</paragraph><paragraph>These documents intend to:</paragraph><list type="ul"><item>Agree on a set of principles for weighing alternate styles</item><item>Codify settled matters of Go style</item><item>Document and provide canonical examples for Go idioms</item><item>Document the pros and cons of various style decisions</item><item>Help minimize surprises in Go readability reviews</item><item>Help readability mentors use consistent terminology and guidance</item></list><paragraph>These documents do not intend to:</paragraph><list type="ul"><item>Be an exhaustive list of comments that can be given in a readability review</item><item>List all of the rules everyone is expected to remember and follow at all times</item><item>Replace good judgment in the use of language features and style</item><item>Justify large-scale changes to get rid of style differences</item></list><paragraph>There will always be differences from one Go programmer to another and from one team's codebase to another. However, it is in the best interest of Google and Alphabet that our codebase be as consistent as possible. (See guide for more on consistency.) To that end, feel free to make style improvements as you see fit, but you do not need to nit-pick every violation of the Style Guide that you find. In particular, these documents may change over time, and that is no reason to cause extra churn in existing codebases; it suffices to write new code using the latest best practices and address nearby issues over time.</paragraph><paragraph>It is important to recognize that issues of style are inherently personal and that there are always inherent trade-offs. Much of the guidance in these documents is subjective, but just like with gofmt, there is significant value in the uniformity they provide. As such, style recommendations will not be changed without due discourse, Go programmers at Google are encouraged to follow the style guide even where they might disagree.</paragraph><heading level="2">Definitions</heading><paragraph>The following words, which are used throughout the style documents, are defined below:</paragraph><list type="ul"><item>Canonical: Establishes prescriptive and enduring rules Within these documents, "canonical" is used to describe something that is considered a standard that all code (old and new) should follow and that is not expected to change substantially over time. Principles in the canonical documents should be understood by authors and reviewers alike, so everything included within a canonical document must meet a high bar. As such, canonical documents are generally shorter and prescribe fewer elements of style than non-canonical documents. https://google.github.io/styleguide/go#canonical</item><item>Normative: Intended to establish consistency Within these documents, "normative" is used to describe something that is an agreed-upon element of style for use by Go code reviewers, in order that the suggestions, terminology, and justifications are consistent. These elements may change over time, and these documents will reflect such changes so that reviewers can remain consistent and up-to-date. Authors of Go code are not expected to be familiar with the normative documents, but the documents will frequently be used as a reference by reviewers in readability reviews. https://google.github.io/styleguide/go#normative</item><item>Idiomatic: Common and familiar Within these documents, "idiomatic" is used to refer to something that is prevalent in Go code and has become a familiar pattern that is easy to recognize. In general, an idiomatic pattern should be preferred to something unidiomatic if both serve the same purpose in context, as this is what will be the most familiar to readers. https://google.github.io/styleguide/go#idiomatic</item></list><paragraph>Canonical: Establishes prescriptive and enduring rules</paragraph><paragraph>Within these documents, "canonical" is used to describe something that is considered a standard that all code (old and new) should follow and that is not expected to change substantially over time. Principles in the canonical documents should be understood by authors and reviewers alike, so everything included within a canonical document must meet a high bar. As such, canonical documents are generally shorter and prescribe fewer elements of style than non-canonical documents.</paragraph><paragraph>https://google.github.io/styleguide/go#canonical</paragraph><paragraph>Normative: Intended to establish consistency</paragraph><paragraph>Within these documents, "normative" is used to describe something that is an agreed-upon element of style for use by Go code reviewers, in order that the suggestions, terminology, and justifications are consistent. These elements may change over time, and these documents will reflect such changes so that reviewers can remain consistent and up-to-date. Authors of Go code are not expected to be familiar with the normative documents, but the documents will frequently be used as a reference by reviewers in readability reviews.</paragraph><paragraph>https://google.github.io/styleguide/go#normative</paragraph><paragraph>Idiomatic: Common and familiar</paragraph><paragraph>Within these documents, "idiomatic" is used to refer to something that is prevalent in Go code and has become a familiar pattern that is easy to recognize. In general, an idiomatic pattern should be preferred to something unidiomatic if both serve the same purpose in context, as this is what will be the most familiar to readers.</paragraph><paragraph>https://google.github.io/styleguide/go#idiomatic</paragraph><heading level="2">Additional references</heading><paragraph>This guide assumes the reader is familiar with Effective Go, as it provides a common baseline for Go code across the entire Go community.</paragraph><paragraph>Below are some additional resources for those looking to self-educate about Go style and for reviewers looking to provide further linkable context in their reviews. Participants in the Go readability process are not expected to be familiar with these resources, but they may arise as context in readability reviews.</paragraph><paragraph>External References</paragraph><paragraph>Relevant Testing-on-the-Toilet articles</paragraph><paragraph>Additional External Writings</paragraph></content>
</page>
<page url="https://google.github.io/styleguide/">
<title>Google Style Guides | styleguide</title>
<content><heading level="1">Google Style Guides</heading><paragraph>Every major open-source project has its own style guide: a set of conventions (sometimes arbitrary) about how to write code for that project. It is much easier to understand a large codebase when all the code in it is in a consistent style.</paragraph><paragraph>"Style" covers a lot of ground, from "use camelCase for variable names" to "never use global variables" to "never use exceptions." This project (google/styleguide) links to the style guidelines we use for Google code. If you are modifying a project that originated at Google, you may be pointed to this page to see the style guides that apply to that project.</paragraph><paragraph>This project also contains google-c-style.el, an Emacs settings file for Google style.</paragraph><paragraph>We used to host the cpplint tool, but we stopped making internal updates public. An open source community has forked the project, so users are encouraged to use https://github.com/cpplint/cpplint instead.</paragraph><paragraph>If your project requires that you create a new XML document format, the XML Document Format Style Guide may be helpful. In addition to actual style rules, it also contains advice on designing your own vs. adapting an existing format, on XML instance document formatting, and on elements vs. attributes.</paragraph><paragraph>The style guides in this project are licensed under the CC-By 3.0 License, which encourages you to share these documents. See https://creativecommons.org/licenses/by/3.0/ for more details.</paragraph><paragraph>The following Google style guide lives outside of this project:</paragraph><paragraph>Since projects are largely maintained in a VCS, writing good commit messages is important to long term project health. Please refer to How to Write a Git Commit Message as an excellent resource. While it explicitly refers to the Git SCM, its principles apply to any system, and many Git conventions are trivial to translate to others.</paragraph><heading level="2">Contributing</heading><paragraph>With few exceptions, these style guides are copies of Google's internal style guides to assist developers working on Google owned and originated open source projects. Changes to the style guides are made to the internal style guides first and eventually copied into the versions found here. External contributions are not accepted. Pull requests are regularly closed without comment.</paragraph><paragraph>People can file issues using the GitHub tracker. Issues that raise questions, justify changes on technical merits, or point out obvious mistakes may get some engagement and could in theory lead to changes, but we are primarily optimizing for Google's internal needs.</paragraph></content>
</page>
<page url="https://google.github.io/styleguide/go/guide">
<title>styleguide | Style guides for Google-originated open-source projects</title>
<content><heading level="1">Go Style Guide</heading><paragraph>https://google.github.io/styleguide/go/guide</paragraph><paragraph>Overview | Guide | Decisions | Best practices</paragraph><paragraph>Note: This is part of a series of documents that outline Go Style at Google. This document is normative and canonical. See the overview for more information.</paragraph><heading level="2">Style principles</heading><paragraph>There are a few overarching principles that summarize how to think about writing readable Go code. The following are attributes of readable code, in order of importance:</paragraph><list type="ol"><item>Clarity: The code's purpose and rationale is clear to the reader.</item><item>Simplicity: The code accomplishes its goal in the simplest way possible.</item><item>Concision: The code has a high signal-to-noise ratio.</item><item>Maintainability: The code is written such that it can be easily maintained.</item><item>Consistency: The code is consistent with the broader Google codebase.</item></list><heading level="3">Clarity</heading><paragraph>The core goal of readability is to produce code that is clear to the reader.</paragraph><paragraph>Clarity is primarily achieved with effective naming, helpful commentary, and efficient code organization.</paragraph><paragraph>Clarity is to be viewed through the lens of the reader, not the author of the code. It is more important that code be easy to read than easy to write. Clarity in code has two distinct facets:</paragraph><heading level="4">What is the code actually doing?</heading><paragraph>Go is designed such that it should be relatively straightforward to see what the code is doing. In cases of uncertainty or where a reader may require prior knowledge in order to understand the code, it is worth investing time in order to make the code's purpose clearer for future readers. For example, it may help to:</paragraph><list type="ul"><item>Use more descriptive variable names</item><item>Add additional commentary</item><item>Break up the code with whitespace and comments</item><item>Refactor the code into separate functions/methods to make it more modular</item></list><paragraph>There is no one-size-fits-all approach here, but it is important to prioritize clarity when developing Go code.</paragraph><heading level="4">Why is the code doing what it does?</heading><paragraph>The code's rationale is often sufficiently communicated by the names of variables, functions, methods, or packages. Where it is not, it is important to add commentary. The "Why?" is especially important when the code contains nuances that a reader may not be familiar with, such as:</paragraph><list type="ul"><item>A nuance in the language, e.g., a closure will be capturing a loop variable, but the closure is many lines away</item><item>A nuance of the business logic, e.g., an access control check that needs to distinguish between the actual user and someone impersonating a user</item></list><paragraph>An API might require care to use correctly. For example, a piece of code may be intricate and difficult to follow for performance reasons, or a complex sequence of mathematical operations may use type conversions in an unexpected way. In these cases and many more, it is important that accompanying commentary and documentation explain these aspects so that future maintainers don't make a mistake and so that readers can understand the code without needing to reverse-engineer it.</paragraph><paragraph>It is also important to be aware that some attempts to provide clarity (such as adding extra commentary) can actually obscure the code's purpose by adding clutter, restating what the code already says, contradicting the code, or adding maintenance burden to keep the comments up-to-date. Allow the code to speak for itself (e.g., by making the symbol names themselves self-describing) rather than adding redundant comments. It is often better for comments to explain why something is done, not what the code is doing.</paragraph><paragraph>The Google codebase is largely uniform and consistent. It is often the case that code that stands out (e.g., by using an unfamiliar pattern) is doing so for a good reason, typically for performance. Maintaining this property is important to make it clear to readers where they should focus their attention when reading a new piece of code.</paragraph><paragraph>The standard library contains many examples of this principle in action. Among them:</paragraph><heading level="3">Simplicity</heading><paragraph>Your Go code should be simple for those using, reading, and maintaining it.</paragraph><paragraph>Go code should be written in the simplest way that accomplishes its goals, both in terms of behavior and performance. Within the Google Go codebase, simple code:</paragraph><list type="ul"><item>Is easy to read from top to bottom</item><item>Does not assume that you already know what it is doing</item><item>Does not assume that you can memorize all of the preceding code</item><item>Does not have unnecessary levels of abstraction</item><item>Does not have names that call attention to something mundane</item><item>Makes the propagation of values and decisions clear to the reader</item><item>Has comments that explain why, not what, the code is doing to avoid future deviation</item><item>Has documentation that stands on its own</item><item>Has useful errors and useful test failures</item><item>May often be mutually exclusive with "clever" code</item></list><paragraph>Tradeoffs can arise between code simplicity and API usage simplicity. For example, it may be worthwhile to have the code be more complex so that the end user of the API may more easily call the API correctly. In contrast, it may also be worthwhile to leave a bit of extra work to the end user of the API so that the code remains simple and easy to understand.</paragraph><paragraph>When code needs complexity, the complexity should be added deliberately. This is typically necessary if additional performance is required or where there are multiple disparate customers of a particular library or service. Complexity may be justified, but it should come with accompanying documentation so that clients and future maintainers are able to understand and navigate the complexity. This should be supplemented with tests and examples that demonstrate its correct usage, especially if there is both a "simple" and a "complex" way to use the code.</paragraph><paragraph>This principle does not imply that complex code cannot or should not be written in Go or that Go code is not allowed to be complex. We strive for a codebase that avoids unnecessary complexity so that when complexity does appear, it indicates that the code in question requires care to understand and maintain. Ideally, there should be accompanying commentary that explains the rationale and identifies the care that should be taken. This often arises when optimizing code for performance; doing so often requires a more complex approach, like preallocating a buffer and reusing it throughout a goroutine lifetime. When a maintainer sees this, it should be a clue that the code in question is performance-critical, and that should influence the care that is taken when making future changes. If employed unnecessarily, on the other hand, this complexity is a burden on those who need to read or change the code in the future.</paragraph><paragraph>If code turns out to be very complex when its purpose should be simple, this is often a signal to revisit the implementation to see if there is a simpler way to accomplish the same thing.</paragraph><heading level="4">Least mechanism</heading><paragraph>Where there are several ways to express the same idea, prefer the one that uses the most standard tools. Sophisticated machinery often exists, but should not be employed without reason. It is easy to add complexity to code as needed, whereas it is much harder to remove existing complexity after it has been found to be unnecessary.</paragraph><list type="ol"><item>Aim to use a core language construct (for example a channel, slice, map, loop, or struct) when sufficient for your use case.</item><item>If there isn't one, look for a tool within the standard library (like an HTTP client or a template engine).</item><item>Finally, consider whether there is a core library in the Google codebase that is sufficient before introducing a new dependency or creating your own.</item></list><paragraph>As an example, consider production code that contains a flag bound to a variable with a default value which must be overridden in tests. Unless intending to test the program's command-line interface itself (say, with os/exec), it is simpler and therefore preferable to override the bound value directly rather than by using flag.Set.</paragraph><paragraph>Similarly, if a piece of code requires a set membership check, a boolean-valued map (e.g., map[string]bool) often suffices. Libraries that provide set-like types and functionality should only be used if more complicated operations are required that are impossible or overly complicated with a map.</paragraph><heading level="3">Concision</heading><paragraph>Concise Go code has a high signal-to-noise ratio. It is easy to discern the relevant details, and the naming and structure guide the reader through these details.</paragraph><paragraph>There are many things that can get in the way of surfacing the most salient details at any given time:</paragraph><list type="ul"><item>Repetitive code</item><item>Extraneous syntax</item><item>Opaque names</item><item>Unnecessary abstraction</item><item>Whitespace</item></list><paragraph>Repetitive code especially obscures the differences between each nearly-identical section, and requires a reader to visually compare similar lines of code to find the changes. Table-driven testing is a good example of a mechanism that can concisely factor out the common code from the important details of each repetition, but the choice of which pieces to include in the table will have an impact on how easy the table is to understand.</paragraph><paragraph>When considering multiple ways to structure code, it is worth considering which way makes important details the most apparent.</paragraph><paragraph>Understanding and using common code constructions and idioms are also important for maintaining a high signal-to-noise ratio. For example, the following code block is very common in error handling, and the reader can quickly understand the purpose of this block.</paragraph><code language="javascript">// Good:
if err := doSomething(); err != nil {
    // ...
}
</code><paragraph>If code looks very similar to this but is subtly different, a reader may not notice the change. In cases like this, it is worth intentionally "boosting" the signal of the error check by adding a comment to call attention to it.</paragraph><code language="code">// Good:
if err := doSomething(); err == nil { // if NO error
    // ...
}
</code><heading level="3">Maintainability</heading><paragraph>Code is edited many more times than it is written. Readable code not only makes sense to a reader who is trying to understand how it works, but also to the programmer who needs to change it. Clarity is key.</paragraph><paragraph>Maintainable code:</paragraph><list type="ul"><item>Is easy for a future programmer to modify correctly</item><item>Has APIs that are structured so that they can grow gracefully</item><item>Is clear about the assumptions that it makes and chooses abstractions that map to the structure of the problem, not to the structure of the code</item><item>Avoids unnecessary coupling and doesn't include features that are not used</item><item>Has a comprehensive test suite to ensure promised behaviors are maintained and important logic is correct, and the tests provide clear, actionable diagnostics in case of failure</item></list><paragraph>When using abstractions like interfaces and types which by definition remove information from the context in which they are used, it is important to ensure that they provide sufficient benefit. Editors and IDEs can connect directly to a method definition and show the corresponding documentation when a concrete type is used, but can only refer to an interface definition otherwise. Interfaces are a powerful tool, but come with a cost, since the maintainer may need to understand the specifics of the underlying implementation in order to correctly use the interface, which must be explained within the interface documentation or at the call-site.</paragraph><paragraph>Maintainable code also avoids hiding important details in places that are easy to overlook. For example, in each of the following lines of code, the presence or lack of a single character is critical to understand the line:</paragraph><code language="javascript">// Bad:
// The use of = instead of := can change this line completely.
if user, err = db.UserByID(userID); err != nil {
    // ...
}
</code><code language="code">// Bad:
// The ! in the middle of this line is very easy to miss.
leap := (year%4 == 0) && (!(year%100 == 0) || (year%400 == 0))
</code><paragraph>Neither of these are incorrect, but both could be written in a more explicit fashion, or could have an accompanying comment that calls attention to the important behavior:</paragraph><code language="javascript">// Good:
u, err := db.UserByID(userID)
if err != nil {
    return fmt.Errorf("invalid origin user: %s", err)
}
user = u
</code><code language="javascript">// Good:
// Gregorian leap years aren't just year%4 == 0.
// See https://en.wikipedia.org/wiki/Leap_year#Algorithm.
var (
    leap4   = year%4 == 0
    leap100 = year%100 == 0
    leap400 = year%400 == 0
)
leap := leap4 && (!leap100 || leap400)
</code><paragraph>In the same way, a helper function that hides critical logic or an important edge-case could make it easy for a future change to fail to account for it properly.</paragraph><paragraph>Predictable names are another feature of maintainable code. A user of a package or a maintainer of a piece of code should be able to predict the name of a variable, method, or function in a given context. Function parameters and receiver names for identical concepts should typically share the same name, both to keep documentation understandable and to facilitate refactoring code with minimal overhead.</paragraph><paragraph>Maintainable code minimizes its dependencies (both implicit and explicit). Depending on fewer packages means fewer lines of code that can affect behavior. Avoiding dependencies on internal or undocumented behavior makes code less likely to impose a maintenance burden when those behaviors change in the future.</paragraph><paragraph>When considering how to structure or write code, it is worth taking the time to think through ways in which the code may evolve over time. If a given approach is more conducive to easier and safer future changes, that is often a good trade-off, even if it means a slightly more complicated design.</paragraph><heading level="3">Consistency</heading><paragraph>Consistent code is code that looks, feels, and behaves like similar code throughout the broader codebase, within the context of a team or package, and even within a single file.</paragraph><paragraph>Consistency concerns do not override any of the principles above, but if a tie must be broken, it is often beneficial to break it in favor of consistency.</paragraph><paragraph>Consistency within a package is often the most immediately important level of consistency. It can be very jarring if the same problem is approached in multiple ways throughout a package, or if the same concept has many names within a file. However, even this should not override documented style principles or global consistency.</paragraph><heading level="2">Core guidelines</heading><paragraph>These guidelines collect the most important aspects of Go style that all Go code is expected to follow. We expect that these principles be learned and followed by the time readability is granted. These are not expected to change frequently, and new additions will have to clear a high bar.</paragraph><paragraph>The guidelines below expand on the recommendations in Effective Go, which provide a common baseline for Go code across the entire community.</paragraph><heading level="3">Formatting</heading><paragraph>All Go source files must conform to the format outputted by the gofmt tool. This format is enforced by a presubmit check in the Google codebase. Generated code should generally also be formatted (e.g., by using format.Source), as it is also browsable in Code Search.</paragraph><heading level="3">MixedCaps</heading><paragraph>Go source code uses MixedCaps or mixedCaps (camel case) rather than underscores (snake case) when writing multi-word names.</paragraph><paragraph>This applies even when it breaks conventions in other languages. For example, a constant is MaxLength (not MAX_LENGTH) if exported and maxLength (not max_length) if unexported.</paragraph><paragraph>Local variables are considered unexported for the purpose of choosing the initial capitalization.</paragraph><heading level="3">Line length</heading><paragraph>There is no fixed line length for Go source code. If a line feels too long, prefer refactoring instead of splitting it. If it is already as short as it is practical for it to be, the line should be allowed to remain long.</paragraph><paragraph>Do not split a line:</paragraph><list type="ul"><item>Before an indentation change (e.g., function declaration, conditional)</item><item>To make a long string (e.g., a URL) fit into multiple shorter lines</item></list><heading level="3">Naming</heading><paragraph>Naming is more art than science. In Go, names tend to be somewhat shorter than in many other languages, but the same general guidelines apply. Names should:</paragraph><list type="ul"><item>Not feel repetitive when they are used</item><item>Take the context into consideration</item><item>Not repeat concepts that are already clear</item></list><paragraph>You can find more specific guidance on naming in decisions.</paragraph><heading level="3">Local consistency</heading><paragraph>Where the style guide has nothing to say about a particular point of style, authors are free to choose the style that they prefer, unless the code in close proximity (usually within the same file or package, but sometimes within a team or project directory) has taken a consistent stance on the issue.</paragraph><paragraph>Examples of valid local style considerations:</paragraph><list type="ul"><item>Use of %s or %v for formatted printing of errors</item><item>Usage of buffered channels in lieu of mutexes</item></list><paragraph>Examples of invalid local style considerations:</paragraph><list type="ul"><item>Line length restrictions for code</item><item>Use of assertion-based testing libraries</item></list><paragraph>If the local style disagrees with the style guide but the readability impact is limited to one file, it will generally be surfaced in a code review for which a consistent fix would be outside the scope of the CL in question. At that point, it is appropriate to file a bug to track the fix.</paragraph><paragraph>If a change would worsen an existing style deviation, expose it in more API surfaces, expand the number of files in which the deviation is present, or introduce an actual bug, then local consistency is no longer a valid justification for violating the style guide for new code. In these cases, it is appropriate for the author to clean up the existing codebase in the same CL, perform a refactor in advance of the current CL, or find an alternative that at least does not make the local problem worse.</paragraph></content>
</page>
<page url="https://google.github.io/styleguide/go/index">
<title>Go Style | styleguide</title>
<content><heading level="1">Go Style</heading><paragraph>https://google.github.io/styleguide/go</paragraph><paragraph>Overview | Guide | Decisions | Best practices</paragraph><heading level="2">About</heading><paragraph>The Go Style Guide and accompanying documents codify the current best approaches for writing readable and idiomatic Go. Adherence to the Style Guide is not intended to be absolute, and these documents will never be exhaustive. Our intention is to minimize the guesswork of writing readable Go so that newcomers to the language can avoid common mistakes. The Style Guide also serves to unify the style guidance given by anyone reviewing Go code at Google.</paragraph><table><thead><tr><th>Document</th><th>Link</th><th>Primary Audience</th><th>Normative</th><th>Canonical</th></tr></thead><tbody><tr><td>Style Guide</td><td>https://google.github.io/styleguide/go/guide</td><td>Everyone</td><td>Yes</td><td>Yes</td></tr><tr><td>Style Decisions</td><td>https://google.github.io/styleguide/go/decisions</td><td>Readability Mentors</td><td>Yes</td><td>No</td></tr><tr><td>Best Practices</td><td>https://google.github.io/styleguide/go/best-practices</td><td>Anyone interested</td><td>No</td><td>No</td></tr></tbody></table><heading level="3">Documents</heading><list type="ol"><item>The Style Guide outlines the foundation of Go style at Google. This document is definitive and is used as the basis for the recommendations in Style Decisions and Best Practices.</item><item>Style Decisions is a more verbose document that summarizes decisions on specific style points and discusses the reasoning behind the decisions where appropriate. These decisions may occasionally change based on new data, new language features, new libraries, or emerging patterns, but it is not expected that individual Go programmers at Google should keep up-to-date with this document.</item><item>Best Practices documents some of the patterns that have evolved over time that solve common problems, read well, and are robust to code maintenance needs. These best practices are not canonical, but Go programmers at Google are encouraged to use them where possible to keep the codebase uniform and consistent.</item></list><paragraph>The Style Guide outlines the foundation of Go style at Google. This document is definitive and is used as the basis for the recommendations in Style Decisions and Best Practices.</paragraph><paragraph>Style Decisions is a more verbose document that summarizes decisions on specific style points and discusses the reasoning behind the decisions where appropriate.</paragraph><paragraph>These decisions may occasionally change based on new data, new language features, new libraries, or emerging patterns, but it is not expected that individual Go programmers at Google should keep up-to-date with this document.</paragraph><paragraph>Best Practices documents some of the patterns that have evolved over time that solve common problems, read well, and are robust to code maintenance needs.</paragraph><paragraph>These best practices are not canonical, but Go programmers at Google are encouraged to use them where possible to keep the codebase uniform and consistent.</paragraph><paragraph>These documents intend to:</paragraph><list type="ul"><item>Agree on a set of principles for weighing alternate styles</item><item>Codify settled matters of Go style</item><item>Document and provide canonical examples for Go idioms</item><item>Document the pros and cons of various style decisions</item><item>Help minimize surprises in Go readability reviews</item><item>Help readability mentors use consistent terminology and guidance</item></list><paragraph>These documents do not intend to:</paragraph><list type="ul"><item>Be an exhaustive list of comments that can be given in a readability review</item><item>List all of the rules everyone is expected to remember and follow at all times</item><item>Replace good judgment in the use of language features and style</item><item>Justify large-scale changes to get rid of style differences</item></list><paragraph>There will always be differences from one Go programmer to another and from one team's codebase to another. However, it is in the best interest of Google and Alphabet that our codebase be as consistent as possible. (See guide for more on consistency.) To that end, feel free to make style improvements as you see fit, but you do not need to nit-pick every violation of the Style Guide that you find. In particular, these documents may change over time, and that is no reason to cause extra churn in existing codebases; it suffices to write new code using the latest best practices and address nearby issues over time.</paragraph><paragraph>It is important to recognize that issues of style are inherently personal and that there are always inherent trade-offs. Much of the guidance in these documents is subjective, but just like with gofmt, there is significant value in the uniformity they provide. As such, style recommendations will not be changed without due discourse, Go programmers at Google are encouraged to follow the style guide even where they might disagree.</paragraph><heading level="2">Definitions</heading><paragraph>The following words, which are used throughout the style documents, are defined below:</paragraph><list type="ul"><item>Canonical: Establishes prescriptive and enduring rules Within these documents, "canonical" is used to describe something that is considered a standard that all code (old and new) should follow and that is not expected to change substantially over time. Principles in the canonical documents should be understood by authors and reviewers alike, so everything included within a canonical document must meet a high bar. As such, canonical documents are generally shorter and prescribe fewer elements of style than non-canonical documents. https://google.github.io/styleguide/go#canonical</item><item>Normative: Intended to establish consistency Within these documents, "normative" is used to describe something that is an agreed-upon element of style for use by Go code reviewers, in order that the suggestions, terminology, and justifications are consistent. These elements may change over time, and these documents will reflect such changes so that reviewers can remain consistent and up-to-date. Authors of Go code are not expected to be familiar with the normative documents, but the documents will frequently be used as a reference by reviewers in readability reviews. https://google.github.io/styleguide/go#normative</item><item>Idiomatic: Common and familiar Within these documents, "idiomatic" is used to refer to something that is prevalent in Go code and has become a familiar pattern that is easy to recognize. In general, an idiomatic pattern should be preferred to something unidiomatic if both serve the same purpose in context, as this is what will be the most familiar to readers. https://google.github.io/styleguide/go#idiomatic</item></list><paragraph>Canonical: Establishes prescriptive and enduring rules</paragraph><paragraph>Within these documents, "canonical" is used to describe something that is considered a standard that all code (old and new) should follow and that is not expected to change substantially over time. Principles in the canonical documents should be understood by authors and reviewers alike, so everything included within a canonical document must meet a high bar. As such, canonical documents are generally shorter and prescribe fewer elements of style than non-canonical documents.</paragraph><paragraph>https://google.github.io/styleguide/go#canonical</paragraph><paragraph>Normative: Intended to establish consistency</paragraph><paragraph>Within these documents, "normative" is used to describe something that is an agreed-upon element of style for use by Go code reviewers, in order that the suggestions, terminology, and justifications are consistent. These elements may change over time, and these documents will reflect such changes so that reviewers can remain consistent and up-to-date. Authors of Go code are not expected to be familiar with the normative documents, but the documents will frequently be used as a reference by reviewers in readability reviews.</paragraph><paragraph>https://google.github.io/styleguide/go#normative</paragraph><paragraph>Idiomatic: Common and familiar</paragraph><paragraph>Within these documents, "idiomatic" is used to refer to something that is prevalent in Go code and has become a familiar pattern that is easy to recognize. In general, an idiomatic pattern should be preferred to something unidiomatic if both serve the same purpose in context, as this is what will be the most familiar to readers.</paragraph><paragraph>https://google.github.io/styleguide/go#idiomatic</paragraph><heading level="2">Additional references</heading><paragraph>This guide assumes the reader is familiar with Effective Go, as it provides a common baseline for Go code across the entire Go community.</paragraph><paragraph>Below are some additional resources for those looking to self-educate about Go style and for reviewers looking to provide further linkable context in their reviews. Participants in the Go readability process are not expected to be familiar with these resources, but they may arise as context in readability reviews.</paragraph><paragraph>External References</paragraph><paragraph>Relevant Testing-on-the-Toilet articles</paragraph><paragraph>Additional External Writings</paragraph></content>
</page>
<page url="https://google.github.io/styleguide/go/decisions">
<title>styleguide | Style guides for Google-originated open-source projects</title>
<content><heading level="1">Go Style Decisions</heading><paragraph>https://google.github.io/styleguide/go/decisions</paragraph><paragraph>Overview | Guide | Decisions | Best practices</paragraph><paragraph>Note: This is part of a series of documents that outline Go Style at Google. This document is normative but not canonical, and is subordinate to the core style guide. See the overview for more information.</paragraph><heading level="2">About</heading><paragraph>This document contains style decisions intended to unify and provide standard guidance, explanations, and examples for the advice given by the Go readability mentors.</paragraph><paragraph>This document is not exhaustive and will grow over time. In cases where the core style guide contradicts the advice given here, the style guide takes precedence, and this document should be updated accordingly.</paragraph><paragraph>See the Overview for the full set of Go Style documents.</paragraph><paragraph>The following sections have moved from style decisions to another part of the guide:</paragraph><heading level="2">Naming</heading><paragraph>See the naming section within the core style guide for overarching guidance on naming. The following sections provide further clarification on specific areas within naming.</paragraph><heading level="3">Underscores</heading><paragraph>Names in Go should in general not contain underscores. There are three exceptions to this principle:</paragraph><list type="ol"><item>Package names that are only imported by generated code may contain underscores. See package names for more detail around how to choose multi-word package names.</item><item>Test, Benchmark and Example function names within *_test.go files may include underscores.</item><item>Low-level libraries that interoperate with the operating system or cgo may reuse identifiers, as is done in syscall. This is expected to be very rare in most codebases.</item></list><paragraph>Note: Filenames of source code are not Go identifiers and do not have to follow these conventions. They may contain underscores.</paragraph><heading level="3">Package names</heading><paragraph>Go package names should be short and contain only lowercase letters. A package name composed of multiple words should be left unbroken in all lowercase. For example, the package tabwriter is not named tabWriter, TabWriter, or tab_writer.</paragraph><paragraph>Avoid selecting package names that are likely to be shadowed by commonly used local variable names. For example, usercount is a better package name than count, since count is a commonly used variable name.</paragraph><paragraph>Go package names should not have underscores. If you need to import a package that does have one in its name (usually from generated or third party code), it must be renamed at import time to a name that is suitable for use in Go code.</paragraph><paragraph>An exception to this is that package names that are only imported by generated code may contain underscores. Specific examples include:</paragraph><list type="ul"><item>Using the _test suffix for unit tests that only exercise the exported API of a package (package testing calls these "black box tests"). For example, a package linkedlist must define its black box unit tests in a package named linkedlist_test (not linked_list_test)</item><item>Using underscores and the _test suffix for packages that specify functional or integration tests. For example, a linked list service integration test could be named linked_list_service_test</item><item>Using the _test suffix for package-level documentation examples</item></list><paragraph>Using the _test suffix for unit tests that only exercise the exported API of a package (package testing calls these "black box tests"). For example, a package linkedlist must define its black box unit tests in a package named linkedlist_test (not linked_list_test)</paragraph><paragraph>Using underscores and the _test suffix for packages that specify functional or integration tests. For example, a linked list service integration test could be named linked_list_service_test</paragraph><paragraph>Using the _test suffix for package-level documentation examples</paragraph><paragraph>Avoid uninformative package names like util, utility, common, helper, models, and so on that would tempt users of the package to rename it when importing. See:</paragraph><paragraph>When an imported package is renamed (e.g. import foopb "path/to/foo_go_proto"), the local name for the package must comply with the rules above, as the local name dictates how the symbols in the package are referenced in the file. If a given import is renamed in multiple files, particularly in the same or nearby packages, the same local name should be used wherever possible for consistency.</paragraph><paragraph>See also: Go blog post about package names.</paragraph><heading level="3">Receiver names</heading><paragraph>Receiver variable names must be:</paragraph><list type="ul"><item>Short (usually one or two letters in length)</item><item>Abbreviations for the type itself</item><item>Applied consistently to every receiver for that type</item></list><table><thead><tr><th>Long Name</th><th>Better Name</th></tr></thead><tbody><tr><td>func (tray Tray)</td><td>func (t Tray)</td></tr><tr><td>func (info *ResearchInfo)</td><td>func (ri *ResearchInfo)</td></tr><tr><td>func (this *ReportWriter)</td><td>func (w *ReportWriter)</td></tr><tr><td>func (self *Scanner)</td><td>func (s *Scanner)</td></tr></tbody></table><heading level="3">Constant names</heading><paragraph>Constant names must use MixedCaps like all other names in Go. (Exported constants start with uppercase, while unexported constants start with lowercase.) This applies even when it breaks conventions in other languages. Constant names should not be a derivative of their values and should instead explain what the value denotes.</paragraph><code language="javascript">// Good:
const MaxPacketSize = 512

const (
    ExecuteBit = 1 << iota
    WriteBit
    ReadBit
)
</code><paragraph>Do not use non-MixedCaps constant names or constants with a K prefix.</paragraph><code language="javascript">// Bad:
const MAX_PACKET_SIZE = 512
const kMaxBufferSize = 1024
const KMaxUsersPergroup = 500
</code><paragraph>Name constants based on their role, not their values. If a constant does not have a role apart from its value, then it is unnecessary to define it as a constant.</paragraph><code language="javascript">// Bad:
const Twelve = 12

const (
    UserNameColumn = "username"
    GroupColumn    = "group"
)
</code><heading level="3">Initialisms</heading><paragraph>Words in names that are initialisms or acronyms (e.g., URL and NATO) should have the same case. URL should appear as URL or url (as in urlPony, or URLPony), never as Url. As a general rule, identifiers (e.g., ID and DB) should also be capitalized similar to their usage in English prose.</paragraph><list type="ul"><item>In names with multiple initialisms (e.g. XMLAPI because it contains XML and API), each letter within a given initialism should have the same case, but each initialism in the name does not need to have the same case.</item><item>In names with an initialism containing a lowercase letter (e.g. DDoS, iOS, gRPC), the initialism should appear as it would in standard prose, unless you need to change the first letter for the sake of exportedness. In these cases, the entire initialism should be the same case (e.g. ddos, IOS, GRPC).</item></list><table><thead><tr><th>English Usage</th><th>Scope</th><th>Correct</th><th>Incorrect</th></tr></thead><tbody><tr><td>XML API</td><td>Exported</td><td>XMLAPI</td><td>XmlApi, XMLApi, XmlAPI, XMLapi</td></tr><tr><td>XML API</td><td>Unexported</td><td>xmlAPI</td><td>xmlapi, xmlApi</td></tr><tr><td>iOS</td><td>Exported</td><td>IOS</td><td>Ios, IoS</td></tr><tr><td>iOS</td><td>Unexported</td><td>iOS</td><td>ios</td></tr><tr><td>gRPC</td><td>Exported</td><td>GRPC</td><td>Grpc</td></tr><tr><td>gRPC</td><td>Unexported</td><td>gRPC</td><td>grpc</td></tr><tr><td>DDoS</td><td>Exported</td><td>DDoS</td><td>DDOS, Ddos</td></tr><tr><td>DDoS</td><td>Unexported</td><td>ddos</td><td>dDoS, dDOS</td></tr><tr><td>ID</td><td>Exported</td><td>ID</td><td>Id</td></tr><tr><td>ID</td><td>Unexported</td><td>id</td><td>iD</td></tr><tr><td>DB</td><td>Exported</td><td>DB</td><td>Db</td></tr><tr><td>DB</td><td>Unexported</td><td>db</td><td>dB</td></tr><tr><td>Txn</td><td>Exported</td><td>Txn</td><td>TXN</td></tr></tbody></table><heading level="3">Getters</heading><paragraph>Function and method names should not use a Get or get prefix, unless the underlying concept uses the word "get" (e.g. an HTTP GET). Prefer starting the name with the noun directly, for example use Counts over GetCounts.</paragraph><paragraph>If the function involves performing a complex computation or executing a remote call, a different word like Compute or Fetch can be used in place of Get, to make it clear to a reader that the function call may take time and could block or fail.</paragraph><heading level="3">Variable names</heading><paragraph>The general rule of thumb is that the length of a name should be proportional to the size of its scope and inversely proportional to the number of times that it is used within that scope. A variable created at file scope may require multiple words, whereas a variable scoped to a single inner block may be a single word or even just a character or two, to keep the code clear and avoid extraneous information.</paragraph><paragraph>Here is a rough baseline. These numeric guidelines are not strict rules. Apply judgement based on context, clarity, and concision.</paragraph><list type="ul"><item>A small scope is one in which one or two small operations are performed, say 1-7 lines.</item><item>A medium scope is a few small or one large operation, say 8-15 lines.</item><item>A large scope is one or a few large operations, say 15-25 lines.</item><item>A very large scope is anything that spans more than a page (say, more than 25 lines).</item></list><paragraph>A name that might be perfectly clear (e.g., c for a counter) within a small scope could be insufficient in a larger scope and would require clarification to remind the reader of its purpose further along in the code. A scope in which there are many variables, or variables that represent similar values or concepts, may necessitate longer variable names than the scope suggests.</paragraph><paragraph>The specificity of the concept can also help to keep a variable's name concise. For example, assuming there is only a single database in use, a short variable name like db that might normally be reserved for very small scopes may remain perfectly clear even if the scope is very large. In this case, a single word database is likely acceptable based on the size of the scope, but is not required as db is a very common shortening for the word with few alternate interpretations.</paragraph><paragraph>The name of a local variable should reflect what it contains and how it is being used in the current context, rather than where the value originated. For example, it is often the case that the best local variable name is not the same as the struct or protocol buffer field name.</paragraph><paragraph>In general:</paragraph><list type="ul"><item>Single-word names like count or options are a good starting point.</item><item>Additional words can be added to disambiguate similar names, for example userCount and projectCount.</item><item>Do not simply drop letters to save typing. For example Sandbox is preferred over Sbx, particularly for exported names.</item><item>Omit types and type-like words from most variable names. For a number, userCount is a better name than numUsers or usersInt. For a slice, users is a better name than userSlice. It is acceptable to include a type-like qualifier if there are two versions of a value in scope, for example you might have an input stored in ageString and use age for the parsed value.</item><item>Omit words that are clear from the surrounding context. For example, in the implementation of a UserCount method, a local variable called userCount is probably redundant; count, users, or even c are just as readable.</item></list><list type="ul"><item>For a number, userCount is a better name than numUsers or usersInt.</item><item>For a slice, users is a better name than userSlice.</item><item>It is acceptable to include a type-like qualifier if there are two versions of a value in scope, for example you might have an input stored in ageString and use age for the parsed value.</item></list><heading level="4">Single-letter variable names</heading><paragraph>Single-letter variable names can be a useful tool to minimize repetition, but can also make code needlessly opaque. Limit their use to instances where the full word is obvious and where it would be repetitive for it to appear in place of the single-letter variable.</paragraph><paragraph>In general:</paragraph><list type="ul"><item>For a method receiver variable, a one-letter or two-letter name is preferred.</item><item>Using familiar variable names for common types is often helpful: r for an io.Reader or *http.Request w for an io.Writer or http.ResponseWriter</item><item>Single-letter identifiers are acceptable as integer loop variables, particularly for indices (e.g., i) and coordinates (e.g., x and y).</item><item>Abbreviations can be acceptable loop identifiers when the scope is short, for example for _, n := range nodes { ... }.</item></list><list type="ul"><item>r for an io.Reader or *http.Request</item><item>w for an io.Writer or http.ResponseWriter</item></list><heading level="3">Repetition</heading><paragraph>A piece of Go source code should avoid unnecessary repetition. One common source of this is repetitive names, which often include unnecessary words or repeat their context or type. Code itself can also be unnecessarily repetitive if the same or a similar code segment appears multiple times in close proximity.</paragraph><paragraph>Repetitive naming can come in many forms, including:</paragraph><heading level="4">Package vs. exported symbol name</heading><paragraph>When naming exported symbols, the name of the package is always visible outside your package, so redundant information between the two should be reduced or eliminated. If a package exports only one type and it is named after the package itself, the canonical name for the constructor is New if one is required.</paragraph><paragraph>Examples: Repetitive Name -> Better Name</paragraph><list type="ul"><item>widget.NewWidget -> widget.New</item><item>widget.NewWidgetWithName -> widget.NewWithName</item><item>db.LoadFromDatabase -> db.Load</item><item>goatteleportutil.CountGoatsTeleported -> gtutil.CountGoatsTeleported or goatteleport.Count</item><item>myteampb.MyTeamMethodRequest -> mtpb.MyTeamMethodRequest or myteampb.MethodRequest</item></list><heading level="4">Variable name vs. type</heading><paragraph>The compiler always knows the type of a variable, and in most cases it is also clear to the reader what type a variable is by how it is used. It is only necessary to clarify the type of a variable if its value appears twice in the same scope.</paragraph><table><thead><tr><th>Repetitive Name</th><th>Better Name</th></tr></thead><tbody><tr><td>var numUsers int</td><td>var users int</td></tr><tr><td>var nameString string</td><td>var name string</td></tr><tr><td>var primaryProject *Project</td><td>var primary *Project</td></tr></tbody></table><paragraph>If the value appears in multiple forms, this can be clarified either with an extra word like raw and parsed or with the underlying representation:</paragraph><code language="code">// Good:
limitStr := r.FormValue("limit")
limit, err := strconv.Atoi(limitStr)
</code><code language="code">// Good:
limitRaw := r.FormValue("limit")
limit, err := strconv.Atoi(limitRaw)
</code><heading level="4">External context vs. local names</heading><paragraph>Names that include information from their surrounding context often create extra noise without benefit. The package name, method name, type name, function name, import path, and even filename can all provide context that automatically qualifies all names within.</paragraph><code language="code">// Bad:
// In package "ads/targeting/revenue/reporting"
type AdsTargetingRevenueReport struct{}

func (p *Project) ProjectName() string
</code><code language="code">// Good:
// In package "ads/targeting/revenue/reporting"
type Report struct{}

func (p *Project) Name() string
</code><code language="code">// Bad:
// In package "sqldb"
type DBConnection struct{}
</code><code language="code">// Good:
// In package "sqldb"
type Connection struct{}
</code><code language="javascript">// Bad:
// In package "ads/targeting"
func Process(in *pb.FooProto) *Report {
    adsTargetingID := in.GetAdsTargetingID()
}
</code><code language="javascript">// Good:
// In package "ads/targeting"
func Process(in *pb.FooProto) *Report {
    id := in.GetAdsTargetingID()
}
</code><paragraph>Repetition should generally be evaluated in the context of the user of the symbol, rather than in isolation. For example, the following code has lots of names that may be fine in some circumstances, but redundant in context:</paragraph><code language="javascript">// Bad:
func (db *DB) UserCount() (userCount int, err error) {
    var userCountInt64 int64
    if dbLoadError := db.LoadFromDatabase("count(distinct users)", &userCountInt64); dbLoadError != nil {
        return 0, fmt.Errorf("failed to load user count: %s", dbLoadError)
    }
    userCount = int(userCountInt64)
    return userCount, nil
}
</code><paragraph>Instead, information about names that are clear from context or usage can often be omitted:</paragraph><code language="javascript">// Good:
func (db *DB) UserCount() (int, error) {
    var count int64
    if err := db.Load("count(distinct users)", &count); err != nil {
        return 0, fmt.Errorf("failed to load user count: %s", err)
    }
    return int(count), nil
}
</code><paragraph>The conventions around commentary (which include what to comment, what style to use, how to provide runnable examples, etc.) are intended to support the experience of reading the documentation of a public API. See Effective Go for more information.</paragraph><paragraph>The best practices document's section on documentation conventions discusses this further.</paragraph><paragraph>Best Practice: Use doc preview during development and code review to see whether the documentation and runnable examples are useful and are presented the way you expect them to be.</paragraph><paragraph>Tip: Godoc uses very little special formatting; lists and code snippets should usually be indented to avoid linewrapping. Apart from indentation, decoration should generally be avoided.</paragraph><paragraph>Ensure that commentary is readable from source even on narrow screens.</paragraph><paragraph>When a comment gets too long, it is recommended to wrap it into multiple single-line comments. When possible, aim for comments that will read well on an 80-column wide terminal, however this is not a hard cut-off; there is no fixed line length limit for comments in Go. The standard library, for example, often chooses to break a comment based on punctuation, which sometimes leaves the individual lines closer to the 60-70 character mark.</paragraph><paragraph>There is plenty of existing code in which comments exceed 80 characters in length. This guidance should not be used as a justification to change such code as part of a readability review (see consistency), though teams are encouraged to opportunistically update comments to follow this guideline as a part of other refactors. The primary goal of this guideline is to ensure that all Go readability mentors make the same recommendation when and if recommendations are made.</paragraph><paragraph>See this post from The Go Blog on documentation for more on commentary.</paragraph><code language="code"># Good:
// This is a comment paragraph.
// The length of individual lines doesn't matter in Godoc;
// but the choice of wrapping makes it easy to read on narrow screens.
//
// Don't worry too much about the long URL:
// https://supercalifragilisticexpialidocious.example.com:8080/Animalia/Chordata/Mammalia/Rodentia/Geomyoidea/Geomyidae/
//
// Similarly, if you have other information that is made awkward
// by too many line breaks, use your judgment and include a long line
// if it helps rather than hinders.
</code><paragraph>Avoid comments that will wrap repeatedly on small screens, which is a poor reader experience.</paragraph><code language="code"># Bad:
// This is a comment paragraph. The length of individual lines doesn't matter in
Godoc;
// but the choice of wrapping causes jagged lines on narrow screens or in code
review,
// which can be annoying, especially when in a comment block that will wrap
repeatedly.
//
// Don't worry too much about the long URL:
// https://supercalifragilisticexpialidocious.example.com:8080/Animalia/Chordata/Mammalia/Rodentia/Geomyoidea/Geomyidae/
</code><paragraph>All top-level exported names must have doc comments, as should unexported type or function declarations with unobvious behavior or meaning. These comments should be full sentences that begin with the name of the object being described. An article ("a", "an", "the") can precede the name to make it read more naturally.</paragraph><code language="go">// Good:
// A Request represents a request to run a command.
type Request struct { ...

// Encode writes the JSON encoding of req to w.
func Encode(w io.Writer, req *Request) { ...
</code><paragraph>Doc comments appear in Godoc and are surfaced by IDEs, and therefore should be written for anyone using the package.</paragraph><paragraph>A documentation comment applies to the following symbol, or the group of fields if it appears in a struct.</paragraph><code language="javascript">// Good:
// Options configure the group management service.
type Options struct {
    // General setup:
    Name  string
    Group *FooGroup

    // Dependencies:
    DB *sql.DB

    // Customization:
    LargeGroupThreshold int // optional; default: 10
    MinimumMembers      int // optional; default: 2
}
</code><paragraph>Best Practice: If you have doc comments for unexported code, follow the same custom as if it were exported (namely, starting the comment with the unexported name). This makes it easy to export it later by simply replacing the unexported name with the newly-exported one across both comments and code.</paragraph><paragraph>Comments that are complete sentences should be capitalized and punctuated like standard English sentences. (As an exception, it is okay to begin a sentence with an uncapitalized identifier name if it is otherwise clear. Such cases are probably best done only at the beginning of a paragraph.)</paragraph><paragraph>Comments that are sentence fragments have no such requirements for punctuation or capitalization.</paragraph><paragraph>Documentation comments should always be complete sentences, and as such should always be capitalized and punctuated. Simple end-of-line comments (especially for struct fields) can be simple phrases that assume the field name is the subject.</paragraph><code language="javascript">// Good:
// A Server handles serving quotes from the collected works of Shakespeare.
type Server struct {
    // BaseDir points to the base directory under which Shakespeare's works are stored.
    //
    // The directory structure is expected to be the following:
    //   {BaseDir}/manifest.json
    //   {BaseDir}/{name}/{name}-part{number}.txt
    BaseDir string

    WelcomeMessage  string // displayed when user logs in
    ProtocolVersion string // checked against incoming requests
    PageLength      int    // lines per page when printing (optional; default: 20)
}
</code><heading level="3">Examples</heading><paragraph>Packages should clearly document their intended usage. Try to provide a runnable example; examples show up in Godoc. Runnable examples belong in the test file, not the production source file. See this example (Godoc, source).</paragraph><paragraph>If it isn't feasible to provide a runnable example, example code can be provided within code comments. As with other code and command-line snippets in comments, it should follow standard formatting conventions.</paragraph><heading level="3">Named result parameters</heading><paragraph>When naming parameters, consider how function signatures appear in Godoc. The name of the function itself and the type of the result parameters are often sufficiently clear.</paragraph><code language="code">// Good:
func (n *Node) Parent1() *Node
func (n *Node) Parent2() (*Node, error)
</code><paragraph>If a function returns two or more parameters of the same type, adding names can be useful.</paragraph><code language="code">// Good:
func (n *Node) Children() (left, right *Node, err error)
</code><paragraph>If the caller must take action on particular result parameters, naming them can help suggest what the action is:</paragraph><code language="go">// Good:
// WithTimeout returns a context that will be canceled no later than d duration
// from now.
//
// The caller must arrange for the returned cancel function to be called when
// the context is no longer needed to prevent a resource leak.
func WithTimeout(parent Context, d time.Duration) (ctx Context, cancel func())
</code><paragraph>In the code above, cancellation is a particular action a caller must take. However, were the result parameters written as (Context, func()) alone, it would be unclear what is meant by "cancel function".</paragraph><paragraph>Don't use named result parameters when the names produce unnecessary repetition.</paragraph><code language="code">// Bad:
func (n *Node) Parent1() (node *Node)
func (n *Node) Parent2() (node *Node, err error)
</code><paragraph>Don't name result parameters in order to avoid declaring a variable inside the function. This practice results in unnecessary API verbosity at the cost of minor implementation brevity.</paragraph><paragraph>Naked returns are acceptable only in a small function. Once it's a medium-sized function, be explicit with your returned values. Similarly, do not name result parameters just because it enables you to use naked returns. Clarity is always more important than saving a few lines in your function.</paragraph><paragraph>It is always acceptable to name a result parameter if its value must be changed in a deferred closure.</paragraph><paragraph>Tip: Types can often be clearer than names in function signatures. GoTip #38: Functions as Named Types demonstrates this.</paragraph><paragraph>In, WithTimeout above, the real code uses a CancelFunc instead of a raw func() in the result parameter list and requires little effort to document.</paragraph><paragraph>Package comments must appear immediately above the package clause with no blank line between the comment and the package name. Example:</paragraph><code language="code">// Good:
// Package math provides basic constants and mathematical functions.
//
// This package does not guarantee bit-identical results across architectures.
package math
</code><paragraph>There must be a single package comment per package. If a package is composed of multiple files, exactly one of the files should have a package comment.</paragraph><paragraph>Comments for main packages have a slightly different form, where the name of the go_binary rule in the BUILD file takes the place of the package name.</paragraph><code language="go">// Good:
// The seed_generator command is a utility that generates a Finch seed file
// from a set of JSON study configs.
package main
</code><paragraph>Other styles of comment are fine as long as the name of the binary is exactly as written in the BUILD file. When the binary name is the first word, capitalizing it is required even though it does not strictly match the spelling of the command-line invocation.</paragraph><code language="code">// Good:
// Binary seed_generator ...
// Command seed_generator ...
// Program seed_generator ...
// The seed_generator command ...
// The seed_generator program ...
// Seed_generator ...
</code><paragraph>Tips:</paragraph><list type="ul"><item>Example command-line invocations and API usage can be useful documentation. For Godoc formatting, indent the comment lines containing code.</item><item>If there is no obvious primary file or if the package comment is extraordinarily long, it is acceptable to put the doc comment in a file named doc.go with only the comment and the package clause.</item><item>Multiline comments can be used instead of multiple single-line comments. This is primarily useful if the documentation contains sections which may be useful to copy and paste from the source file, as with sample command-lines (for binaries) and template examples. // Good: /* The seed_generator command is a utility that generates a Finch seed file from a set of JSON study configs. seed_generator *.json | base64 > finch-seed.base64 */ package template</item><item>Comments intended for maintainers and that apply to the whole file are typically placed after import declarations. These are not surfaced in Godoc and are not subject to the rules above on package comments.</item></list><paragraph>Example command-line invocations and API usage can be useful documentation. For Godoc formatting, indent the comment lines containing code.</paragraph><paragraph>If there is no obvious primary file or if the package comment is extraordinarily long, it is acceptable to put the doc comment in a file named doc.go with only the comment and the package clause.</paragraph><paragraph>Multiline comments can be used instead of multiple single-line comments. This is primarily useful if the documentation contains sections which may be useful to copy and paste from the source file, as with sample command-lines (for binaries) and template examples.</paragraph><code language="code">// Good:
/*
The seed_generator command is a utility that generates a Finch seed file
from a set of JSON study configs.

    seed_generator *.json | base64 > finch-seed.base64
*/
package template
</code><paragraph>Comments intended for maintainers and that apply to the whole file are typically placed after import declarations. These are not surfaced in Godoc and are not subject to the rules above on package comments.</paragraph><heading level="2">Imports</heading><heading level="3">Import renaming</heading><paragraph>Package imports shouldn't normally be renamed, but there are cases where they must be renamed or where a rename improves readability.</paragraph><paragraph>Local names for imported packages must follow the guidance around package naming, including the prohibition on the use of underscores and capital letters. Try to be consistent by always using the same local name for the same imported package.</paragraph><paragraph>An imported package must be renamed to avoid a name collision with other imports. (A corollary of this is that good package names should not require renaming.) In the event of a name collision, prefer to rename the most local or project-specific import.</paragraph><paragraph>Generated protocol buffer packages must be renamed to remove underscores from their names, and their local names must have a pb suffix. See [proto and stub best practices] for more information.</paragraph><code language="javascript">// Good:
import (
    fspb "path/to/package/foo_service_go_proto"
)
</code><paragraph>Lastly, an imported, non-autogenerated package can be renamed if it has an uninformative name (e.g. util or v1) Do this sparingly: do not rename the package if the code surrounding the use of the package conveys enough context. When possible, prefer refactoring the package itself with a more suitable name.</paragraph><code language="javascript">// Good:
import (
    core "github.com/kubernetes/api/core/v1"
    meta "github.com/kubernetes/apimachinery/pkg/apis/meta/v1beta1"
)
</code><paragraph>If you need to import a package whose name collides with a common local variable name that you want to use (e.g. url, ssh) and you wish to rename the package, the preferred way to do so is with the pkg suffix (e.g. urlpkg). Note that it is possible to shadow a package with a local variable; this rename is only necessary if the package still needs to be used when such a variable is in scope.</paragraph><heading level="3">Import grouping</heading><paragraph>Imports should be organized in two groups:</paragraph><code language="javascript">// Good:
package main

import (
    "fmt"
    "hash/adler32"
    "os"

    "github.com/dsnet/compress/flate"
    "golang.org/x/text/encoding"
    "google.golang.org/protobuf/proto"
    foopb "myproj/foo/proto/proto"
    _ "myproj/rpc/protocols/dial"
    _ "myproj/security/auth/authhooks"
)
</code><paragraph>It is acceptable to split the project packages into multiple groups if you want a separate group, as long as the groups have some meaning. Common reasons to do this:</paragraph><list type="ul"><item>renamed imports</item><item>packages imported for their side-effects</item></list><paragraph>Example:</paragraph><code language="javascript">// Good:
package main

import (
    "fmt"
    "hash/adler32"
    "os"


    "github.com/dsnet/compress/flate"
    "golang.org/x/text/encoding"
    "google.golang.org/protobuf/proto"

    foopb "myproj/foo/proto/proto"

    _ "myproj/rpc/protocols/dial"
    _ "myproj/security/auth/authhooks"
)
</code><paragraph>Note: Maintaining optional groups - splitting beyond what is necessary for the mandatory separation between standard library and Google imports - is not supported by the goimports tool. Additional import subgroups require attention on the part of both authors and reviewers to maintain in a conforming state.</paragraph><paragraph>Google programs that are also AppEngine apps should have a separate group for AppEngine imports.</paragraph><paragraph>Gofmt takes care of sorting each group by import path. However, it does not automatically separate imports into groups. The popular goimports tool combines Gofmt and import management, separating imports into groups based on the decision above. It is permissible to let goimports manage import arrangement entirely, but as a file is revised its import list must remain internally consistent.</paragraph><heading level="3">Import "blank" (import _)</heading><paragraph>Packages that are imported only for their side effects (using the syntax import _ "package") may only be imported in a main package, or in tests that require them.</paragraph><paragraph>Some examples of such packages include:</paragraph><paragraph>Avoid blank imports in library packages, even if the library indirectly depends on them. Constraining side-effect imports to the main package helps control dependencies, and makes it possible to write tests that rely on a different import without conflict or wasted build costs.</paragraph><paragraph>The following are the only exceptions to this rule:</paragraph><list type="ul"><item>You may use a blank import to bypass the check for disallowed imports in the nogo static checker.</item><item>You may use a blank import of the embed package in a source file which uses the //go:embed compiler directive.</item></list><paragraph>You may use a blank import to bypass the check for disallowed imports in the nogo static checker.</paragraph><paragraph>You may use a blank import of the embed package in a source file which uses the //go:embed compiler directive.</paragraph><paragraph>Tip: If you create a library package that indirectly depends on a side-effect import in production, document the intended usage.</paragraph><heading level="3">Import "dot" (import .)</heading><paragraph>The import . form is a language feature that allows bringing identifiers exported from another package to the current package without qualification. See the language spec for more.</paragraph><paragraph>Do not use this feature in the Google codebase; it makes it harder to tell where the functionality is coming from.</paragraph><code language="javascript">// Bad:
package foo_test

import (
    "bar/testutil" // also imports "foo"
    . "foo"
)

var myThing = Bar() // Bar defined in package foo; no qualification needed.
</code><code language="javascript">// Good:
package foo_test

import (
    "bar/testutil" // also imports "foo"
    "foo"
)

var myThing = foo.Bar()
</code><heading level="2">Errors</heading><heading level="3">Returning errors</heading><paragraph>Use error to signal that a function can fail. By convention, error is the last result parameter.</paragraph><code language="go">// Good:
func Good() error { /* ... */ }
</code><paragraph>Returning a nil error is the idiomatic way to signal a successful operation that could otherwise fail. If a function returns an error, callers must treat all non-error return values as unspecified unless explicitly documented otherwise. Commonly, the non-error return values are their zero values, but this cannot be assumed.</paragraph><code language="javascript">// Good:
func GoodLookup() (*Result, error) {
    // ...
    if err != nil {
        return nil, err
    }
    return res, nil
}
</code><paragraph>Exported functions that return errors should return them using the error type. Concrete error types are susceptible to subtle bugs: a concrete nil pointer can get wrapped into an interface and thus become a non-nil value (see the Go FAQ entry on the topic).</paragraph><code language="go">// Bad:
func Bad() *os.PathError { /*...*/ }
</code><paragraph>Tip: A function that takes a context.Context argument should usually return an error so that the caller can determine if the context was cancelled while the function was running.</paragraph><heading level="3">Error strings</heading><paragraph>Error strings should not be capitalized (unless beginning with an exported name, a proper noun or an acronym) and should not end with punctuation. This is because error strings usually appear within other context before being printed to the user.</paragraph><code language="code">// Bad:
err := fmt.Errorf("Something bad happened.")
</code><code language="code">// Good:
err := fmt.Errorf("something bad happened")
</code><paragraph>On the other hand, the style for the full displayed message (logging, test failure, API response, or other UI) depends, but should typically be capitalized.</paragraph><code language="code">// Good:
log.Infof("Operation aborted: %v", err)
log.Errorf("Operation aborted: %v", err)
t.Errorf("Op(%q) failed unexpectedly; err=%v", args, err)
</code><heading level="3">Handle errors</heading><paragraph>Code that encounters an error should make a deliberate choice about how to handle it. It is not usually appropriate to discard errors using _ variables. If a function returns an error, do one of the following:</paragraph><list type="ul"><item>Handle and address the error immediately.</item><item>Return the error to the caller.</item><item>In exceptional situations, call log.Fatal or (if absolutely necessary) panic.</item></list><paragraph>Note: log.Fatalf is not the standard library log. See [#logging].</paragraph><paragraph>In the rare circumstance where it is appropriate to ignore or discard an error (for example a call to (*bytes.Buffer).Write that is documented to never fail), an accompanying comment should explain why this is safe.</paragraph><code language="javascript">// Good:
var b *bytes.Buffer

n, _ := b.Write(p) // never returns a non-nil error
</code><paragraph>For more discussion and examples of error handling, see Effective Go and best practices.</paragraph><heading level="3">In-band errors</heading><paragraph>In C and similar languages, it is common for functions to return values like -1, null, or the empty string to signal errors or missing results. This is known as in-band error handling.</paragraph><code language="go">// Bad:
// Lookup returns the value for key or -1 if there is no mapping for key.
func Lookup(key string) int
</code><paragraph>Failing to check for an in-band error value can lead to bugs and can attribute errors to the wrong function.</paragraph><code language="code">// Bad:
// The following line returns an error that Parse failed for the input value,
// whereas the failure was that there is no mapping for missingKey.
return Parse(Lookup(missingKey))
</code><paragraph>Go's support for multiple return values provides a better solution (see the Effective Go section on multiple returns). Instead of requiring clients to check for an in-band error value, a function should return an additional value to indicate whether its other return values are valid. This return value may be an error or a boolean when no explanation is needed, and should be the final return value.</paragraph><code language="go">// Good:
// Lookup returns the value for key or ok=false if there is no mapping for key.
func Lookup(key string) (value string, ok bool)
</code><paragraph>This API prevents the caller from incorrectly writing Parse(Lookup(key)) which causes a compile-time error, since Lookup(key) has 2 outputs.</paragraph><paragraph>Returning errors in this way encourages more robust and explicit error handling:</paragraph><code language="javascript">// Good:
value, ok := Lookup(key)
if !ok {
    return fmt.Errorf("no value for %q", key)
}
return Parse(value)
</code><paragraph>Some standard library functions, like those in package strings, return in-band error values. This greatly simplifies string-manipulation code at the cost of requiring more diligence from the programmer. In general, Go code in the Google codebase should return additional values for errors.</paragraph><heading level="3">Indent error flow</heading><paragraph>Handle errors before proceeding with the rest of your code. This improves the readability of the code by enabling the reader to find the normal path quickly. This same logic applies to any block which tests a condition then ends in a terminal condition (e.g., return, panic, log.Fatal).</paragraph><paragraph>Code that runs if the terminal condition is not met should appear after the if block, and should not be indented in an else clause.</paragraph><code language="javascript">// Good:
if err != nil {
    // error handling
    return // or continue, etc.
}
// normal code
</code><code language="javascript">// Bad:
if err != nil {
    // error handling
} else {
    // normal code that looks abnormal due to indentation
}
</code><paragraph>Tip: If you are using a variable for more than a few lines of code, it is generally not worth using the if-with-initializer style. In these cases, it is usually better to move the declaration out and use a standard if statement:</paragraph><code language="javascript">// Good:
x, err := f()
if err != nil {
  // error handling
  return
}
// lots of code that uses x
// across multiple lines
</code><code language="javascript">// Bad:
if x, err := f(); err != nil {
  // error handling
  return
} else {
  // lots of code that uses x
  // across multiple lines
}
</code><paragraph>See Go Tip #1: Line of Sight and TotT: Reduce Code Complexity by Reducing Nesting for more details.</paragraph><heading level="2">Language</heading><heading level="3">Literal formatting</heading><paragraph>Go has an exceptionally powerful composite literal syntax, with which it is possible to express deeply-nested, complicated values in a single expression. Where possible, this literal syntax should be used instead of building values field-by-field. The gofmt formatting for literals is generally quite good, but there are some additional rules for keeping these literals readable and maintainable.</paragraph><heading level="4">Field names</heading><paragraph>Struct literals must specify field names for types defined outside the current package.</paragraph><list type="ul"><item>Include field names for types from other packages. // Good: // https://pkg.go.dev/encoding/csv#Reader r := csv.Reader{ Comma: ',', Comment: '#', FieldsPerRecord: 4, } The position of fields in a struct and the full set of fields (both of which are necessary to get right when field names are omitted) are not usually considered to be part of a struct's public API; specifying the field name is needed to avoid unnecessary coupling. // Bad: r := csv.Reader{',', '#', 4, false, false, false, false}</item><item>For package-local types, field names are optional. // Good: okay := Type{42} also := internalType{4, 2} Field names should still be used if it makes the code clearer, and it is very common to do so. For example, a struct with a large number of fields should almost always be initialized with field names. // Good: okay := StructWithLotsOfFields{ field1: 1, field2: "two", field3: 3.14, field4: true, }</item></list><paragraph>Include field names for types from other packages.</paragraph><code language="javascript">// Good:
// https://pkg.go.dev/encoding/csv#Reader
r := csv.Reader{
  Comma: ',',
  Comment: '#',
  FieldsPerRecord: 4,
}
</code><paragraph>The position of fields in a struct and the full set of fields (both of which are necessary to get right when field names are omitted) are not usually considered to be part of a struct's public API; specifying the field name is needed to avoid unnecessary coupling.</paragraph><code language="code">// Bad:
r := csv.Reader{',', '#', 4, false, false, false, false}
</code><paragraph>For package-local types, field names are optional.</paragraph><code language="code">// Good:
okay := Type{42}
also := internalType{4, 2}
</code><paragraph>Field names should still be used if it makes the code clearer, and it is very common to do so. For example, a struct with a large number of fields should almost always be initialized with field names.</paragraph><code language="javascript">// Good:
okay := StructWithLotsOfFields{
  field1: 1,
  field2: "two",
  field3: 3.14,
  field4: true,
}
</code><heading level="4">Matching braces</heading><paragraph>The closing half of a brace pair should always appear on a line with the same amount of indentation as the opening brace. One-line literals necessarily have this property. When the literal spans multiple lines, maintaining this property keeps the brace matching for literals the same as brace matching for common Go syntactic constructs like functions and if statements.</paragraph><paragraph>The most common mistake in this area is putting the closing brace on the same line as a value in a multi-line struct literal. In these cases, the line should end with a comma and the closing brace should appear on the next line.</paragraph><code language="code">// Good:
good := []*Type{{Key: "value"}}
</code><code language="javascript">// Good:
good := []*Type{
    {Key: "multi"},
    {Key: "line"},
}
</code><code language="javascript">// Bad:
bad := []*Type{
    {Key: "multi"},
    {Key: "line"}}
</code><code language="javascript">// Bad:
bad := []*Type{
    {
        Key: "value"},
}
</code><heading level="4">Cuddled braces</heading><paragraph>Dropping whitespace between braces (aka "cuddling" them) for slice and array literals is only permitted when both of the following are true.</paragraph><list type="ul"><item>The indentation matches</item><item>The inner values are also literals or proto builders (i.e. not a variable or other expression)</item></list><code language="javascript">// Good:
good := []*Type{
    { // Not cuddled
        Field: "value",
    },
    {
        Field: "value",
    },
}
</code><code language="javascript">// Good:
good := []*Type{{ // Cuddled correctly
    Field: "value",
}, {
    Field: "value",
}}
</code><code language="javascript">// Good:
good := []*Type{
    first, // Can't be cuddled
    {Field: "second"},
}
</code><code language="javascript">// Good:
okay := []*pb.Type{pb.Type_builder{
    Field: "first", // Proto Builders may be cuddled to save vertical space
}.Build(), pb.Type_builder{
    Field: "second",
}.Build()}
</code><code language="javascript">// Bad:
bad := []*Type{
    first,
    {
        Field: "second",
    }}
</code><heading level="4">Repeated type names</heading><paragraph>Repeated type names may be omitted from slice and map literals. This can be helpful in reducing clutter. A reasonable occasion for repeating the type names explicitly is when dealing with a complex type that is not common in your project, when the repetitive type names are on lines that are far apart and can remind the reader of the context.</paragraph><code language="javascript">// Good:
good := []*Type{
    {A: 42},
    {A: 43},
}
</code><code language="javascript">// Bad:
repetitive := []*Type{
    &Type{A: 42},
    &Type{A: 43},
}
</code><code language="javascript">// Good:
good := map[Type1]*Type2{
    {A: 1}: {B: 2},
    {A: 3}: {B: 4},
}
</code><code language="javascript">// Bad:
repetitive := map[Type1]*Type2{
    Type1{A: 1}: &Type2{B: 2},
    Type1{A: 3}: &Type2{B: 4},
}
</code><paragraph>Tip: If you want to remove repetitive type names in struct literals, you can run gofmt -s.</paragraph><heading level="4">Zero-value fields</heading><paragraph>Zero-value fields may be omitted from struct literals when clarity is not lost as a result.</paragraph><paragraph>Well-designed APIs often employ zero-value construction for enhanced readability. For example, omitting the three zero-value fields from the following struct draws attention to the only option that is being specified.</paragraph><code language="javascript">// Bad:
import (
  "github.com/golang/leveldb"
  "github.com/golang/leveldb/db"
)

ldb := leveldb.Open("/my/table", &db.Options{
    BlockSize: 1<<16,
    ErrorIfDBExists: true,

    // These fields all have their zero values.
    BlockRestartInterval: 0,
    Comparer: nil,
    Compression: nil,
    FileSystem: nil,
    FilterPolicy: nil,
    MaxOpenFiles: 0,
    WriteBufferSize: 0,
    VerifyChecksums: false,
})
</code><code language="javascript">// Good:
import (
  "github.com/golang/leveldb"
  "github.com/golang/leveldb/db"
)

ldb := leveldb.Open("/my/table", &db.Options{
    BlockSize: 1<<16,
    ErrorIfDBExists: true,
})
</code><paragraph>Structs within table-driven tests often benefit from explicit field names, especially when the test struct is not trivial. This allows the author to omit the zero-valued fields entirely when the fields in question are not related to the test case. For example, successful test cases should omit any error-related or failure-related fields. In cases where the zero value is necessary to understand the test case, such as testing for zero or nil inputs, the field names should be specified.</paragraph><paragraph>Concise</paragraph><code language="javascript">tests := []struct {
    input      string
    wantPieces []string
    wantErr    error
}{
    {
        input:      "1.2.3.4",
        wantPieces: []string{"1", "2", "3", "4"},
    },
    {
        input:   "hostname",
        wantErr: ErrBadHostname,
    },
}
</code><paragraph>Explicit</paragraph><code language="javascript">tests := []struct {
    input    string
    wantIPv4 bool
    wantIPv6 bool
    wantErr  bool
}{
    {
        input:    "1.2.3.4",
        wantIPv4: true,
        wantIPv6: false,
    },
    {
        input:    "1:2::3:4",
        wantIPv4: false,
        wantIPv6: true,
    },
    {
        input:    "hostname",
        wantIPv4: false,
        wantIPv6: false,
        wantErr:  true,
    },
}
</code><heading level="3">Nil slices</heading><paragraph>For most purposes, there is no functional difference between nil and the empty slice. Built-in functions like len and cap behave as expected on nil slices.</paragraph><code language="javascript">// Good:
import "fmt"

var s []int         // nil

fmt.Println(s)      // []
fmt.Println(len(s)) // 0
fmt.Println(cap(s)) // 0
for range s {...}   // no-op

s = append(s, 42)
fmt.Println(s)      // [42]
</code><paragraph>If you declare an empty slice as a local variable (especially if it can be the source of a return value), prefer the nil initialization to reduce the risk of bugs by callers.</paragraph><paragraph>Do not create APIs that force their clients to make distinctions between nil and the empty slice.</paragraph><code language="go">// Good:
// Ping pings its targets.
// Returns hosts that successfully responded.
func Ping(hosts []string) ([]string, error) { ... }
</code><code language="go">// Bad:
// Ping pings its targets and returns a list of hosts
// that successfully responded. Can be empty if the input was empty.
// nil signifies that a system error occurred.
func Ping(hosts []string) []string { ... }
</code><paragraph>When designing interfaces, avoid making a distinction between a nil slice and a non-nil, zero-length slice, as this can lead to subtle programming errors. This is typically accomplished by using len to check for emptiness, rather than == nil.</paragraph><paragraph>This implementation accepts both nil and zero-length slices as "empty":</paragraph><code language="javascript">// Good:
// describeInts describes s with the given prefix, unless s is empty.
func describeInts(prefix string, s []int) {
    if len(s) == 0 {
        return
    }
    fmt.Println(prefix, s)
}
</code><paragraph>Instead of relying on the distinction as a part of the API:</paragraph><code language="javascript">// Bad:
func maybeInts() []int { /* ... */ }

// describeInts describes s with the given prefix; pass nil to skip completely.
func describeInts(prefix string, s []int) {
  // The behavior of this function unintentionally changes depending on what
  // maybeInts() returns in 'empty' cases (nil or []int{}).
  if s == nil {
    return
  }
  fmt.Println(prefix, s)
}

describeInts("Here are some ints:", maybeInts())
</code><paragraph>See in-band errors for further discussion.</paragraph><heading level="3">Indentation confusion</heading><paragraph>Avoid introducing a line break if it would align the rest of the line with an indented code block. If this is unavoidable, leave a space to separate the code in the block from the wrapped line.</paragraph><code language="javascript">// Bad:
if longCondition1 && longCondition2 &&
    // Conditions 3 and 4 have the same indentation as the code within the if.
    longCondition3 && longCondition4 {
    log.Info("all conditions met")
}
</code><paragraph>See the following sections for specific guidelines and examples:</paragraph><heading level="3">Function formatting</heading><paragraph>The signature of a function or method declaration should remain on a single line to avoid indentation confusion.</paragraph><paragraph>Function argument lists can make some of the longest lines in a Go source file. However, they precede a change in indentation, and therefore it is difficult to break the line in a way that does not make subsequent lines look like part of the function body in a confusing way:</paragraph><code language="javascript">// Bad:
func (r *SomeType) SomeLongFunctionName(foo1, foo2, foo3 string,
    foo4, foo5, foo6 int) {
    foo7 := bar(foo1)
    // ...
}
</code><paragraph>See best practices for a few options for shortening the call sites of functions that would otherwise have many arguments.</paragraph><paragraph>Lines can often be shortened by factoring out local variables.</paragraph><code language="code">// Good:
local := helper(some, parameters, here)
good := foo.Call(list, of, parameters, local)
</code><paragraph>Similarly, function and method calls should not be separated based solely on line length.</paragraph><code language="code">// Good:
good := foo.Call(long, list, of, parameters, all, on, one, line)
</code><code language="code">// Bad:
bad := foo.Call(long, list, of, parameters,
    with, arbitrary, line, breaks)
</code><paragraph>Avoid adding inline comments to specific function arguments where possible. Instead, use an option struct or add more detail to the function documentation.</paragraph><code language="code">// Good:
good := server.New(ctx, server.Options{Port: 42})
</code><code language="code">// Bad:
bad := server.New(
    ctx,
    42, // Port
)
</code><paragraph>If the API cannot be changed or if the local call is unusual (whether or not the call is too long), it is always permissible to add line breaks if it aids in understanding the call.</paragraph><code language="code">// Good:
canvas.RenderHeptagon(fillColor,
    x0, y0, vertexColor0,
    x1, y1, vertexColor1,
    x2, y2, vertexColor2,
    x3, y3, vertexColor3,
    x4, y4, vertexColor4,
    x5, y5, vertexColor5,
    x6, y6, vertexColor6,
)
</code><paragraph>Note that the lines in the above example are not wrapped at a specific column boundary but are grouped based on vertex coordinates and color.</paragraph><paragraph>Long string literals within functions should not be broken for the sake of line length. For functions that include such strings, a line break can be added after the string format, and the arguments can be provided on the next or subsequent lines. The decision about where the line breaks should go is best made based on semantic groupings of inputs, rather than based purely on line length.</paragraph><code language="code">// Good:
log.Warningf("Database key (%q, %d, %q) incompatible in transaction started by (%q, %d, %q)",
    currentCustomer, currentOffset, currentKey,
    txCustomer, txOffset, txKey)
</code><code language="code">// Bad:
log.Warningf("Database key (%q, %d, %q) incompatible in"+
    " transaction started by (%q, %d, %q)",
    currentCustomer, currentOffset, currentKey, txCustomer,
    txOffset, txKey)
</code><heading level="3">Conditionals and loops</heading><paragraph>An if statement should not be line broken; multi-line if clauses can lead to indentation confusion.</paragraph><code language="javascript">// Bad:
// The second if statement is aligned with the code within the if block, causing
// indentation confusion.
if db.CurrentStatusIs(db.InTransaction) &&
    db.ValuesEqual(db.TransactionKey(), row.Key()) {
    return db.Errorf(db.TransactionError, "query failed: row (%v): key does not match transaction key", row)
}
</code><paragraph>If the short-circuit behavior is not required, the boolean operands can be extracted directly:</paragraph><code language="javascript">// Good:
inTransaction := db.CurrentStatusIs(db.InTransaction)
keysMatch := db.ValuesEqual(db.TransactionKey(), row.Key())
if inTransaction && keysMatch {
    return db.Error(db.TransactionError, "query failed: row (%v): key does not match transaction key", row)
}
</code><paragraph>There may also be other locals that can be extracted, especially if the conditional is already repetitive:</paragraph><code language="javascript">// Good:
uid := user.GetUniqueUserID()
if db.UserIsAdmin(uid) || db.UserHasPermission(uid, perms.ViewServerConfig) || db.UserHasPermission(uid, perms.CreateGroup) {
    // ...
}
</code><code language="javascript">// Bad:
if db.UserIsAdmin(user.GetUniqueUserID()) || db.UserHasPermission(user.GetUniqueUserID(), perms.ViewServerConfig) || db.UserHasPermission(user.GetUniqueUserID(), perms.CreateGroup) {
    // ...
}
</code><paragraph>if statements that contain closures or multi-line struct literals should ensure that the braces match to avoid indentation confusion.</paragraph><code language="javascript">// Good:
if err := db.RunInTransaction(func(tx *db.TX) error {
    return tx.Execute(userUpdate, x, y, z)
}); err != nil {
    return fmt.Errorf("user update failed: %s", err)
}
</code><code language="javascript">// Good:
if _, err := client.Update(ctx, &upb.UserUpdateRequest{
    ID:   userID,
    User: user,
}); err != nil {
    return fmt.Errorf("user update failed: %s", err)
}
</code><paragraph>Similarly, don't try inserting artificial linebreaks into for statements. You can always let the line simply be long if there is no elegant way to refactor it:</paragraph><code language="javascript">// Good:
for i, max := 0, collection.Size(); i < max && !collection.HasPendingWriters(); i++ {
    // ...
}
</code><paragraph>Often, though, there is:</paragraph><code language="javascript">// Good:
for i, max := 0, collection.Size(); i < max; i++ {
    if collection.HasPendingWriters() {
        break
    }
    // ...
}
</code><paragraph>switch and case statements should also remain on a single line.</paragraph><code language="javascript">// Good:
switch good := db.TransactionStatus(); good {
case db.TransactionStarting, db.TransactionActive, db.TransactionWaiting:
    // ...
case db.TransactionCommitted, db.NoTransaction:
    // ...
default:
    // ...
}
</code><code language="javascript">// Bad:
switch bad := db.TransactionStatus(); bad {
case db.TransactionStarting,
    db.TransactionActive,
    db.TransactionWaiting:
    // ...
case db.TransactionCommitted,
    db.NoTransaction:
    // ...
default:
    // ...
}
</code><paragraph>If the line is excessively long, indent all cases and separate them with a blank line to avoid indentation confusion:</paragraph><code language="javascript">// Good:
switch db.TransactionStatus() {
case
    db.TransactionStarting,
    db.TransactionActive,
    db.TransactionWaiting,
    db.TransactionCommitted:

    // ...
case db.NoTransaction:
    // ...
default:
    // ...
}
</code><paragraph>In conditionals comparing a variable to a constant, place the variable value on the left hand side of the equality operator:</paragraph><code language="javascript">// Good:
if result == "foo" {
  // ...
}
</code><paragraph>Instead of the less clear phrasing where the constant comes first ("Yoda style conditionals"):</paragraph><code language="javascript">// Bad:
if "foo" == result {
  // ...
}
</code><heading level="3">Copying</heading><paragraph>To avoid unexpected aliasing and similar bugs, be careful when copying a struct from another package. For example, synchronization objects such as sync.Mutex must not be copied.</paragraph><paragraph>The bytes.Buffer type contains a []byte slice and, as an optimization for small strings, a small byte array to which the slice may refer. If you copy a Buffer, the slice in the copy may alias the array in the original, causing subsequent method calls to have surprising effects.</paragraph><paragraph>In general, do not copy a value of type T if its methods are associated with the pointer type, *T.</paragraph><code language="code">// Bad:
b1 := bytes.Buffer{}
b2 := b1
</code><paragraph>Invoking a method that takes a value receiver can hide the copy. When you author an API, you should generally take and return pointer types if your structs contain fields that should not be copied.</paragraph><paragraph>These are acceptable:</paragraph><code language="javascript">// Good:
type Record struct {
  buf bytes.Buffer
  // other fields omitted
}

func New() *Record {...}

func (r *Record) Process(...) {...}

func Consumer(r *Record) {...}
</code><paragraph>But these are usually wrong:</paragraph><code language="javascript">// Bad:
type Record struct {
  buf bytes.Buffer
  // other fields omitted
}


func (r Record) Process(...) {...} // Makes a copy of r.buf

func Consumer(r Record) {...} // Makes a copy of r.buf
</code><paragraph>This guidance also applies to copying sync.Mutex.</paragraph><heading level="3">Don't panic</heading><paragraph>Do not use panic for normal error handling. Instead, use error and multiple return values. See the Effective Go section on errors.</paragraph><paragraph>Within package main and initialization code, consider log.Exit for errors that should terminate the program (e.g., invalid configuration), as in many of these cases a stack trace will not help the reader. Please note that log.Exit calls os.Exit and any deferred functions will not be run.</paragraph><paragraph>For errors that indicate "impossible" conditions, namely bugs that should always be caught during code review and/or testing, a function may reasonably return an error or call log.Fatal.</paragraph><paragraph>Also see when panic is acceptable.</paragraph><paragraph>Note: log.Fatalf is not the standard library log. See [#logging].</paragraph><heading level="3">Must functions</heading><paragraph>Setup helper functions that stop the program on failure follow the naming convention MustXYZ (or mustXYZ). In general, they should only be called early on program startup, not on things like user input where normal Go error handling is preferred.</paragraph><paragraph>This often comes up for functions called to initialize package-level variables exclusively at package initialization time (e.g. template.Must and regexp.MustCompile).</paragraph><code language="javascript">// Good:
func MustParse(version string) *Version {
    v, err := Parse(version)
    if err != nil {
        panic(fmt.Sprintf("MustParse(%q) = _, %v", version, err))
    }
    return v
}

// Package level "constant". If we wanted to use `Parse`, we would have had to
// set the value in `init`.
var DefaultVersion = MustParse("1.2.3")
</code><paragraph>The same convention may be used in test helpers that only stop the current test (using t.Fatal). Such helpers are often convenient in creating test values, for example in struct fields of table driven tests, as functions that return errors cannot be directly assigned to a struct field.</paragraph><code language="javascript">// Good:
func mustMarshalAny(t *testing.T, m proto.Message) *anypb.Any {
  t.Helper()
  any, err := anypb.New(m)
  if err != nil {
    t.Fatalf("mustMarshalAny(t, m) = %v; want %v", err, nil)
  }
  return any
}

func TestCreateObject(t *testing.T) {
  tests := []struct{
    desc string
    data *anypb.Any
  }{
    {
      desc: "my test case",
      // Creating values directly within table driven test cases.
      data: mustMarshalAny(t, mypb.Object{}),
    },
    // ...
  }
  // ...
}
</code><paragraph>In both of these cases, the value of this pattern is that the helpers can be called in a "value" context. These helpers should not be called in places where it's difficult to ensure an error would be caught or in a context where an error should be checked (e.g., in many request handlers). For constant inputs, this allows tests to easily ensure that the Must arguments are well-formed, and for non-constant inputs it permits tests to validate that errors are properly handled or propagated.</paragraph><paragraph>Where Must functions are used in a test, they should generally be marked as a test helper and call t.Fatal on error (see error handling in test helpers for more considerations of using that).</paragraph><paragraph>They should not be used when ordinary error handling is possible (including with some refactoring):</paragraph><code language="javascript">// Bad:
func Version(o *servicepb.Object) (*version.Version, error) {
    // Return error instead of using Must functions.
    v := version.MustParse(o.GetVersionString())
    return dealiasVersion(v)
}
</code><heading level="3">Goroutine lifetimes</heading><paragraph>When you spawn goroutines, make it clear when or whether they exit.</paragraph><paragraph>Goroutines can leak by blocking on channel sends or receives. The garbage collector will not terminate a goroutine blocked on a channel even if no other goroutine has a reference to the channel.</paragraph><paragraph>Even when goroutines do not leak, leaving them in-flight when they are no longer needed can cause other subtle and hard-to-diagnose problems. Sending on a channel that has been closed causes a panic.</paragraph><code language="code">// Bad:
ch := make(chan int)
ch <- 42
close(ch)
ch <- 13 // panic
</code><paragraph>Modifying still-in-use inputs "after the result isn't needed" can lead to data races. Leaving goroutines in-flight for arbitrarily long can lead to unpredictable memory usage.</paragraph><paragraph>Concurrent code should be written such that the goroutine lifetimes are obvious. Typically this will mean keeping synchronization-related code constrained within the scope of a function and factoring out the logic into synchronous functions. If the concurrency is still not obvious, it is important to document when and why the goroutines exit.</paragraph><paragraph>Code that follows best practices around context usage often helps make this clear. It is conventionally managed with a context.Context:</paragraph><code language="javascript">// Good:
func (w *Worker) Run(ctx context.Context) error {
    var wg sync.WaitGroup
    // ...
    for item := range w.q {
        // process returns at latest when the context is cancelled.
        wg.Add(1)
        go func() {
            defer wg.Done()
            process(ctx, item)
        }()
    }
    // ...
    wg.Wait()  // Prevent spawned goroutines from outliving this function.
}
</code><paragraph>There are other variants of the above that use raw signal channels like chan struct{}, synchronized variables, condition variables, and more. The important part is that the goroutine's end is evident for subsequent maintainers.</paragraph><paragraph>In contrast, the following code is careless about when its spawned goroutines finish:</paragraph><code language="javascript">// Bad:
func (w *Worker) Run() {
    // ...
    for item := range w.q {
        // process returns when it finishes, if ever, possibly not cleanly
        // handling a state transition or termination of the Go program itself.
        go process(item)
    }
    // ...
}
</code><paragraph>This code may look OK, but there are several underlying problems:</paragraph><list type="ul"><item>The code probably has undefined behavior in production, and the program may not terminate cleanly, even if the operating system releases the resources.</item><item>The code is difficult to test meaningfully due to the code's indeterminate lifecycle.</item><item>The code may leak resources as described above.</item></list><paragraph>The code probably has undefined behavior in production, and the program may not terminate cleanly, even if the operating system releases the resources.</paragraph><paragraph>The code is difficult to test meaningfully due to the code's indeterminate lifecycle.</paragraph><paragraph>The code may leak resources as described above.</paragraph><paragraph>See also:</paragraph><heading level="3">Interfaces</heading><paragraph>Go interfaces generally belong in the package that consumes values of the interface type, not a package that implements the interface type. The implementing package should return concrete (usually pointer or struct) types. That way, new methods can be added to implementations without requiring extensive refactoring. See GoTip #49: Accept Interfaces, Return Concrete Types for more details.</paragraph><paragraph>Do not export a test double implementation of an interface from an API that consumes it. Instead, design the API so that it can be tested using the public API of the real implementation. See GoTip #42: Authoring a Stub for Testing for more details. Even when it is not feasible to use the real implementation, it may not be necessary to introduce an interface fully covering all methods in the real type; the consumer can create an interface containing only the methods it needs, as demonstrated in GoTip #78: Minimal Viable Interfaces.</paragraph><paragraph>To test packages that use Stubby RPC clients, use a real client connection. If a real server cannot be run in the test, Google's internal practice is to obtain a real client connection to a local test double using the internal rpctest package (coming soon!).</paragraph><paragraph>Do not define interfaces before they are used (see TotT: Code Health: Eliminate YAGNI Smells ). Without a realistic example of usage, it is too difficult to see whether an interface is even necessary, let alone what methods it should contain.</paragraph><paragraph>Do not use interface-typed parameters if the users of the package do not need to pass different types for them.</paragraph><paragraph>Do not export interfaces that the users of the package do not need.</paragraph><paragraph>TODO: Write a more in-depth doc on interfaces and link to it here.</paragraph><code language="go">// Good:
package consumer // consumer.go

type Thinger interface { Thing() bool }

func Foo(t Thinger) string { ... }
</code><code language="code">// Good:
package consumer // consumer_test.go

type fakeThinger struct{ ... }
func (t fakeThinger) Thing() bool { ... }
...
if Foo(fakeThinger{...}) == "x" { ... }
</code><code language="go">// Bad:
package producer

type Thinger interface { Thing() bool }

type defaultThinger struct{ ... }
func (t defaultThinger) Thing() bool { ... }

func NewThinger() Thinger { return defaultThinger{ ... } }
</code><code language="go">// Good:
package producer

type Thinger struct{ ... }
func (t Thinger) Thing() bool { ... }

func NewThinger() Thinger { return Thinger{ ... } }
</code><heading level="3">Generics</heading><paragraph>Generics (formally called "Type Parameters") are allowed where they fulfill your business requirements. In many applications, a conventional approach using existing language features (slices, maps, interfaces, and so on) works just as well without the added complexity, so be wary of premature use. See the discussion on least mechanism.</paragraph><paragraph>When introducing an exported API that uses generics, make sure it is suitably documented. It's highly encouraged to include motivating runnable examples.</paragraph><paragraph>Do not use generics just because you are implementing an algorithm or data structure that does not care about the type of its member elements. If there is only one type being instantiated in practice, start by making your code work on that type without using generics at all. Adding polymorphism later will be straightforward compared to removing abstraction that is found to be unnecessary.</paragraph><paragraph>Do not use generics to invent domain-specific languages (DSLs). In particular, refrain from introducing error-handling frameworks that might put a significant burden on readers. Instead prefer established error handling practices. For testing, be especially wary of introducing assertion libraries or frameworks that result in less useful test failures.</paragraph><paragraph>In general:</paragraph><list type="ul"><item>Write code, don't design types. From a GopherCon talk by Robert Griesemer and Ian Lance Taylor.</item><item>If you have several types that share a useful unifying interface, consider modeling the solution using that interface. Generics may not be needed.</item><item>Otherwise, instead of relying on the any type and excessive type switching, consider generics.</item></list><paragraph>See also:</paragraph><heading level="3">Pass values</heading><paragraph>Do not pass pointers as function arguments just to save a few bytes. If a function reads its argument x only as *x throughout, then the argument shouldn't be a pointer. Common instances of this include passing a pointer to a string (*string) or a pointer to an interface value (*io.Reader). In both cases, the value itself is a fixed size and can be passed directly.</paragraph><paragraph>This advice does not apply to large structs, or even small structs that may increase in size. In particular, protocol buffer messages should generally be handled by pointer rather than by value. The pointer type satisfies the proto.Message interface (accepted by proto.Marshal, protocmp.Transform, etc.), and protocol buffer messages can be quite large and often grow larger over time.</paragraph><heading level="3">Receiver type</heading><paragraph>A method receiver can be passed either as a value or a pointer, just as if it were a regular function parameter. The choice between the two is based on which method set(s) the method should be a part of.</paragraph><paragraph>Correctness wins over speed or simplicity. There are cases where you must use a pointer value. In other cases, pick pointers for large types or as future-proofing if you don't have a good sense of how the code will grow, and use values for simple plain old data.</paragraph><paragraph>The list below spells out each case in further detail:</paragraph><list type="ul"><item>If the receiver is a slice and the method doesn't reslice or reallocate the slice, use a value rather than a pointer. // Good: type Buffer []byte func (b Buffer) Len() int { return len(b) }</item><item>If the method needs to mutate the receiver, the receiver must be a pointer. // Good: type Counter int func (c *Counter) Inc() { *c++ } // See https://pkg.go.dev/container/heap. type Queue []Item func (q *Queue) Push(x Item) { *q = append([]Item{x}, *q...) }</item><item>If the receiver is a struct containing fields that cannot safely be copied, use a pointer receiver. Common examples are sync.Mutex and other synchronization types. // Good: type Counter struct { mu sync.Mutex total int } func (c *Counter) Inc() { c.mu.Lock() defer c.mu.Unlock() c.total++ } Tip: Check the type's Godoc for information about whether it is safe or unsafe to copy.</item><item>If the receiver is a "large" struct or array, a pointer receiver may be more efficient. Passing a struct is equivalent to passing all of its fields or elements as arguments to the method. If that seems too large to pass by value, a pointer is a good choice.</item><item>For methods that will call or run concurrently with other functions that modify the receiver, use a value if those modifications should not be visible to your method; otherwise use a pointer.</item><item>If the receiver is a struct or array, any of whose elements is a pointer to something that may be mutated, prefer a pointer receiver to make the intention of mutability clear to the reader. // Good: type Counter struct { m *Metric } func (c *Counter) Inc() { c.m.Add(1) }</item><item>If the receiver is a built-in type, such as an integer or a string, that does not need to be modified, use a value. // Good: type User string func (u User) String() { return string(u) }</item><item>If the receiver is a map, function, or channel, use a value rather than a pointer. // Good: // See https://pkg.go.dev/net/http#Header. type Header map[string][]string func (h Header) Add(key, value string) { /* omitted */ }</item><item>If the receiver is a "small" array or struct that is naturally a value type with no mutable fields and no pointers, a value receiver is usually the right choice. // Good: // See https://pkg.go.dev/time#Time. type Time struct { /* omitted */ } func (t Time) Add(d Duration) Time { /* omitted */ }</item><item>When in doubt, use a pointer receiver.</item></list><paragraph>If the receiver is a slice and the method doesn't reslice or reallocate the slice, use a value rather than a pointer.</paragraph><code language="code">// Good:
type Buffer []byte

func (b Buffer) Len() int { return len(b) }
</code><paragraph>If the method needs to mutate the receiver, the receiver must be a pointer.</paragraph><code language="code">// Good:
type Counter int

func (c *Counter) Inc() { *c++ }

// See https://pkg.go.dev/container/heap.
type Queue []Item

func (q *Queue) Push(x Item) { *q = append([]Item{x}, *q...) }
</code><paragraph>If the receiver is a struct containing fields that cannot safely be copied, use a pointer receiver. Common examples are sync.Mutex and other synchronization types.</paragraph><code language="javascript">// Good:
type Counter struct {
    mu    sync.Mutex
    total int
}

func (c *Counter) Inc() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.total++
}
</code><paragraph>Tip: Check the type's Godoc for information about whether it is safe or unsafe to copy.</paragraph><paragraph>If the receiver is a "large" struct or array, a pointer receiver may be more efficient. Passing a struct is equivalent to passing all of its fields or elements as arguments to the method. If that seems too large to pass by value, a pointer is a good choice.</paragraph><paragraph>For methods that will call or run concurrently with other functions that modify the receiver, use a value if those modifications should not be visible to your method; otherwise use a pointer.</paragraph><paragraph>If the receiver is a struct or array, any of whose elements is a pointer to something that may be mutated, prefer a pointer receiver to make the intention of mutability clear to the reader.</paragraph><code language="javascript">// Good:
type Counter struct {
    m *Metric
}

func (c *Counter) Inc() {
    c.m.Add(1)
}
</code><paragraph>If the receiver is a built-in type, such as an integer or a string, that does not need to be modified, use a value.</paragraph><code language="code">// Good:
type User string

func (u User) String() { return string(u) }
</code><paragraph>If the receiver is a map, function, or channel, use a value rather than a pointer.</paragraph><code language="code">// Good:
// See https://pkg.go.dev/net/http#Header.
type Header map[string][]string

func (h Header) Add(key, value string) { /* omitted */ }
</code><paragraph>If the receiver is a "small" array or struct that is naturally a value type with no mutable fields and no pointers, a value receiver is usually the right choice.</paragraph><code language="code">// Good:
// See https://pkg.go.dev/time#Time.
type Time struct { /* omitted */ }

func (t Time) Add(d Duration) Time { /* omitted */ }
</code><paragraph>When in doubt, use a pointer receiver.</paragraph><paragraph>As a general guideline, prefer to make the methods for a type either all pointer methods or all value methods.</paragraph><paragraph>Note: There is a lot of misinformation about whether passing a value or a pointer to a function can affect performance. The compiler can choose to pass pointers to values on the stack as well as copying values on the stack, but these considerations should not outweigh the readability and correctness of the code in most circumstances. When the performance does matter, it is important to profile both approaches with a realistic benchmark before deciding that one approach outperforms the other.</paragraph><heading level="3">switch and break</heading><paragraph>Do not use break statements without target labels at the ends of switch clauses; they are redundant. Unlike in C and Java, switch clauses in Go automatically break, and a fallthrough statement is needed to achieve the C-style behavior. Use a comment rather than break if you want to clarify the purpose of an empty clause.</paragraph><code language="javascript">// Good:
switch x {
case "A", "B":
    buf.WriteString(x)
case "C":
    // handled outside of the switch statement
default:
    return fmt.Errorf("unknown value: %q", x)
}
</code><code language="javascript">// Bad:
switch x {
case "A", "B":
    buf.WriteString(x)
    break // this break is redundant
case "C":
    break // this break is redundant
default:
    return fmt.Errorf("unknown value: %q", x)
}
</code><paragraph>Note: If a switch clause is within a for loop, using break within switch does not exit the enclosing for loop.</paragraph><code language="javascript">for {
  switch x {
  case "A":
     break // exits the switch, not the loop
  }
}
</code><paragraph>To escape the enclosing loop, use a label on the for statement:</paragraph><code language="javascript">loop:
  for {
    switch x {
    case "A":
       break loop // exits the loop
    }
  }
</code><heading level="3">Synchronous functions</heading><paragraph>Synchronous functions return their results directly and finish any callbacks or channel operations before returning. Prefer synchronous functions over asynchronous functions.</paragraph><paragraph>Synchronous functions keep goroutines localized within a call. This helps to reason about their lifetimes, and avoid leaks and data races. Synchronous functions are also easier to test, since the caller can pass an input and check the output without the need for polling or synchronization.</paragraph><paragraph>If necessary, the caller can add concurrency by calling the function in a separate goroutine. However, it is quite difficult (sometimes impossible) to remove unnecessary concurrency at the caller side.</paragraph><paragraph>See also:</paragraph><list type="ul"><item>"Rethinking Classical Concurrency Patterns", talk by Bryan Mills: slides, video</item></list><heading level="3">Type aliases</heading><paragraph>Use a type definition, type T1 T2, to define a new type. Use a type alias, type T1 = T2, to refer to an existing type without defining a new type. Type aliases are rare; their primary use is to aid migrating packages to new source code locations. Don't use type aliasing when it is not needed.</paragraph><heading level="3">Use %q</heading><paragraph>Go's format functions (fmt.Printf etc.) have a %q verb which prints strings inside double-quotation marks.</paragraph><code language="code">// Good:
fmt.Printf("value %q looks like English text", someText)
</code><paragraph>Prefer using %q over doing the equivalent manually, using %s:</paragraph><code language="code">// Bad:
fmt.Printf("value \"%s\" looks like English text", someText)
// Avoid manually wrapping strings with single-quotes too:
fmt.Printf("value '%s' looks like English text", someText)
</code><paragraph>Using %q is recommended in output intended for humans where the input value could possibly be empty or contain control characters. It can be very hard to notice a silent empty string, but "" stands out clearly as such.</paragraph><heading level="3">Use any</heading><paragraph>Go 1.18 introduces an any type as an alias to interface{}. Because it is an alias, any is equivalent to interface{} in many situations and in others it is easily interchangeable via an explicit conversion. Prefer to use any in new code.</paragraph><heading level="2">Common libraries</heading><heading level="3">Flags</heading><paragraph>Go programs in the Google codebase use an internal variant of the standard flag package. It has a similar interface but interoperates well with internal Google systems. Flag names in Go binaries should prefer to use underscores to separate words, though the variables that hold a flag's value should follow the standard Go name style (mixed caps). Specifically, the flag name should be in snake case, and the variable name should be the equivalent name in camel case.</paragraph><code language="javascript">// Good:
var (
    pollInterval = flag.Duration("poll_interval", time.Minute, "Interval to use for polling.")
)
</code><code language="javascript">// Bad:
var (
    poll_interval = flag.Int("pollIntervalSeconds", 60, "Interval to use for polling in seconds.")
)
</code><paragraph>Flags must only be defined in package main or equivalent.</paragraph><paragraph>General-purpose packages should be configured using Go APIs, not by punching through to the command-line interface; don't let importing a library export new flags as a side effect. That is, prefer explicit function arguments or struct field assignment or much less frequently and under the strictest of scrutiny exported global variables. In the extremely rare case that it is necessary to break this rule, the flag name must clearly indicate the package that it configures.</paragraph><paragraph>If your flags are global variables, place them in their own var group, following the imports section.</paragraph><paragraph>There is additional discussion around best practices for creating complex CLIs with subcommands.</paragraph><paragraph>See also:</paragraph><heading level="3">Logging</heading><paragraph>Go programs in the Google codebase use a variant of the standard log package. It has a similar but more powerful interface and interoperates well with internal Google systems. An open source version of this library is available as package glog, and open source Google projects may use that, but this guide refers to it as log throughout.</paragraph><paragraph>Note: For abnormal program exits, this library uses log.Fatal to abort with a stacktrace, and log.Exit to stop without one. There is no log.Panic function as in the standard library.</paragraph><paragraph>Tip: log.Info(v) is equivalent log.Infof("%v", v), and the same goes for other logging levels. Prefer the non-formatting version when you have no formatting to do.</paragraph><paragraph>See also:</paragraph><heading level="3">Contexts</heading><paragraph>Values of the context.Context type carry security credentials, tracing information, deadlines, and cancellation signals across API and process boundaries. Unlike C++ and Java, which in the Google codebase use thread-local storage, Go programs pass contexts explicitly along the entire function call chain from incoming RPCs and HTTP requests to outgoing requests.</paragraph><paragraph>When passed to a function or method, context.Context is always the first parameter.</paragraph><code language="go">func F(ctx context.Context /* other arguments */) {}
</code><paragraph>Exceptions are:</paragraph><list type="ul"><item>In an HTTP handler, where the context comes from req.Context().</item><item>In streaming RPC methods, where the context comes from the stream. Code using gRPC streaming accesses a context from a Context() method in the generated server type, which implements grpc.ServerStream. See gRPC Generated Code documentation.</item><item>In entrypoint functions (see below for examples of such functions), use context.Background() or, for tests, tb.Context(). In binary targets: main In general purpose code and libraries: init In tests: TestXXX, BenchmarkXXX, FuzzXXX</item></list><paragraph>In streaming RPC methods, where the context comes from the stream.</paragraph><paragraph>Code using gRPC streaming accesses a context from a Context() method in the generated server type, which implements grpc.ServerStream. See gRPC Generated Code documentation.</paragraph><paragraph>In entrypoint functions (see below for examples of such functions), use context.Background() or, for tests, tb.Context().</paragraph><list type="ul"><item>In binary targets: main</item><item>In general purpose code and libraries: init</item><item>In tests: TestXXX, BenchmarkXXX, FuzzXXX</item></list><paragraph>Note: It is very rare for code in the middle of a callchain to require creating a base context of its own using context.Background(). Always prefer taking a context from your caller, unless it's the wrong context.</paragraph><paragraph>You may come across server libraries (the implementation of Stubby, gRPC, or HTTP in Google's server framework for Go) that construct a fresh context object per request. These contexts are immediately filled with information from the incoming request, so that when passed to the request handler, the context's attached values have been propagated to it across the network boundary from the client caller. Moreover, these contexts' lifetimes are scoped to that of the request: when the request is finished, the context is cancelled.</paragraph><paragraph>Unless you are implementing a server framework, you shouldn't create contexts with context.Background() in library code. Instead, prefer using context detachment, which is mentioned below, if there is an existing context available. If you think you do need context.Background() outside of entrypoint functions, discuss it with the Google Go style mailing list before committing to an implementation.</paragraph><paragraph>The convention that context.Context comes first in functions also applies to test helpers.</paragraph><code language="go">// Good:
func readTestFile(ctx context.Context, t *testing.T, path string) string {}
</code><paragraph>Do not add a context member to a struct type. Instead, add a context parameter to each method on the type that needs to pass it along. The one exception is for methods whose signature must match an interface in the standard library or in a third party library outside Google's control. Such cases are very rare, and should be discussed with the Google Go style mailing list before implementation and readability review.</paragraph><paragraph>Note: Go 1.24 added a (testing.TB).Context() method. In tests, prefer using (testing.TB).Context() over context.Background() to provide the initial context.Context used by the test. Helper functions, environment or test double setup, and other functions called from the test function body that require a context should have one explicitly passed.</paragraph><paragraph>Code in the Google codebase that must spawn background operations which can run after the parent context has been cancelled can use an internal package for detachment. Follow issue #40221 for discussions on an open source alternative.</paragraph><paragraph>Since contexts are immutable, it is fine to pass the same context to multiple calls that share the same deadline, cancellation signal, credentials, parent trace, and so on.</paragraph><paragraph>See also:</paragraph><heading level="4">Custom contexts</heading><paragraph>Do not create custom context types or use interfaces other than context.Context in function signatures. There are no exceptions to this rule.</paragraph><paragraph>Imagine if every team had a custom context. Every function call from package p to package q would have to determine how to convert a p.Context to a q.Context, for all pairs of packages p and q. This is impractical and error-prone for humans, and it makes automated refactorings that add context parameters nearly impossible.</paragraph><paragraph>If you have application data to pass around, put it in a parameter, in the receiver, in globals, or in a Context value if it truly belongs there. Creating your own context type is not acceptable since it undermines the ability of the Go team to make Go programs work properly in production.</paragraph><heading level="3">crypto/rand</heading><paragraph>Do not use package math/rand to generate keys, even throwaway ones. If unseeded, the generator is completely predictable. Seeded with time.Nanoseconds(), there are just a few bits of entropy. Instead, use crypto/rand's Reader, and if you need text, print to hexadecimal or base64.</paragraph><code language="javascript">// Good:
import (
    "crypto/rand"
    // "encoding/base64"
    // "encoding/hex"
    "fmt"

    // ...
)

func Key() string {
    buf := make([]byte, 16)
    if _, err := rand.Read(buf); err != nil {
        log.Fatalf("Out of randomness, should never happen: %v", err)
    }
    return fmt.Sprintf("%x", buf)
    // or hex.EncodeToString(buf)
    // or base64.StdEncoding.EncodeToString(buf)
}
</code><paragraph>Note: log.Fatalf is not the standard library log. See [#logging].</paragraph><heading level="2">Useful test failures</heading><paragraph>It should be possible to diagnose a test's failure without reading the test's source. Tests should fail with helpful messages detailing:</paragraph><list type="ul"><item>What caused the failure</item><item>What inputs resulted in an error</item><item>The actual result</item><item>What was expected</item></list><paragraph>Specific conventions for achieving this goal are outlined below.</paragraph><heading level="3">Assertion libraries</heading><paragraph>Do not create "assertion libraries" as helpers for testing.</paragraph><paragraph>Assertion libraries are libraries that attempt to combine the validation and production of failure messages within a test (though the same pitfalls can apply to other test helpers as well). For more on the distinction between test helpers and assertion libraries, see best practices.</paragraph><code language="javascript">// Bad:
var obj BlogPost

assert.IsNotNil(t, "obj", obj)
assert.StringEq(t, "obj.Type", obj.Type, "blogPost")
assert.IntEq(t, "obj.Comments", obj.Comments, 2)
assert.StringNotEq(t, "obj.Body", obj.Body, "")
</code><paragraph>Assertion libraries tend to either stop the test early (if assert calls t.Fatalf or panic) or omit relevant information about what the test got right:</paragraph><code language="javascript">// Bad:
package assert

func IsNotNil(t *testing.T, name string, val any) {
    if val == nil {
        t.Fatalf("Data %s = nil, want not nil", name)
    }
}

func StringEq(t *testing.T, name, got, want string) {
    if got != want {
        t.Fatalf("Data %s = %q, want %q", name, got, want)
    }
}
</code><paragraph>Complex assertion functions often do not provide useful failure messages and context that exists within the test function. Too many assertion functions and libraries lead to a fragmented developer experience: which assertion library should I use, what style of output format should it emit, etc.? Fragmentation produces unnecessary confusion, especially for library maintainers and authors of large-scale changes, who are responsible for fixing potential downstream breakages. Instead of creating a domain-specific language for testing, use Go itself.</paragraph><paragraph>Assertion libraries often factor out comparisons and equality checks. Prefer using standard libraries such as cmp and fmt instead:</paragraph><code language="javascript">// Good:
var got BlogPost

want := BlogPost{
    Comments: 2,
    Body:     "Hello, world!",
}

if !cmp.Equal(got, want) {
    t.Errorf("Blog post = %v, want = %v", got, want)
}
</code><paragraph>For more domain-specific comparison helpers, prefer returning a value or an error that can be used in the test's failure message instead of passing *testing.T and calling its error reporting methods:</paragraph><code language="javascript">// Good:
func postLength(p BlogPost) int { return len(p.Body) }

func TestBlogPost_VeritableRant(t *testing.T) {
    post := BlogPost{Body: "I am Gunnery Sergeant Hartman, your senior drill instructor."}

    if got, want := postLength(post), 60; got != want {
        t.Errorf("Length of post = %v, want %v", got, want)
    }
}
</code><paragraph>Best Practice: Were postLength non-trivial, it would make sense to test it directly, independently of any tests that use it.</paragraph><paragraph>See also:</paragraph><heading level="3">Identify the function</heading><paragraph>In most tests, failure messages should include the name of the function that failed, even though it seems obvious from the name of the test function. Specifically, your failure message should be YourFunc(%v) = %v, want %v instead of just got %v, want %v.</paragraph><heading level="3">Identify the input</heading><paragraph>In most tests, failure messages should include the function inputs if they are short. If the relevant properties of the inputs are not obvious (for example, because the inputs are large or opaque), you should name your test cases with a description of what's being tested and print the description as part of your error message.</paragraph><heading level="3">Got before want</heading><paragraph>Test outputs should include the actual value that the function returned before printing the value that was expected. A standard format for printing test outputs is YourFunc(%v) = %v, want %v. Where you would write "actual" and "expected", prefer using the words "got" and "want", respectively.</paragraph><paragraph>For diffs, directionality is less apparent, and as such it is important to include a key to aid in interpreting the failure. See the section on printing diffs. Whichever diff order you use in your failure messages, you should explicitly indicate it as a part of the failure message, because existing code is inconsistent about the ordering.</paragraph><heading level="3">Full structure comparisons</heading><paragraph>If your function returns a struct (or any data type with multiple fields such as slices, arrays, and maps), avoid writing test code that performs a hand-coded field-by-field comparison of the struct. Instead, construct the data that you're expecting your function to return, and compare directly using a deep comparison.</paragraph><paragraph>Note: This does not apply if your data contains irrelevant fields that obscure the intention of the test.</paragraph><paragraph>If your struct needs to be compared for approximate (or equivalent kind of semantic) equality or it contains fields that cannot be compared for equality (e.g., if one of the fields is an io.Reader), tweaking a cmp.Diff or cmp.Equal comparison with cmpopts options such as cmpopts.IgnoreInterfaces may meet your needs (example).</paragraph><paragraph>If your function returns multiple return values, you don't need to wrap those in a struct before comparing them. Just compare the return values individually and print them.</paragraph><code language="javascript">// Good:
val, multi, tail, err := strconv.UnquoteChar(`\"Fran & Freddie's Diner\"`, '"')
if err != nil {
  t.Fatalf(...)
}
if val != `"` {
  t.Errorf(...)
}
if multi {
  t.Errorf(...)
}
if tail != `Fran & Freddie's Diner"` {
  t.Errorf(...)
}
</code><heading level="3">Compare stable results</heading><paragraph>Avoid comparing results that may depend on output stability of a package that you do not own. Instead, the test should compare on semantically relevant information that is stable and resistant to changes in dependencies. For functionality that returns a formatted string or serialized bytes, it is generally not safe to assume that the output is stable.</paragraph><paragraph>For example, json.Marshal can change (and has changed in the past) the specific bytes that it emits. Tests that perform string equality on the JSON string may break if the json package changes how it serializes the bytes. Instead, a more robust test would parse the contents of the JSON string and ensure that it is semantically equivalent to some expected data structure.</paragraph><heading level="3">Keep going</heading><paragraph>Tests should keep going for as long as possible, even after a failure, in order to print out all of the failed checks in a single run. This way, a developer who is fixing the failing test doesn't have to re-run the test after fixing each bug to find the next bug.</paragraph><paragraph>Prefer calling t.Error over t.Fatal for reporting a mismatch. When comparing several different properties of a function's output, use t.Error for each of those comparisons.</paragraph><paragraph>Calling t.Fatal is primarily useful for reporting an unexpected error condition, when subsequent comparison failures are not going to be meaningful.</paragraph><paragraph>For table-driven test, consider using subtests and use t.Fatal rather than t.Error and continue. See also GoTip #25: Subtests: Making Your Tests Lean.</paragraph><paragraph>Best practice: For more discussion about when t.Fatal should be used, see best practices.</paragraph><heading level="3">Equality comparison and diffs</heading><paragraph>The == operator evaluates equality using language-defined comparisons. Scalar values (numbers, booleans, etc) are compared based on their values, but only some structs and interfaces can be compared in this way. Pointers are compared based on whether they point to the same variable, rather than based on the equality of the values to which they point.</paragraph><paragraph>The cmp package can compare more complex data structures not appropriately handled by ==, such as slices. Use cmp.Equal for equality comparison and cmp.Diff to obtain a human-readable diff between objects.</paragraph><code language="javascript">// Good:
want := &Doc{
    Type:     "blogPost",
    Comments: 2,
    Body:     "This is the post body.",
    Authors:  []string{"isaac", "albert", "emmy"},
}
if !cmp.Equal(got, want) {
    t.Errorf("AddPost() = %+v, want %+v", got, want)
}
</code><paragraph>As a general-purpose comparison library, cmp may not know how to compare certain types. For example, it can only compare protocol buffer messages if passed the protocmp.Transform option.</paragraph><code language="javascript">// Good:
if diff := cmp.Diff(want, got, protocmp.Transform()); diff != "" {
    t.Errorf("Foo() returned unexpected difference in protobuf messages (-want +got):\n%s", diff)
}
</code><paragraph>Although the cmp package is not part of the Go standard library, it is maintained by the Go team and should produce stable equality results over time. It is user-configurable and should serve most comparison needs.</paragraph><paragraph>Existing code may make use of the following older libraries, and may continue using them for consistency:</paragraph><list type="ul"><item>pretty produces aesthetically pleasing difference reports. However, it quite deliberately considers values that have the same visual representation as equal. In particular, pretty does not catch differences between nil slices and empty ones, is not sensitive to different interface implementations with identical fields, and it is possible to use a nested map as the basis for comparison with a struct value. It also serializes the entire value into a string before producing a diff, and as such is not a good choice for comparing large values. By default, it compares unexported fields, which makes it sensitive to changes in implementation details in your dependencies. For this reason, it is not appropriate to use pretty on protobuf messages.</item></list><paragraph>Prefer using cmp for new code, and it is worth considering updating older code to use cmp where and when it is practical to do so.</paragraph><paragraph>Older code may use the standard library reflect.DeepEqual function to compare complex structures. reflect.DeepEqual should not be used for checking equality, as it is sensitive to changes in unexported fields and other implementation details. Code that is using reflect.DeepEqual should be updated to one of the above libraries.</paragraph><paragraph>Note: The cmp package is designed for testing, rather than production use. As such, it may panic when it suspects that a comparison is performed incorrectly to provide instruction to users on how to improve the test to be less brittle. Given cmp's propensity towards panicking, it makes it unsuitable for code that is used in production as a spurious panic may be fatal.</paragraph><heading level="3">Level of detail</heading><paragraph>The conventional failure message, which is suitable for most Go tests, is YourFunc(%v) = %v, want %v. However, there are cases that may call for more or less detail:</paragraph><list type="ul"><item>Tests performing complex interactions should describe the interactions too. For example, if the same YourFunc is called several times, identify which call failed the test. If it's important to know any extra state of the system, include that in the failure output (or at least in the logs).</item><item>If the data is a complex struct with significant boilerplate, it is acceptable to describe only the important parts in the message, but do not overly obscure the data.</item><item>Setup failures do not require the same level of detail. If a test helper populates a Spanner table but Spanner was down, you probably don't need to include which test input you were going to store in the database. t.Fatalf("Setup: Failed to set up test database: %s", err) is usually helpful enough to resolve the issue.</item></list><paragraph>Tip: Make your failure mode trigger during development. Review what the failure message looks like and whether a maintainer can effectively deal with the failure.</paragraph><paragraph>There are some techniques for reproducing test inputs and outputs clearly:</paragraph><list type="ul"><item>When printing string data, %q is often useful to emphasize that the value is important and to more easily spot bad values.</item><item>When printing (small) structs, %+v can be more useful than %v.</item><item>When validation of larger values fails, printing a diff can make it easier to understand the failure.</item></list><heading level="3">Print diffs</heading><paragraph>If your function returns large output then it can be hard for someone reading the failure message to find the differences when your test fails. Instead of printing both the returned value and the wanted value, make a diff.</paragraph><paragraph>To compute diffs for such values, cmp.Diff is preferred, particularly for new tests and new code, but other tools may be used. See types of equality for guidance regarding the strengths and weaknesses of each function.</paragraph><paragraph>You can use the diff package to compare multi-line strings or lists of strings. You can use this as a building block for other kinds of diffs.</paragraph><paragraph>Add some text to your failure message explaining the direction of the diff.</paragraph><list type="ul"><item>Something like diff (-want +got) is good when you're using the cmp, pretty, and diff packages (if you pass (want, got) to the function), because the - and + that you add to your format string will match the - and + that actually appear at the beginning of the diff lines. If you pass (got, want) to your function, the correct key would be (-got +want) instead.</item><item>The messagediff package uses a different output format, so the message diff (want -> got) is appropriate when you're using it (if you pass (want, got) to the function), because the direction of the arrow will match the direction of the arrow in the "modified" lines.</item></list><paragraph>Something like diff (-want +got) is good when you're using the cmp, pretty, and diff packages (if you pass (want, got) to the function), because the - and + that you add to your format string will match the - and + that actually appear at the beginning of the diff lines. If you pass (got, want) to your function, the correct key would be (-got +want) instead.</paragraph><paragraph>The messagediff package uses a different output format, so the message diff (want -> got) is appropriate when you're using it (if you pass (want, got) to the function), because the direction of the arrow will match the direction of the arrow in the "modified" lines.</paragraph><paragraph>The diff will span multiple lines, so you should print a newline before you print the diff.</paragraph><heading level="3">Test error semantics</heading><paragraph>When a unit test performs string comparisons or uses a vanilla cmp to check that particular kinds of errors are returned for particular inputs, you may find that your tests are brittle if any of those error messages are reworded in the future. Since this has the potential to turn your unit test into a change detector (see TotT: Change-Detector Tests Considered Harmful ), don't use string comparison to check what type of error your function returns. However, it is permissible to use string comparisons to check that error messages coming from the package under test satisfy certain properties, for example, that it includes the parameter name.</paragraph><paragraph>Error values in Go typically have a component intended for human eyes and a component intended for semantic control flow. Tests should seek to only test semantic information that can be reliably observed, rather than display information that is intended for human debugging, as this is often subject to future changes. For guidance on constructing errors with semantic meaning see best-practices regarding errors. If an error with insufficient semantic information is coming from a dependency outside your control, consider filing a bug against the owner to help improve the API, rather than relying on parsing the error message.</paragraph><paragraph>Within unit tests, it is common to only care whether an error occurred or not. If so, then it is sufficient to only test whether the error was non-nil when you expected an error. If you would like to test that the error semantically matches some other error, then consider using errors.Is or cmp with cmpopts.EquateErrors.</paragraph><paragraph>Note: If a test uses cmpopts.EquateErrors but all of its wantErr values are either nil or cmpopts.AnyError, then using cmp is unnecessary mechanism. Simplify the code by making the want field a bool. You can then use a simple comparison with !=.</paragraph><code language="javascript">// Good:
err := f(test.input)
gotErr := err != nil
if gotErr != test.wantErr {
    t.Errorf("f(%q) = %v, want error presence = %v", test.input, err, test.wantErr)
}
</code><paragraph>See also GoTip #13: Designing Errors for Checking.</paragraph><heading level="2">Test structure</heading><heading level="3">Subtests</heading><paragraph>The standard Go testing library offers a facility to define subtests. This allows flexibility in setup and cleanup, controlling parallelism, and test filtering. Subtests can be useful (particularly for table-driven tests), but using them is not mandatory. See also the Go blog post about subtests.</paragraph><paragraph>Subtests should not depend on the execution of other cases for success or initial state, because subtests are expected to be able to be run individually with using go test -run flags or with Bazel test filter expressions.</paragraph><heading level="4">Subtest names</heading><paragraph>Name your subtest such that it is readable in test output and useful on the command line for users of test filtering. When you use t.Run to create a subtest, the first argument is used as a descriptive name for the test. To ensure that test results are legible to humans reading the logs, choose subtest names that will remain useful and readable after escaping. Think of subtest names more like a function identifier than a prose description.</paragraph><paragraph>The test runner replaces spaces with underscores, and escapes non-printing characters. To ensure accurate correlation between test logs and source code, it is recommended to avoid using these characters in subtest names.</paragraph><paragraph>If your test data benefits from a longer description, consider putting the description in a separate field (perhaps to be printed using t.Log or alongside failure messages).</paragraph><paragraph>Subtests may be run individually using flags to the Go test runner or Bazel test filter, so choose descriptive names that are also easy to type.</paragraph><paragraph>Warning: Slash characters are particularly unfriendly in subtest names, since they have special meaning for test filters.</paragraph><code language="code"># Bad:
# Assuming TestTime and t.Run("America/New_York", ...)
bazel test :mytest --test_filter="Time/New_York"    # Runs nothing!
bazel test :mytest --test_filter="Time//New_York"   # Correct, but awkward.
</code><paragraph>To identify the inputs of the function, include them in the test's failure messages, where they won't be escaped by the test runner.</paragraph><code language="javascript">// Good:
func TestTranslate(t *testing.T) {
    data := []struct {
        name, desc, srcLang, dstLang, srcText, wantDstText string
    }{
        {
            name:        "hu=en_bug-1234",
            desc:        "regression test following bug 1234. contact: cleese",
            srcLang:     "hu",
            srcText:     "cigarettát és egy öngyújtót kérek",
            dstLang:     "en",
            wantDstText: "cigarettes and a lighter please",
        }, // ...
    }
    for _, d := range data {
        t.Run(d.name, func(t *testing.T) {
            got := Translate(d.srcLang, d.dstLang, d.srcText)
            if got != d.wantDstText {
                t.Errorf("%s\nTranslate(%q, %q, %q) = %q, want %q",
                    d.desc, d.srcLang, d.dstLang, d.srcText, got, d.wantDstText)
            }
        })
    }
}
</code><paragraph>Here are a few examples of things to avoid:</paragraph><code language="code">// Bad:
// Too wordy.
t.Run("check that there is no mention of scratched records or hovercrafts", ...)
// Slashes cause problems on the command line.
t.Run("AM/PM confusion", ...)
</code><paragraph>See also Go Tip #117: Subtest Names.</paragraph><heading level="3">Table-driven tests</heading><paragraph>Use table-driven tests when many different test cases can be tested using similar testing logic.</paragraph><list type="ul"><item>When testing whether the actual output of a function is equal to the expected output. For example, the many tests of fmt.Sprintf or the minimal snippet below.</item><item>When testing whether the outputs of a function always conform to the same set of invariants. For example, tests for net.Dial.</item></list><paragraph>Here is the minimal structure of a table-driven test. If needed, you may use different names or add extra facilities such as subtests or setup and cleanup functions. Always keep useful test failures in mind.</paragraph><code language="javascript">// Good:
func TestCompare(t *testing.T) {
    compareTests := []struct {
        a, b string
        want int
    }{
        {"", "", 0},
        {"a", "", 1},
        {"", "a", -1},
        {"abc", "abc", 0},
        {"ab", "abc", -1},
        {"abc", "ab", 1},
        {"x", "ab", 1},
        {"ab", "x", -1},
        {"x", "a", 1},
        {"b", "x", -1},
        // test runtime·memeq's chunked implementation
        {"abcdefgh", "abcdefgh", 0},
        {"abcdefghi", "abcdefghi", 0},
        {"abcdefghi", "abcdefghj", -1},
    }

    for _, test := range compareTests {
        got := Compare(test.a, test.b)
        if got != test.want {
            t.Errorf("Compare(%q, %q) = %v, want %v", test.a, test.b, got, test.want)
        }
    }
}
</code><paragraph>Note: The failure messages in this example above fulfill the guidance to identify the function and identify the input. There's no need to identify the row numerically.</paragraph><paragraph>When some test cases need to be checked using different logic from other test cases, it is appropriate to write multiple test functions, as explained in GoTip #50: Disjoint Table Tests.</paragraph><paragraph>When the additional test cases are simple (e.g., basic error checking) and don't introduce conditionalized code flow in the table test's loop body, it's permissible to include that case in the existing test, though be careful using logic like this. What starts simple today can organically grow into something unmaintainable.</paragraph><paragraph>For example:</paragraph><code language="javascript">func TestDivide(t *testing.T) {
    tests := []struct {
        dividend, divisor int
        want              int
        wantErr           bool
    }{
        {
            dividend: 4,
            divisor:  2,
            want:     2,
        },
        {
            dividend: 10,
            divisor:  2,
            want:     5,
        },
        {
            dividend: 1,
            divisor:  0,
            wantErr:  true,
        },
    }

    for _, test := range tests {
        got, err := Divide(test.dividend, test.divisor)
        if (err != nil) != test.wantErr {
            t.Errorf("Divide(%d, %d) error = %v, want error presence = %t", test.dividend, test.divisor, err, test.wantErr)
        }

        // In this example, we're only testing the value result when the tested function didn't fail.
        if err != nil {
            continue
        }

        if got != test.want {
            t.Errorf("Divide(%d, %d) = %d, want %d", test.dividend, test.divisor, got, test.want)
        }
    }
}
</code><paragraph>More complicated logic in your test code, like complex error checking based on conditional differences in test setup (often based on table test input parameters), can be difficult to understand when each entry in a table has specialized logic based on the inputs. If test cases have different logic but identical setup, a sequence of subtests within a single test function might be more readable. A test helper may also be useful for simplifying test setup in order to maintain the readability of a test body.</paragraph><paragraph>You can combine table-driven tests with multiple test functions. For example, when testing that a function's output exactly matches the expected output and that the function returns a non-nil error for an invalid input, then writing two separate table-driven test functions is the best approach: one for normal non-error outputs, and one for error outputs.</paragraph><heading level="4">Data-driven test cases</heading><paragraph>Table test rows can sometimes become complicated, with the row values dictating conditional behavior inside the test case. The extra clarity from the duplication between the test cases is necessary for readability.</paragraph><code language="javascript">// Good:
type decodeCase struct {
    name   string
    input  string
    output string
    err    error
}

func TestDecode(t *testing.T) {
    // setupCodex is slow as it creates a real Codex for the test.
    codex := setupCodex(t)

    var tests []decodeCase // rows omitted for brevity

    for _, test := range tests {
        t.Run(test.name, func(t *testing.T) {
            output, err := Decode(test.input, codex)
            if got, want := output, test.output; got != want {
                t.Errorf("Decode(%q) = %v, want %v", test.input, got, want)
            }
            if got, want := err, test.err; !cmp.Equal(got, want) {
                t.Errorf("Decode(%q) err %q, want %q", test.input, got, want)
            }
        })
    }
}

func TestDecodeWithFake(t *testing.T) {
    // A fakeCodex is a fast approximation of a real Codex.
    codex := newFakeCodex()

    var tests []decodeCase // rows omitted for brevity

    for _, test := range tests {
        t.Run(test.name, func(t *testing.T) {
            output, err := Decode(test.input, codex)
            if got, want := output, test.output; got != want {
                t.Errorf("Decode(%q) = %v, want %v", test.input, got, want)
            }
            if got, want := err, test.err; !cmp.Equal(got, want) {
                t.Errorf("Decode(%q) err %q, want %q", test.input, got, want)
            }
        })
    }
}
</code><paragraph>In the counterexample below, note how hard it is to distinguish between which type of Codex is used per test case in the case setup. (The highlighted parts run afoul of the advice from TotT: Data Driven Traps! .)</paragraph><code language="javascript">// Bad:
type decodeCase struct {
  name   string
  input  string
  codex  testCodex
  output string
  err    error
}

type testCodex int

const (
  fake testCodex = iota
  prod
)

func TestDecode(t *testing.T) {
  var tests []decodeCase // rows omitted for brevity

  for _, test := tests {
    t.Run(test.name, func(t *testing.T) {
      var codex Codex
      switch test.codex {
      case fake:
        codex = newFakeCodex()
      case prod:
        codex = setupCodex(t)
      default:
        t.Fatalf("Unknown codex type: %v", codex)
      }
      output, err := Decode(test.input, codex)
      if got, want := output, test.output; got != want {
        t.Errorf("Decode(%q) = %q, want %q", test.input, got, want)
      }
      if got, want := err, test.err; !cmp.Equal(got, want) {
        t.Errorf("Decode(%q) err %q, want %q", test.input, got, want)
      }
    })
  }
}
</code><heading level="4">Identifying the row</heading><paragraph>Do not use the index of the test in the test table as a substitute for naming your tests or printing the inputs. Nobody wants to go through your test table and count the entries in order to figure out which test case is failing.</paragraph><code language="javascript">// Bad:
tests := []struct {
    input, want string
}{
    {"hello", "HELLO"},
    {"wORld", "WORLD"},
}
for i, d := range tests {
    if strings.ToUpper(d.input) != d.want {
        t.Errorf("Failed on case #%d", i)
    }
}
</code><paragraph>Add a test description to your test struct and print it along failure messages. When using subtests, your subtest name should be effective in identifying the row.</paragraph><paragraph>Important: Even though t.Run scopes the output and execution, you must always identify the input. The table test row names must follow the subtest naming guidance.</paragraph><heading level="3">Test helpers</heading><paragraph>A test helper is a function that performs a setup or cleanup task. All failures that occur in test helpers are expected to be failures of the environment (not from the code under test) — for example when a test database cannot be started because there are no more free ports on this machine.</paragraph><paragraph>If you pass a *testing.T, call t.Helper to attribute failures in the test helper to the line where the helper is called. This parameter should come after a context parameter, if present, and before any remaining parameters.</paragraph><code language="javascript">// Good:
func TestSomeFunction(t *testing.T) {
    golden := readFile(t, "testdata/golden-result.txt")
    // ... tests against golden ...
}

// readFile returns the contents of a data file.
// It must only be called from the same goroutine as started the test.
func readFile(t *testing.T, filename string) string {
    t.Helper()
    contents, err := runfiles.ReadFile(filename)
    if err != nil {
        t.Fatal(err)
    }
    return string(contents)
}
</code><paragraph>Do not use this pattern when it obscures the connection between a test failure and the conditions that led to it. Specifically, the guidance about assert libraries still applies, and t.Helper should not be used to implement such libraries.</paragraph><paragraph>Tip: For more on the distinction between test helpers and assertion helpers, see best practices.</paragraph><paragraph>Although the above refers to *testing.T, much of the advice stays the same for benchmark and fuzz helpers.</paragraph><heading level="3">Test package</heading><heading level="4">Tests in the same package</heading><paragraph>Tests may be defined in the same package as the code being tested.</paragraph><paragraph>To write a test in the same package:</paragraph><list type="ul"><item>Place the tests in a foo_test.go file</item><item>Use package foo for the test file</item><item>Do not explicitly import the package to be tested</item></list><code language="code"># Good:
go_library(
    name = "foo",
    srcs = ["foo.go"],
    deps = [
        ...
    ],
)

go_test(
    name = "foo_test",
    size = "small",
    srcs = ["foo_test.go"],
    library = ":foo",
    deps = [
        ...
    ],
)
</code><paragraph>A test in the same package can access unexported identifiers in the package. This may enable better test coverage and more concise tests. Be aware that any examples declared in the test will not have the package names that a user will need in their code.</paragraph><heading level="4">Tests in a different package</heading><paragraph>It is not always appropriate or even possible to define a test in the same package as the code being tested. In these cases, use a package name with the _test suffix. This is an exception to the "no underscores" rule to package names. For example:</paragraph><heading level="3">Use package testing</heading><paragraph>The Go standard library provides the testing package. This is the only testing framework permitted for Go code in the Google codebase. In particular, assertion libraries and third-party testing frameworks are not allowed.</paragraph><paragraph>The testing package provides a minimal but complete set of functionality for writing good tests:</paragraph><list type="ul"><item>Top-level tests</item><item>Benchmarks</item><item>Runnable examples</item><item>Subtests</item><item>Logging</item><item>Failures and fatal failures</item></list><paragraph>These are designed to work cohesively with core language features like composite literal and if-with-initializer syntax to enable test authors to write [clear, readable, and maintainable tests].</paragraph><heading level="2">Non-decisions</heading><paragraph>A style guide cannot enumerate positive prescriptions for all matters, nor can it enumerate all matters about which it does not offer an opinion. That said, here are a few things where the readability community has previously debated and has not achieved consensus about.</paragraph><list type="ul"><item>Local variable initialization with zero value. var i int and i := 0 are equivalent. See also initialization best practices.</item><item>Empty composite literal vs. new or make. &File{} and new(File) are equivalent. So are map[string]bool{} and make(map[string]bool). See also composite declaration best practices.</item><item>got, want argument ordering in cmp.Diff calls. Be locally consistent, and include a legend in your failure message.</item><item>errors.New vs fmt.Errorf on non-formatted strings. errors.New("foo") and fmt.Errorf("foo") may be used interchangeably.</item></list><paragraph>If there are special circumstances where they come up again, the readability mentor might make an optional comment, but in general the author is free to pick the style they prefer in the given situation.</paragraph><paragraph>Naturally, if anything not covered by the style guide does need more discussion, authors are welcome to ask – either in the specific review, or on internal message boards.</paragraph></content>
</page>
<page url="https://google.github.io/styleguide/angularjs-google-style.html">
<title>Google's AngularJS Style Guide</title>
<content><heading level="1">An AngularJS Style Guide for Closure Users at Google</heading><heading level="2">Background</heading><paragraph>This is the external version of a document that was primarily written for Google engineers. It describes a recommended style for AngularJS apps that use Closure, as used internally at Google. Members of the broader AngularJS community should feel free to apply (or not apply) these recommendations, as relevant to their own use cases.</paragraph><paragraph>This document describes style for AngularJS apps in google3. This guide supplements and extends the Google JavaScript Style Guide.</paragraph><paragraph>Style Note: Examples on the AngularJS external webpage, and many external apps, are written in a style that freely uses closures, favors functional inheritance, and does not often use JavaScript types. Google follows a more rigorous Javascript style to support JSCompiler optimizations and large code bases - see the javascript-style mailing list. This is not an Angular-specific issue, and is not discussed further in this style guide. (But if you want further reading: Martin Fowler on closures, much longer description, appendix A of the closure book has a good description of inheritance patterns and why it prefers pseudoclassical, Javascript, the Good Parts as a counter.)</paragraph><heading level="2">1 Angular Language Rules</heading><heading level="3">Manage dependencies with Closure's goog.require and goog.provide</heading><paragraph>Choose a namespace for your project, and use goog.provide and goog.require.</paragraph><code language="code">
goog.provide('hello.about.AboutCtrl');
goog.provide('hello.versions.Versions');
</code><paragraph>Why? Google BUILD rules integrate nicely with closure provide/require.</paragraph><heading level="3">Modules</heading><paragraph>Your main application module should be in your root client directory. A module should never be altered other than the one where it is defined.</paragraph><paragraph>Modules may either be defined in the same file as their components (this works well for a module that contains exactly one service) or in a separate file for wiring pieces together.</paragraph><paragraph>Why? A module should be consistent for anyone that wants to include it as a reusable component. If a module can mean different things depending on which files are included, it is not consistent.</paragraph><heading level="3">Modules should reference other modules using the Angular Module's "name" property</heading><paragraph>For example:</paragraph><code language="code">
// file submodulea.js:
  goog.provide('my.submoduleA');

  my.submoduleA = angular.module('my.submoduleA', []);
  // ...

// file app.js
  goog.require('my.submoduleA');

  Yes: my.application.module = angular.module('hello', [my.submoduleA.name]);
  
      No: my.application.module = angular.module('hello', ['my.submoduleA']);
  </code><paragraph>Why? Using a property of my.submoduleA prevents Closure presubmit failures complaining that the file is required but never used. Using the .name property avoids duplicating strings.</paragraph><heading level="3">Use a common externs file</heading><paragraph>This maximally allows the JS compiler to enforce type safety in the presence of externally provided types from Angular, and means you don't have to worry about Angular vars being obfuscated in a confusing way.</paragraph><paragraph>Note to readers outside Google: the current externs file is located in an internal-to-Google directory, but an example can be found on github here.</paragraph><heading level="3">JSCompiler Flags</heading><paragraph>Reminder: According to the JS style guide, customer facing code must be compiled.</paragraph><paragraph>Recommended: Use the JSCompiler (the closure compiler that works with js_binary by default) and ANGULAR_COMPILER_FLAGS_FULL from //javascript/angular/build_defs/build_defs for your base flags.</paragraph><paragraph>Note - if you are using @export for methods, you will need to add the compiler flag</paragraph><code language="code">
"--generate_exports",
</code><paragraph>If you are using @export for properties, you will need to add the flags:</paragraph><code language="code">
"--generate_exports",
"--remove_unused_prototype_props_in_externs=false",
"--export_local_property_definitions",
</code><heading level="3">Controllers and Scopes</heading><paragraph>Controllers are classes. Methods should be defined on MyCtrl.prototype.</paragraph><paragraph>Google Angular applications should use the 'controller as' style to export the controller onto the scope. This is fully implemented in Angular 1.2 and can be mimicked in pre-Angular 1.2 builds.</paragraph><paragraph>Pre Angular 1.2, this looks like:</paragraph><code language="javascript">
/**
 * Home controller.
 *
 * @param {!angular.Scope} $scope
 * @constructor
 * @ngInject
 * @export
 */
hello.mainpage.HomeCtrl = function($scope) {
  /** @export */
  $scope.homeCtrl = this; // This is a bridge until Angular 1.2 controller-as

  /**
   * @type {string}
   * @export
   */
  this.myColor = 'blue';
};


/**
 * @param {number} a
 * @param {number} b
 * @export
 */
hello.mainpage.HomeCtrl.prototype.add = function(a, b) {
  return a + b;
};
</code><paragraph>And the template:</paragraph><code language="html">
<div ng-controller="hello.mainpage.HomeCtrl"/>
  <span ng-class="homeCtrl.myColor">I'm in a color!</span>
  <span>{{homeCtrl.add(5, 6)}}</span>
</div>
</code><paragraph>After Angular 1.2, this looks like:</paragraph><code language="javascript">
/**
 * Home controller.
 *
 * @constructor
 * @ngInject
 * @export
 */
hello.mainpage.HomeCtrl = function() {
  /**
   * @type {string}
   * @export
   */
  this.myColor = 'blue';
};


/**
 * @param {number} a
 * @param {number} b
 * @export
 */
hello.mainpage.HomeCtrl.prototype.add = function(a, b) {
  return a + b;
};
</code><paragraph>If you are compiling with property renaming, expose properties and methods using the @export annotation. Remember to @export the constructor as well.</paragraph><paragraph>And in the template:</paragraph><code language="html">
<div ng-controller="hello.mainpage.HomeCtrl as homeCtrl"/>
  <span ng-class="homeCtrl.myColor">I'm in a color!</span>
  <span>{{homeCtrl.add(5, 6)}}</span>
</div>
</code><paragraph>Why? Putting methods and properties directly onto the controller, instead of building up a scope object, fits better with the Google Closure class style. Additionally, using 'controller as' makes it obvious which controller you are accessing when multiple controllers apply to an element. Since there is always a '.' in the bindings, you don't have to worry about prototypal inheritance masking primitives.</paragraph><heading level="3">Directives</heading><paragraph>All DOM manipulation should be done inside directives. Directives should be kept small and use composition. Files defining directives should goog.provide a static function which returns the directive definition object.</paragraph><code language="javascript">
goog.provide('hello.pane.paneDirective');

/**
 * Description and usage
 * @return {angular.Directive} Directive definition object.
 */
hello.pane.paneDirective = function() {
  // ...
};
</code><paragraph>Exception: DOM manipulation may occur in services for DOM elements disconnected from the rest of the view, e.g. dialogs or keyboard shortcuts.</paragraph><heading level="3">Services</heading><paragraph>Services registered on the module with module.service are classes. Use module.service instead of module.provider or module.factory unless you need to do initialization beyond just creating a new instance of the class.</paragraph><code language="javascript">
/**
 * @param {!angular.$http} $http The Angular http service.
 * @constructor
 */
hello.request.Request = function($http) {
  /** @type {!angular.$http} */
  this.http_ = $http;
};

hello.request.Request.prototype.get = function() {/*...*/};
</code><paragraph>In the module:</paragraph><code language="code">
module.service('request', hello.request.Request);
</code><heading level="2">2 Angular Style Rules</heading><heading level="3">Reserve $ for Angular properties and services</heading><paragraph>Do not use $ to prepend your own object properties and service identifiers. Consider this style of naming reserved by AngularJS and jQuery.</paragraph><paragraph>Yes:</paragraph><code language="javascript">
  $scope.myModel = { value: 'foo' }
  myModule.service('myService', function() { /*...*/ });
  var MyCtrl = function($http) {this.http_ = $http;};
</code><paragraph>No:</paragraph><code language="javascript">
  $scope.$myModel = { value: 'foo' } // BAD
  $scope.myModel = { $value: 'foo' } // BAD
  myModule.service('$myService', function() { ... }); // BAD
  var MyCtrl = function($http) {this.$http_ = $http;}; // BAD
</code><paragraph>Why? It's useful to distinguish between Angular / jQuery builtins and things you add yourself. In addition, $ is not an acceptable character for variables names in the JS style guide.</paragraph><heading level="3">Custom elements</heading><paragraph>For custom elements (e.g. <ng-include src="template"></ng-include>), IE8 requires special support (html5shiv-like hacks) to enable css styling. Be aware of this restriction in apps targeting old versions of IE.</paragraph><heading level="2">3 Angular Tips, Tricks, and Best Practices</heading><paragraph>These are not strict style guide rules, but are placed here as reference for folks getting started with Angular at Google.</paragraph><heading level="3">Testing</heading><paragraph>Angular is designed for test-driven development.</paragraph><paragraph>The recommended unit testing setup is Jasmine + Karma (though you could use closure tests or js_test)</paragraph><paragraph>Angular provides easy adapters to load modules and use the injector in Jasmine tests.</paragraph><heading level="3">Consider using the Best Practices for App Structure</heading><paragraph>This directory structure doc describes how to structure your application with controllers in nested subdirectories and all components (e.g. services and directives) in a 'components' dir.</paragraph><heading level="3">Be aware of how scope inheritance works</heading><paragraph>See The Nuances of Scope Prototypal Inheritance</paragraph><heading level="3">Use @ngInject for easy dependency injection compilation</heading><paragraph>This removes the need to add myCtrl['$inject'] = ... to prevent minification from messing up Angular's dependency injection.</paragraph><paragraph>Usage:</paragraph><code language="javascript">
/**
 * My controller.
 * @param {!angular.$http} $http
 * @param {!my.app.myService} myService
 * @constructor
 * @export
 * @ngInject
 */
my.app.MyCtrl = function($http, myService) {
  //...
};
</code><heading level="2">4 Best practices links and docs</heading></content>
</page>
<page url="https://google.github.io/styleguide/go/best-practices">
<title>styleguide | Style guides for Google-originated open-source projects</title>
<content><heading level="1">Go Style Best Practices</heading><paragraph>https://google.github.io/styleguide/go/best-practices</paragraph><paragraph>Overview | Guide | Decisions | Best practices</paragraph><paragraph>Note: This is part of a series of documents that outline Go Style at Google. This document is neither normative nor canonical, and is an auxiliary document to the core style guide. See the overview for more information.</paragraph><heading level="2">About</heading><paragraph>This file documents guidance about how to best apply the Go Style Guide. This guidance is intended for common situations that arise frequently, but may not apply in every circumstance. Where possible, multiple alternative approaches are discussed along with the considerations that go into the decision about when and when not to apply them.</paragraph><paragraph>See the overview for the full set of Style Guide documents.</paragraph><heading level="2">Naming</heading><heading level="3">Function and method names</heading><heading level="4">Avoid repetition</heading><paragraph>When choosing the name for a function or method, consider the context in which the name will be read. Consider the following recommendations to avoid excess repetition at the call site:</paragraph><list type="ul"><item>The following can generally be omitted from function and method names: The types of the inputs and outputs (when there is no collision) The type of a method's receiver Whether an input or output is a pointer</item><item>For functions, do not repeat the name of the package. // Bad: package yamlconfig func ParseYAMLConfig(input string) (*Config, error) // Good: package yamlconfig func Parse(input string) (*Config, error)</item><item>For methods, do not repeat the name of the method receiver. // Bad: func (c *Config) WriteConfigTo(w io.Writer) (int64, error) // Good: func (c *Config) WriteTo(w io.Writer) (int64, error)</item><item>Do not repeat the names of variables passed as parameters. // Bad: func OverrideFirstWithSecond(dest, source *Config) error // Good: func Override(dest, source *Config) error</item><item>Do not repeat the names and types of the return values. // Bad: func TransformToJSON(input *Config) *jsonconfig.Config // Good: func Transform(input *Config) *jsonconfig.Config</item></list><paragraph>The following can generally be omitted from function and method names:</paragraph><list type="ul"><item>The types of the inputs and outputs (when there is no collision)</item><item>The type of a method's receiver</item><item>Whether an input or output is a pointer</item></list><paragraph>For functions, do not repeat the name of the package.</paragraph><code language="go">// Bad:
package yamlconfig

func ParseYAMLConfig(input string) (*Config, error)
</code><code language="go">// Good:
package yamlconfig

func Parse(input string) (*Config, error)
</code><paragraph>For methods, do not repeat the name of the method receiver.</paragraph><code language="code">// Bad:
func (c *Config) WriteConfigTo(w io.Writer) (int64, error)
</code><code language="code">// Good:
func (c *Config) WriteTo(w io.Writer) (int64, error)
</code><paragraph>Do not repeat the names of variables passed as parameters.</paragraph><code language="go">// Bad:
func OverrideFirstWithSecond(dest, source *Config) error
</code><code language="go">// Good:
func Override(dest, source *Config) error
</code><paragraph>Do not repeat the names and types of the return values.</paragraph><code language="go">// Bad:
func TransformToJSON(input *Config) *jsonconfig.Config
</code><code language="go">// Good:
func Transform(input *Config) *jsonconfig.Config
</code><paragraph>When it is necessary to disambiguate functions of a similar name, it is acceptable to include extra information.</paragraph><code language="code">// Good:
func (c *Config) WriteTextTo(w io.Writer) (int64, error)
func (c *Config) WriteBinaryTo(w io.Writer) (int64, error)
</code><heading level="4">Naming conventions</heading><paragraph>There are some other common conventions when choosing names for functions and methods:</paragraph><list type="ul"><item>Functions that return something are given noun-like names. // Good: func (c *Config) JobName(key string) (value string, ok bool) A corollary of this is that function and method names should avoid the prefix Get. // Bad: func (c *Config) GetJobName(key string) (value string, ok bool)</item><item>Functions that do something are given verb-like names. // Good: func (c *Config) WriteDetail(w io.Writer) (int64, error)</item><item>Identical functions that differ only by the types involved include the name of the type at the end of the name. // Good: func ParseInt(input string) (int, error) func ParseInt64(input string) (int64, error) func AppendInt(buf []byte, value int) []byte func AppendInt64(buf []byte, value int64) []byte If there is a clear "primary" version, the type can be omitted from the name for that version: // Good: func (c *Config) Marshal() ([]byte, error) func (c *Config) MarshalText() (string, error)</item></list><paragraph>Functions that return something are given noun-like names.</paragraph><code language="code">// Good:
func (c *Config) JobName(key string) (value string, ok bool)
</code><paragraph>A corollary of this is that function and method names should avoid the prefix Get.</paragraph><code language="code">// Bad:
func (c *Config) GetJobName(key string) (value string, ok bool)
</code><paragraph>Functions that do something are given verb-like names.</paragraph><code language="code">// Good:
func (c *Config) WriteDetail(w io.Writer) (int64, error)
</code><paragraph>Identical functions that differ only by the types involved include the name of the type at the end of the name.</paragraph><code language="go">// Good:
func ParseInt(input string) (int, error)
func ParseInt64(input string) (int64, error)
func AppendInt(buf []byte, value int) []byte
func AppendInt64(buf []byte, value int64) []byte
</code><paragraph>If there is a clear "primary" version, the type can be omitted from the name for that version:</paragraph><code language="code">// Good:
func (c *Config) Marshal() ([]byte, error)
func (c *Config) MarshalText() (string, error)
</code><heading level="3">Test double and helper packages</heading><paragraph>There are several disciplines you can apply to naming packages and types that provide test helpers and especially test doubles. A test double could be a stub, fake, mock, or spy.</paragraph><paragraph>These examples mostly use stubs. Update your names accordingly if your code uses fakes or another kind of test double.</paragraph><paragraph>Suppose you have a well-focused package providing production code similar to this:</paragraph><code language="javascript">package creditcard

import (
    "errors"

    "path/to/money"
)

// ErrDeclined indicates that the issuer declines the charge.
var ErrDeclined = errors.New("creditcard: declined")

// Card contains information about a credit card, such as its issuer,
// expiration, and limit.
type Card struct {
    // omitted
}

// Service allows you to perform operations with credit cards against external
// payment processor vendors like charge, authorize, reimburse, and subscribe.
type Service struct {
    // omitted
}

func (s *Service) Charge(c *Card, amount money.Money) error { /* omitted */ }
</code><heading level="4">Creating test helper packages</heading><paragraph>Suppose you want to create a package that contains test doubles for another. We'll use package creditcard (from above) for this example:</paragraph><paragraph>One approach is to introduce a new Go package based on the production one for testing. A safe choice is to append the word test to the original package name ("creditcard" + "test"):</paragraph><code language="code">// Good:
package creditcardtest
</code><paragraph>Unless stated explicitly otherwise, all examples in the sections below are in package creditcardtest.</paragraph><heading level="4">Simple case</heading><paragraph>You want to add a set of test doubles for Service. Because Card is effectively a dumb data type, similar to a Protocol Buffer message, it needs no special treatment in tests, so no double is required. If you anticipate only test doubles for one type (like Service), you can take a concise approach to naming the doubles:</paragraph><code language="javascript">// Good:
import (
    "path/to/creditcard"
    "path/to/money"
)

// Stub stubs creditcard.Service and provides no behavior of its own.
type Stub struct{}

func (Stub) Charge(*creditcard.Card, money.Money) error { return nil }
</code><paragraph>This is strictly preferable to a naming choice like StubService or the very poor StubCreditCardService, because the base package name and its domain types imply what creditcardtest.Stub is.</paragraph><paragraph>Finally, if the package is built with Bazel, make sure the new go_library rule for the package is marked as testonly:</paragraph><code language="code"># Good:
go_library(
    name = "creditcardtest",
    srcs = ["creditcardtest.go"],
    deps = [
        ":creditcard",
        ":money",
    ],
    testonly = True,
)
</code><paragraph>The approach above is conventional and will be reasonably well understood by other engineers.</paragraph><paragraph>See also:</paragraph><heading level="4">Multiple test double behaviors</heading><paragraph>When one kind of stub is not enough (for example, you also need one that always fails), we recommend naming the stubs according to the behavior they emulate. Here we rename Stub to AlwaysCharges and introduce a new stub called AlwaysDeclines:</paragraph><code language="javascript">// Good:
// AlwaysCharges stubs creditcard.Service and simulates success.
type AlwaysCharges struct{}

func (AlwaysCharges) Charge(*creditcard.Card, money.Money) error { return nil }

// AlwaysDeclines stubs creditcard.Service and simulates declined charges.
type AlwaysDeclines struct{}

func (AlwaysDeclines) Charge(*creditcard.Card, money.Money) error {
    return creditcard.ErrDeclined
}
</code><heading level="4">Multiple doubles for multiple types</heading><paragraph>But now suppose that package creditcard contains multiple types worth creating doubles for, as seen below with Service and StoredValue:</paragraph><code language="javascript">package creditcard

type Service struct {
    // omitted
}

type Card struct {
    // omitted
}

// StoredValue manages customer credit balances.  This applies when returned
// merchandise is credited to a customer's local account instead of processed
// by the credit issuer.  For this reason, it is implemented as a separate
// service.
type StoredValue struct {
    // omitted
}

func (s *StoredValue) Credit(c *Card, amount money.Money) error { /* omitted */ }
</code><paragraph>In this case, more explicit test double naming is sensible:</paragraph><code language="code">// Good:
type StubService struct{}

func (StubService) Charge(*creditcard.Card, money.Money) error { return nil }

type StubStoredValue struct{}

func (StubStoredValue) Credit(*creditcard.Card, money.Money) error { return nil }
</code><heading level="4">Local variables in tests</heading><paragraph>When variables in your tests refer to doubles, choose a name that most clearly differentiates the double from other production types based on context. Consider some production code you want to test:</paragraph><code language="javascript">package payment

import (
    "path/to/creditcard"
    "path/to/money"
)

type CreditCard interface {
    Charge(*creditcard.Card, money.Money) error
}

type Processor struct {
    CC CreditCard
}

var ErrBadInstrument = errors.New("payment: instrument is invalid or expired")

func (p *Processor) Process(c *creditcard.Card, amount money.Money) error {
    if c.Expired() {
        return ErrBadInstrument
    }
    return p.CC.Charge(c, amount)
}
</code><paragraph>In the tests, a test double called a "spy" for CreditCard is juxtaposed against production types, so prefixing the name may improve clarity.</paragraph><code language="javascript">// Good:
package payment

import "path/to/creditcardtest"

func TestProcessor(t *testing.T) {
    var spyCC creditcardtest.Spy
    proc := &Processor{CC: spyCC}

    // declarations omitted: card and amount
    if err := proc.Process(card, amount); err != nil {
        t.Errorf("proc.Process(card, amount) = %v, want nil", err)
    }

    charges := []creditcardtest.Charge{
        {Card: card, Amount: amount},
    }

    if got, want := spyCC.Charges, charges; !cmp.Equal(got, want) {
        t.Errorf("spyCC.Charges = %v, want %v", got, want)
    }
}
</code><paragraph>This is clearer than when the name is not prefixed.</paragraph><code language="javascript">// Bad:
package payment

import "path/to/creditcardtest"

func TestProcessor(t *testing.T) {
    var cc creditcardtest.Spy

    proc := &Processor{CC: cc}

    // declarations omitted: card and amount
    if err := proc.Process(card, amount); err != nil {
        t.Errorf("proc.Process(card, amount) = %v, want nil", err)
    }

    charges := []creditcardtest.Charge{
        {Card: card, Amount: amount},
    }

    if got, want := cc.Charges, charges; !cmp.Equal(got, want) {
        t.Errorf("cc.Charges = %v, want %v", got, want)
    }
}
</code><heading level="3">Shadowing</heading><paragraph>Note: This explanation uses two informal terms, stomping and shadowing. They are not official concepts in the Go language spec.</paragraph><paragraph>Like many programming languages, Go has mutable variables: assigning to a variable changes its value.</paragraph><code language="javascript">// Good:
func abs(i int) int {
    if i < 0 {
        i *= -1
    }
    return i
}
</code><paragraph>When using short variable declarations with the := operator, in some cases a new variable is not created. We can call this stomping. It's OK to do this when the original value is no longer needed.</paragraph><code language="javascript">// Good:
// innerHandler is a helper for some request handler, which itself issues
// requests to other backends.
func (s *Server) innerHandler(ctx context.Context, req *pb.MyRequest) *pb.MyResponse {
    // Unconditionally cap the deadline for this part of request handling.
    ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
    defer cancel()
    ctxlog.Info(ctx, "Capped deadline in inner request")

    // Code here no longer has access to the original context.
    // This is good style if when first writing this, you anticipate
    // that even as the code grows, no operation legitimately should
    // use the (possibly unbounded) original context that the caller provided.

    // ...
}
</code><paragraph>Be careful using short variable declarations in a new scope, though: that introduces a new variable. We can call this shadowing the original variable. Code after the end of the block refers to the original. Here is a buggy attempt to shorten the deadline conditionally:</paragraph><code language="javascript">// Bad:
func (s *Server) innerHandler(ctx context.Context, req *pb.MyRequest) *pb.MyResponse {
    // Attempt to conditionally cap the deadline.
    if *shortenDeadlines {
        ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
        defer cancel()
        ctxlog.Info(ctx, "Capped deadline in inner request")
    }

    // BUG: "ctx" here again means the context that the caller provided.
    // The above buggy code compiled because both ctx and cancel
    // were used inside the if statement.

    // ...
}
</code><paragraph>A correct version of the code might be:</paragraph><code language="javascript">// Good:
func (s *Server) innerHandler(ctx context.Context, req *pb.MyRequest) *pb.MyResponse {
    if *shortenDeadlines {
        var cancel func()
        // Note the use of simple assignment, = and not :=.
        ctx, cancel = context.WithTimeout(ctx, 3*time.Second)
        defer cancel()
        ctxlog.Info(ctx, "Capped deadline in inner request")
    }
    // ...
}
</code><paragraph>In the case we called stomping, because there's no new variable, the type being assigned must match that of the original variable. With shadowing, an entirely new entity is introduced so it can have a different type. Intentional shadowing can be a useful practice, but you can always use a new name if it improves clarity.</paragraph><paragraph>It is not a good idea to use variables with the same name as standard packages other than very small scopes, because that renders free functions and values from that package inaccessible. Conversely, when picking a name for your package, avoid names that are likely to require import renaming or cause shadowing of otherwise good variable names at the client side.</paragraph><code language="javascript">// Bad:
func LongFunction() {
    url := "https://example.com/"
    // Oops, now we can't use net/url in code below.
}
</code><heading level="3">Util packages</heading><paragraph>Go packages have a name specified on the package declaration, separate from the import path. The package name matters more for readability than the path.</paragraph><paragraph>Go package names should be related to what the package provides. Naming a package just util, helper, common or similar is usually a poor choice (it can be used as part of the name though). Uninformative names make the code harder to read, and if used too broadly they are liable to cause needless import conflicts.</paragraph><paragraph>Instead, consider what the callsite will look like.</paragraph><code language="code">// Good:
db := spannertest.NewDatabaseFromFile(...)

_, err := f.Seek(0, io.SeekStart)

b := elliptic.Marshal(curve, x, y)
</code><paragraph>You can tell roughly what each of these do even without knowing the imports list (cloud.google.com/go/spanner/spannertest, io, and crypto/elliptic). With less focused names, these might read:</paragraph><code language="code">// Bad:
db := test.NewDatabaseFromFile(...)

_, err := f.Seek(0, common.SeekStart)

b := helper.Marshal(curve, x, y)
</code><heading level="2">Package size</heading><paragraph>If you're asking yourself how big your Go packages should be and whether to place related types in the same package or split them into different ones, a good place to start is the Go blog post about package names. Despite the post title, it's not solely about naming. It contains some helpful hints and cites several useful articles and talks.</paragraph><paragraph>Here are some other considerations and notes.</paragraph><paragraph>Users see godoc for the package in one page, and any methods exported by types supplied by the package are grouped by their type. Godoc also group constructors along with the types they return. If client code is likely to need two values of different type to interact with each other, it may be convenient for the user to have them in the same package.</paragraph><paragraph>Code within a package can access unexported identifiers in the package. If you have a few related types whose implementation is tightly coupled, placing them in the same package lets you achieve this coupling without polluting the public API with these details. A good test for this coupling is to imagine a hypothetical user of two packages, where the packages cover closely related topics: if the user must import both packages in order to use either in any meaningful way, combining them together is usually the right thing to do. The standard library generally demonstrates this kind of scoping and layering well.</paragraph><paragraph>All of that being said, putting your entire project in a single package would likely make that package too large. When something is conceptually distinct, giving it its own small package can make it easier to use. The short name of the package as known to clients together with the exported type name work together to make a meaningful identifier: e.g. bytes.Buffer, ring.New. The Package Names blog post has more examples.</paragraph><paragraph>Go style is flexible about file size, because maintainers can move code within a package from one file to another without affecting callers. But as a general guideline: it is usually not a good idea to have a single file with many thousands of lines in it, or having many tiny files. There is no "one type, one file" convention as in some other languages. As a rule of thumb, files should be focused enough that a maintainer can tell which file contains something, and the files should be small enough that it will be easy to find once there. The standard library often splits large packages to several source files, grouping related code by file. The source for package bytes is a good example. Packages with long package documentation may choose to dedicate one file called doc.go that has the package documentation, a package declaration, and nothing else, but this is not required.</paragraph><paragraph>Within the Google codebase and in projects using Bazel, directory layout for Go code is different than it is in open source Go projects: you can have multiple go_library targets in a single directory. A good reason to give each package its own directory is if you expect to open source your project in the future.</paragraph><paragraph>A few non-canonical reference examples to help demonstrate these ideas in action:</paragraph><list type="ul"><item>small packages that contain one cohesive idea that warrant nothing more being added nor nothing being removed:</item><item>moderately sized packages that contain one large domain and its multiple responsibilities together:</item><item>large packages that divide several closely related domains across several files:</item></list><paragraph>small packages that contain one cohesive idea that warrant nothing more being added nor nothing being removed:</paragraph><paragraph>moderately sized packages that contain one large domain and its multiple responsibilities together:</paragraph><paragraph>large packages that divide several closely related domains across several files:</paragraph><paragraph>See also:</paragraph><heading level="2">Imports</heading><heading level="3">Protocol Buffer Messages and Stubs</heading><paragraph>Proto library imports are treated differently than standard Go imports due to their cross-language nature. The convention for renamed proto imports are based on the rule that generated the package:</paragraph><list type="ul"><item>The pb suffix is generally used for go_proto_library rules.</item><item>The grpc suffix is generally used for go_grpc_library rules.</item></list><paragraph>Often a single word describing the package is used:</paragraph><code language="javascript">// Good:
import (
    foopb "path/to/package/foo_service_go_proto"
    foogrpc "path/to/package/foo_service_go_grpc"
)
</code><paragraph>Follow the style guidance for package names. Prefer whole words. Short names are good, but avoid ambiguity. When in doubt, use the proto package name up to _go with a pb suffix:</paragraph><code language="javascript">// Good:
import (
    pushqueueservicepb "path/to/package/push_queue_service_go_proto"
)
</code><paragraph>Note: Previous guidance encouraged very short names such as "xpb" or even just "pb". New code should prefer more descriptive names. Existing code which uses short names should not be used as an example, but does not need to be changed.</paragraph><heading level="3">Import ordering</heading><paragraph>Imports are typically grouped into the following two (or more) blocks, in order:</paragraph><list type="ol"><item>Standard library imports (e.g., "fmt")</item><item>imports (e.g., "/path/to/somelib")</item><item>(optional) Protobuf imports (e.g., fpb "path/to/foo_go_proto")</item><item>(optional) Side-effect imports (e.g., _ "path/to/package")</item></list><paragraph>If a file does not have a group for one of the optional categories above, the relevant imports are included in the project import group.</paragraph><paragraph>Any import grouping that is clear and easy to understand is generally fine. For example, a team may choose to group gRPC imports separately from protobuf imports.</paragraph><paragraph>Note: For code maintaining only the two mandatory groups (one group for the standard library and one for all other imports), the goimports tool produces output consistent with this guidance.</paragraph><paragraph>However, goimports has no knowledge of groups beyond the mandatory ones; the optional groups are prone to invalidation by the tool. When optional groups are used, attention on the part of both authors and reviewers is required to ensure that groupings remain compliant.</paragraph><paragraph>Either approach is fine, but do not leave the imports section in an inconsistent, partially grouped state.</paragraph><heading level="2">Error handling</heading><paragraph>In Go, errors are values; they are created by code and consumed by code. Errors can be:</paragraph><list type="ul"><item>Converted into diagnostic information for display to humans</item><item>Used by the maintainer</item><item>Interpreted by an end user</item></list><paragraph>Error messages also show up across a variety of different surfaces including log messages, error dumps, and rendered UIs.</paragraph><paragraph>Code that processes (produces or consumes) errors should do so deliberately. It can be tempting to ignore or blindly propagate an error return value. However, it is always worth considering whether the current function in the call frame is positioned to handle the error most effectively. This is a large topic and it is hard to give categorical advice. Use your judgment, but keep the following considerations in mind:</paragraph><list type="ul"><item>When creating an error value, decide whether to give it any structure.</item><item>When handling an error, consider adding information that you have but that the caller and/or callee might not.</item><item>See also guidance on error logging.</item></list><paragraph>While it is usually not appropriate to ignore an error, a reasonable exception to this is when orchestrating related operations, where often only the first error is useful. Package errgroup provides a convenient abstraction for a group of operations that can all fail or be canceled as a group.</paragraph><paragraph>See also:</paragraph><heading level="3">Error structure</heading><paragraph>If callers need to interrogate the error (e.g., distinguish different error conditions), give the error value structure so that this can be done programmatically rather than having the caller perform string matching. This advice applies to production code as well as to tests that care about different error conditions.</paragraph><paragraph>The simplest structured errors are unparameterized global values.</paragraph><code language="javascript">type Animal string

var (
    // ErrDuplicate occurs if this animal has already been seen.
    ErrDuplicate = errors.New("duplicate")

    // ErrMarsupial occurs because we're allergic to marsupials outside Australia.
    // Sorry.
    ErrMarsupial = errors.New("marsupials are not supported")
)

func process(animal Animal) error {
    switch {
    case seen[animal]:
        return ErrDuplicate
    case marsupial(animal):
        return ErrMarsupial
    }
    seen[animal] = true
    // ...
    return nil
}
</code><paragraph>The caller can simply compare the returned error value of the function with one of the known error values:</paragraph><code language="javascript">// Good:
func handlePet(...) {
    switch err := process(an); err {
    case ErrDuplicate:
        return fmt.Errorf("feed %q: %v", an, err)
    case ErrMarsupial:
        // Try to recover with a friend instead.
        alternate = an.BackupAnimal()
        return handlePet(..., alternate, ...)
    }
}
</code><paragraph>The above uses sentinel values, where the error must be equal (in the sense of ==) to the expected value. That is perfectly adequate in many cases. If process returns wrapped errors (discussed below), you can use errors.Is.</paragraph><code language="javascript">// Good:
func handlePet(...) {
    switch err := process(an); {
    case errors.Is(err, ErrDuplicate):
        return fmt.Errorf("feed %q: %v", an, err)
    case errors.Is(err, ErrMarsupial):
        // ...
    }
}
</code><paragraph>Do not attempt to distinguish errors based on their string form. (See Go Tip #13: Designing Errors for Checking for more.)</paragraph><code language="javascript">// Bad:
func handlePet(...) {
    err := process(an)
    if regexp.MatchString(`duplicate`, err.Error()) {...}
    if regexp.MatchString(`marsupial`, err.Error()) {...}
}
</code><paragraph>If there is extra information in the error that the caller needs programmatically, it should ideally be presented structurally. For example, the os.PathError type is documented to place the pathname of the failing operation in a struct field which the caller can easily access.</paragraph><paragraph>Other error structures can be used as appropriate, for example a project struct containing an error code and detail string. Package status is a common encapsulation; if you choose this approach (which you are not obligated to do), use canonical codes. See Go Tip #89: When to Use Canonical Status Codes as Errors to know if using status codes is the right choice.</paragraph><heading level="3">Adding information to errors</heading><paragraph>Any function returning an error should strive to make the error value useful. Often, the function is in the middle of a callchain and is merely propagating an error from some other function that it called (maybe even from another package). Here there is an opportunity to annotate the error with extra information, but the programmer should ensure there's sufficient information in the error without adding duplicate or irrelevant detail. If you're unsure, try triggering the error condition during development: that's a good way to assess what the observers of the error (either humans or code) will end up with.</paragraph><paragraph>Convention and good documentation help. For example, the standard package os advertises that its errors contain path information when it is available. This is a useful style, because callers getting back an error don't need to annotate it with information that they had already provided the failing function.</paragraph><code language="javascript">// Good:
if err := os.Open("settings.txt"); err != nil {
    return err
}

// Output:
//
// open settings.txt: no such file or directory
</code><paragraph>If there is something interesting to say about the meaning of the error, of course it can be added. Just consider which level of the callchain is best positioned to understand this meaning.</paragraph><code language="javascript">// Good:
if err := os.Open("settings.txt"); err != nil {
    // We convey the significance of this error to us. Note that the current
    // function might perform more than one file operation that can fail, so
    // these annotations can also serve to disambiguate to the caller what went
    // wrong.
    return fmt.Errorf("launch codes unavailable: %v", err)
}

// Output:
//
// launch codes unavailable: open settings.txt: no such file or directory
</code><paragraph>Contrast with the redundant information here:</paragraph><code language="javascript">// Bad:
if err := os.Open("settings.txt"); err != nil {
    return fmt.Errorf("could not open settings.txt: %w", err)
}

// Output:
//
// could not open settings.txt: open settings.txt: no such file or directory
</code><paragraph>When adding information to a propagated error, you can either wrap the error or present a fresh error. Wrapping the error with the %w verb in fmt.Errorf allows callers to access data from the original error. This can be very useful at times, but in other cases these details are misleading or uninteresting to the caller. See the blog post on error wrapping for more information. Wrapping errors also expands the API surface of your package in a non-obvious way, and this can cause breakages if you change the implementation details of your package.</paragraph><paragraph>It is best to avoid using %w unless you also document (and have tests that validate) the underlying errors that you expose. If you do not expect your caller to call errors.Unwrap, errors.Is and so on, don't bother with %w.</paragraph><paragraph>The same concept applies to structured errors like *status.Status (see canonical codes). For example, if your server sends malformed requests to a backend and receives an InvalidArgument code, this code should not be propagated to the client, assuming that the client has done nothing wrong. Instead, return an Internal canonical code to the client.</paragraph><paragraph>However, annotating errors helps automated logging systems preserve the status payload of an error. For example, annotating the error is appropriate in an internal function:</paragraph><code language="javascript">// Good:
func (s *Server) internalFunction(ctx context.Context) error {
    // ...
    if err != nil {
        return fmt.Errorf("couldn't find remote file: %w", err)
    }
}
</code><paragraph>Code directly at system boundaries (typically RPC, IPC, storage, and similar) should report errors using the canonical error space. It is the responsibility of code here to handle domain-specific errors and represent them canonically. For example:</paragraph><code language="javascript">// Bad:
func (*FortuneTeller) SuggestFortune(context.Context, *pb.SuggestionRequest) (*pb.SuggestionResponse, error) {
    // ...
    if err != nil {
        return nil, fmt.Errorf("couldn't find remote file: %w", err)
    }
}
</code><code language="javascript">// Good:
import (
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
)
func (*FortuneTeller) SuggestFortune(context.Context, *pb.SuggestionRequest) (*pb.SuggestionResponse, error) {
    // ...
    if err != nil {
        // Or use fmt.Errorf with the %w verb if deliberately wrapping an
        // error which the caller is meant to unwrap.
        return nil, status.Errorf(codes.Internal, "couldn't find fortune database", status.ErrInternal)
    }
}
</code><paragraph>See also:</paragraph><heading level="3">Placement of %w in errors</heading><paragraph>Prefer to place %w at the end of an error string.</paragraph><paragraph>Errors can be wrapped with the %w verb, or by placing them in a structured error that implements Unwrap() error (ex: fs.PathError).</paragraph><paragraph>Wrapped errors form error chains: each new layer of wrapping adds a new entry to the front of the error chain. The error chain can be traversed with the Unwrap() error method. For example:</paragraph><code language="code">err1 := fmt.Errorf("err1")
err2 := fmt.Errorf("err2: %w", err1)
err3 := fmt.Errorf("err3: %w", err2)
</code><paragraph>This forms an error chain of the form,</paragraph><code language="javascript">flowchart LR
  err3 == err3 wraps err2 ==> err2;
  err2 == err2 wraps err1 ==> err1;
</code><paragraph>Regardless of where the %w verb is placed, the error returned always represents the front of the error chain, and the %w is the next child. Similarly, Unwrap() error always traverses the error chain from newest to oldest error.</paragraph><paragraph>Placement of the %w verb does, however, affect whether the error chain is printed newest to oldest, oldest to newest, or neither:</paragraph><code language="code">// Good:
err1 := fmt.Errorf("err1")
err2 := fmt.Errorf("err2: %w", err1)
err3 := fmt.Errorf("err3: %w", err2)
fmt.Println(err3) // err3: err2: err1
// err3 is a newest-to-oldest error chain, that prints newest-to-oldest.
</code><code language="code">// Bad:
err1 := fmt.Errorf("err1")
err2 := fmt.Errorf("%w: err2", err1)
err3 := fmt.Errorf("%w: err3", err2)
fmt.Println(err3) // err1: err2: err3
// err3 is a newest-to-oldest error chain, that prints oldest-to-newest.
</code><code language="code">// Bad:
err1 := fmt.Errorf("err1")
err2 := fmt.Errorf("err2-1 %w err2-2", err1)
err3 := fmt.Errorf("err3-1 %w err3-2", err2)
fmt.Println(err3) // err3-1 err2-1 err1 err2-2 err3-2
// err3 is a newest-to-oldest error chain, that neither prints newest-to-oldest
// nor oldest-to-newest.
</code><paragraph>Therefore, in order for error text to mirror error chain structure, prefer placing the %w verb at the end with the form [...]: %w.</paragraph><heading level="3">Logging errors</heading><paragraph>Functions sometimes need to tell an external system about an error without propagating it to their callers. Logging is an obvious choice here; but be conscious of what and how you log errors.</paragraph><list type="ul"><item>Like good test failure messages, log messages should clearly express what went wrong and help the maintainer by including relevant information to diagnose the problem.</item><item>Avoid duplication. If you return an error, it's usually better not to log it yourself but rather let the caller handle it. The caller can choose to log the error, or perhaps rate-limit logging using rate.Sometimes. Other options include attempting recovery or even stopping the program. In any case, giving the caller control helps avoid logspam. The downside to this approach, however, is that any logging is written using the caller's line coordinates.</item><item>Be careful with PII. Many log sinks are not appropriate destinations for sensitive end-user information.</item><item>Use log.Error sparingly. ERROR level logging causes a flush and is more expensive than lower logging levels. This can have serious performance impact on your code. When deciding between error and warning levels, consider the best practice that messages at the error level should be actionable rather than "more serious" than a warning.</item><item>Inside Google, we have monitoring systems that can be set up for more effective alerting than writing to a log file and hoping someone notices it. This is similar but not identical to the standard library package expvar.</item></list><paragraph>Like good test failure messages, log messages should clearly express what went wrong and help the maintainer by including relevant information to diagnose the problem.</paragraph><paragraph>Avoid duplication. If you return an error, it's usually better not to log it yourself but rather let the caller handle it. The caller can choose to log the error, or perhaps rate-limit logging using rate.Sometimes. Other options include attempting recovery or even stopping the program. In any case, giving the caller control helps avoid logspam.</paragraph><paragraph>The downside to this approach, however, is that any logging is written using the caller's line coordinates.</paragraph><paragraph>Be careful with PII. Many log sinks are not appropriate destinations for sensitive end-user information.</paragraph><paragraph>Use log.Error sparingly. ERROR level logging causes a flush and is more expensive than lower logging levels. This can have serious performance impact on your code. When deciding between error and warning levels, consider the best practice that messages at the error level should be actionable rather than "more serious" than a warning.</paragraph><paragraph>Inside Google, we have monitoring systems that can be set up for more effective alerting than writing to a log file and hoping someone notices it. This is similar but not identical to the standard library package expvar.</paragraph><heading level="4">Custom verbosity levels</heading><paragraph>Use verbose logging (log.V) to your advantage. Verbose logging can be useful for development and tracing. Establishing a convention around verbosity levels can be helpful. For example:</paragraph><list type="ul"><item>Write a small amount of extra information at V(1)</item><item>Trace more information in V(2)</item><item>Dump large internal states in V(3)</item></list><paragraph>To minimize the cost of verbose logging, you should ensure not to accidentally call expensive functions even when log.V is turned off. log.V offers two APIs. The more convenient one carries the risk of this accidental expense. When in doubt, use the slightly more verbose style.</paragraph><code language="javascript">// Good:
for _, sql := range queries {
  log.V(1).Infof("Handling %v", sql)
  if log.V(2) {
    log.Infof("Handling %v", sql.Explain())
  }
  sql.Run(...)
}
</code><code language="code">// Bad:
// sql.Explain called even when this log is not printed.
log.V(2).Infof("Handling %v", sql.Explain())
</code><heading level="3">Program initialization</heading><paragraph>Program initialization errors (such as bad flags and configuration) should be propagated upward to main, which should call log.Exit with an error that explains how to fix the error. In these cases, log.Fatal should not generally be used, because a stack trace that points at the check is not likely to be as useful as a human-generated, actionable message.</paragraph><heading level="3">Program checks and panics</heading><paragraph>As stated in the decision against panics, standard error handling should be structured around error return values. Libraries should prefer returning an error to the caller rather than aborting the program, especially for transient errors.</paragraph><paragraph>It is occasionally necessary to perform consistency checks on an invariant and terminate the program if it is violated. In general, this is only done when a failure of the invariant check means that the internal state has become unrecoverable. The most reliable way to do this in the Google codebase is to call log.Fatal. Using panic in these cases is not reliable, because it is possible for deferred functions to deadlock or further corrupt internal or external state.</paragraph><paragraph>Similarly, resist the temptation to recover panics to avoid crashes, as doing so can result in propagating a corrupted state. The further you are from the panic, the less you know about the state of the program, which could be holding locks or other resources. The program can then develop other unexpected failure modes that can make the problem even more difficult to diagnose. Instead of trying to handle unexpected panics in code, use monitoring tools to surface unexpected failures and fix related bugs with a high priority.</paragraph><paragraph>Note: The standard net/http server violates this advice and recovers panics from request handlers. Consensus among experienced Go engineers is that this was a historical mistake. If you sample server logs from application servers in other languages, it is common to find large stacktraces that are left unhandled. Avoid this pitfall in your servers.</paragraph><heading level="3">When to panic</heading><paragraph>The standard library panics on API misuse. For example, reflect issues a panic in many cases where a value is accessed in a way that suggests it was misinterpreted. This is analogous to the panics on core language bugs such as accessing an element of a slice that is out of bounds. Code review and tests should discover such bugs, which are not expected to appear in production code. These panics act as invariant checks that do not depend on a library, as the standard library does not have access to the levelled log package that the Google codebase uses.</paragraph><paragraph>Another case in which panics can be useful, though uncommon, is as an internal implementation detail of a package which always has a matching recover in the callchain. Parsers and similar deeply nested, tightly coupled internal function groups can benefit from this design, where plumbing error returns adds complexity without value.</paragraph><paragraph>The key attribute of this design is that these panics are never allowed to escape across package boundaries and do not form part of the package's API. This is typically accomplished with a top-level deferred function that uses recover to translate a propagated panic into a returned error at the public API boundary. It requires the code that panics and recovers to distinguish between panics that the code raises itself and those that it doesn't:</paragraph><code language="javascript">// Good:
type syntaxError struct {
  msg string
}

func parseInt(in string) int {
  n, err := strconv.Atoi(in)
  if err != nil {
    panic(&syntaxError{"not a valid integer"})
  }
}

func Parse(in string) (_ *Node, err error) {
  defer func() {
    if p := recover(); p != nil {
      sErr, ok := p.(*syntaxError)
      if !ok {
        panic(p) // Propagate the panic since it is outside our code's domain.
      }
      err = fmt.Errorf("syntax error: %v", sErr.msg)
    }
  }()
  ... // Parse input calling parseInt internally to parse integers
}
</code><paragraph>Warning: Code employing this pattern must take care to manage any resources associated with the code run in such defer-managed sections (e.g., close, free, or unlock).</paragraph><paragraph>See: Go Tip #81: Avoiding Resource Leaks in API Design</paragraph><paragraph>Panic is also used when the compiler cannot identify unreachable code, for example when using a function like log.Fatal that will not return:</paragraph><code language="javascript">// Good:
func answer(i int) string {
    switch i {
    case 42:
        return "yup"
    case 54:
        return "base 13, huh"
    default:
        log.Fatalf("Sorry, %d is not the answer.", i)
        panic("unreachable")
    }
}
</code><paragraph>Do not call log functions before flags have been parsed. If you must die in a package initialization function (an init or a "must" function), a panic is acceptable in place of the fatal logging call.</paragraph><paragraph>See also:</paragraph><heading level="2">Documentation</heading><heading level="3">Conventions</heading><paragraph>This section augments the decisions document's commentary section.</paragraph><paragraph>Go code that is documented in familiar style is easier to read and less likely to be misused than something misdocumented or not documented at all. Runnable examples show up in Godoc and Code Search and are an excellent way of explaining how to use your code.</paragraph><heading level="4">Parameters and configuration</heading><paragraph>Not every parameter must be enumerated in the documentation. This applies to:</paragraph><list type="ul"><item>function and method parameters</item><item>struct fields</item><item>APIs for options</item></list><paragraph>Document the error-prone or non-obvious fields and parameters by saying why they are interesting.</paragraph><paragraph>In the following snippet, the highlighted commentary adds little useful information to the reader:</paragraph><code language="go">// Bad:
// Sprintf formats according to a format specifier and returns the resulting
// string.
//
// format is the format, and data is the interpolation data.
func Sprintf(format string, data ...any) string
</code><paragraph>However, this snippet demonstrates a code scenario similar to the previous where the commentary instead states something non-obvious or materially helpful to the reader:</paragraph><code language="go">// Good:
// Sprintf formats according to a format specifier and returns the resulting
// string.
//
// The provided data is used to interpolate the format string. If the data does
// not match the expected format verbs or the amount of data does not satisfy
// the format specification, the function will inline warnings about formatting
// errors into the output string as described by the Format errors section
// above.
func Sprintf(format string, data ...any) string
</code><paragraph>Consider your likely audience in choosing what to document and at what depth. Maintainers, newcomers to the team, external users, and even yourself six months in the future may appreciate slightly different information from what is on your mind when you first come to write your docs.</paragraph><paragraph>See also:</paragraph><heading level="4">Contexts</heading><paragraph>It is implied that the cancellation of a context argument interrupts the function it is provided to. If the function can return an error, conventionally it is ctx.Err().</paragraph><paragraph>This fact does not need to be restated:</paragraph><code language="code">// Bad:
// Run executes the worker's run loop.
//
// The method will process work until the context is cancelled and accordingly
// returns an error.
func (Worker) Run(ctx context.Context) error
</code><paragraph>Because that is implied, the following is better:</paragraph><code language="code">// Good:
// Run executes the worker's run loop.
func (Worker) Run(ctx context.Context) error
</code><paragraph>Where context behavior is different or non-obvious, it should be expressly documented if any of the following are true.</paragraph><list type="ul"><item>The function returns an error other than ctx.Err() when the context is cancelled: // Good: // Run executes the worker's run loop. // // If the context is cancelled, Run returns a nil error. func (Worker) Run(ctx context.Context) error</item><item>The function has other mechanisms that may interrupt it or affect lifetime: // Good: // Run executes the worker's run loop. // // Run processes work until the context is cancelled or Stop is called. // Context cancellation is handled asynchronously internally: run may return // before all work has stopped. The Stop method is synchronous and waits // until all operations from the run loop finish. Use Stop for graceful // shutdown. func (Worker) Run(ctx context.Context) error func (Worker) Stop()</item><item>The function has special expectations about context lifetime, lineage, or attached values: // Good: // NewReceiver starts receiving messages sent to the specified queue. // The context should not have a deadline. func NewReceiver(ctx context.Context) *Receiver // Principal returns a human-readable name of the party who made the call. // The context must have a value attached to it from security.NewContext. func Principal(ctx context.Context) (name string, ok bool) Warning: Avoid designing APIs that make such demands (like contexts not having deadlines) from their callers. The above is only an example of how to document this if it cannot be avoided, not an endorsement of the pattern.</item></list><paragraph>The function returns an error other than ctx.Err() when the context is cancelled:</paragraph><code language="code">// Good:
// Run executes the worker's run loop.
//
// If the context is cancelled, Run returns a nil error.
func (Worker) Run(ctx context.Context) error
</code><paragraph>The function has other mechanisms that may interrupt it or affect lifetime:</paragraph><code language="code">// Good:
// Run executes the worker's run loop.
//
// Run processes work until the context is cancelled or Stop is called.
// Context cancellation is handled asynchronously internally: run may return
// before all work has stopped. The Stop method is synchronous and waits
// until all operations from the run loop finish. Use Stop for graceful
// shutdown.
func (Worker) Run(ctx context.Context) error

func (Worker) Stop()
</code><paragraph>The function has special expectations about context lifetime, lineage, or attached values:</paragraph><code language="go">// Good:
// NewReceiver starts receiving messages sent to the specified queue.
// The context should not have a deadline.
func NewReceiver(ctx context.Context) *Receiver

// Principal returns a human-readable name of the party who made the call.
// The context must have a value attached to it from security.NewContext.
func Principal(ctx context.Context) (name string, ok bool)
</code><paragraph>Warning: Avoid designing APIs that make such demands (like contexts not having deadlines) from their callers. The above is only an example of how to document this if it cannot be avoided, not an endorsement of the pattern.</paragraph><heading level="4">Concurrency</heading><paragraph>Go users assume that conceptually read-only operations are safe for concurrent use and do not require extra synchronization.</paragraph><paragraph>The extra remark about concurrency can safely be removed in this Godoc:</paragraph><code language="code">// Len returns the number of bytes of the unread portion of the buffer;
// b.Len() == len(b.Bytes()).
//
// It is safe to be called concurrently by multiple goroutines.
func (*Buffer) Len() int
</code><paragraph>Mutating operations, however, are not assumed to be safe for concurrent use and require the user to consider synchronization.</paragraph><paragraph>Similarly, the extra remark about concurrency can safely be removed here:</paragraph><code language="code">// Grow grows the buffer's capacity.
//
// It is not safe to be called concurrently by multiple goroutines.
func (*Buffer) Grow(n int)
</code><paragraph>Documentation is strongly encouraged if any of the following are true.</paragraph><list type="ul"><item>It is unclear whether the operation is read-only or mutating: // Good: package lrucache // Lookup returns the data associated with the key from the cache. // // This operation is not safe for concurrent use. func (*Cache) Lookup(key string) (data []byte, ok bool) Why? A cache hit when looking up the key mutate a LRU cache internally. How this is implemented may not be obvious to all readers.</item><item>Synchronization is provided by the API: // Good: package fortune_go_proto // NewFortuneTellerClient returns an *rpc.Client for the FortuneTeller service. // It is safe for simultaneous use by multiple goroutines. func NewFortuneTellerClient(cc *rpc.ClientConn) *FortuneTellerClient Why? Stubby provides synchronization. Note: If the API is a type and the API provides synchronization in entirety, conventionally only the type definition documents the semantics.</item><item>The API consumes user-implemented types of interfaces, and the interface's consumer has particular concurrency requirements: // Good: package health // A Watcher reports the health of some entity (usually a backend service). // // Watcher methods are safe for simultaneous use by multiple goroutines. type Watcher interface { // Watch sends true on the passed-in channel when the Watcher's // status has changed. Watch(changed chan<- bool) (unwatch func()) // Health returns nil if the entity being watched is healthy, or a // non-nil error explaining why the entity is not healthy. Health() error } Why? Whether an API is safe for use by multiple goroutines is part of its contract.</item></list><paragraph>It is unclear whether the operation is read-only or mutating:</paragraph><code language="code">// Good:
package lrucache

// Lookup returns the data associated with the key from the cache.
//
// This operation is not safe for concurrent use.
func (*Cache) Lookup(key string) (data []byte, ok bool)
</code><paragraph>Why? A cache hit when looking up the key mutate a LRU cache internally. How this is implemented may not be obvious to all readers.</paragraph><paragraph>Synchronization is provided by the API:</paragraph><code language="go">// Good:
package fortune_go_proto

// NewFortuneTellerClient returns an *rpc.Client for the FortuneTeller service.
// It is safe for simultaneous use by multiple goroutines.
func NewFortuneTellerClient(cc *rpc.ClientConn) *FortuneTellerClient
</code><paragraph>Why? Stubby provides synchronization.</paragraph><paragraph>Note: If the API is a type and the API provides synchronization in entirety, conventionally only the type definition documents the semantics.</paragraph><paragraph>The API consumes user-implemented types of interfaces, and the interface's consumer has particular concurrency requirements:</paragraph><code language="javascript">// Good:
package health

// A Watcher reports the health of some entity (usually a backend service).
//
// Watcher methods are safe for simultaneous use by multiple goroutines.
type Watcher interface {
    // Watch sends true on the passed-in channel when the Watcher's
    // status has changed.
    Watch(changed chan<- bool) (unwatch func())

    // Health returns nil if the entity being watched is healthy, or a
    // non-nil error explaining why the entity is not healthy.
    Health() error
}
</code><paragraph>Why? Whether an API is safe for use by multiple goroutines is part of its contract.</paragraph><heading level="4">Cleanup</heading><paragraph>Document any explicit cleanup requirements that the API has. Otherwise, callers won't use the API correctly, leading to resource leaks and other possible bugs.</paragraph><paragraph>Call out cleanups that are up to the caller:</paragraph><code language="go">// Good:
// NewTicker returns a new Ticker containing a channel that will send the
// current time on the channel after each tick.
//
// Call Stop to release the Ticker's associated resources when done.
func NewTicker(d Duration) *Ticker

func (*Ticker) Stop()
</code><paragraph>If it is potentially unclear how to clean up the resources, explain how:</paragraph><code language="javascript">// Good:
// Get issues a GET to the specified URL.
//
// When err is nil, resp always contains a non-nil resp.Body.
// Caller should close resp.Body when done reading from it.
//
//    resp, err := http.Get("http://example.com/")
//    if err != nil {
//        // handle error
//    }
//    defer resp.Body.Close()
//    body, err := io.ReadAll(resp.Body)
func (c *Client) Get(url string) (resp *Response, err error)
</code><paragraph>See also:</paragraph><heading level="4">Errors</heading><paragraph>Document significant error sentinel values or error types that your functions return to callers so that callers can anticipate what types of conditions they can handle in their code.</paragraph><code language="javascript">// Good:
package os

// Read reads up to len(b) bytes from the File and stores them in b. It returns
// the number of bytes read and any error encountered.
//
// At end of file, Read returns 0, io.EOF.
func (*File) Read(b []byte) (n int, err error) {
</code><paragraph>When a function returns a specific error type, correctly note whether the error is a pointer receiver or not:</paragraph><code language="javascript">// Good:
package os

type PathError struct {
    Op   string
    Path string
    Err  error
}

// Chdir changes the current working directory to the named directory.
//
// If there is an error, it will be of type *PathError.
func Chdir(dir string) error {
</code><paragraph>Documenting whether the values returned are pointer receivers enables callers to correctly compare the errors using errors.Is, errors.As, and package cmp. This is because a non-pointer value is not equivalent to a pointer value.</paragraph><paragraph>Note: In the Chdir example, the return type is written as error rather than *PathError due to how nil interface values work.</paragraph><paragraph>Document overall error conventions in the package's documentation when the behavior is applicable to most errors found in the package:</paragraph><code language="code">// Good:
// Package os provides a platform-independent interface to operating system
// functionality.
//
// Often, more information is available within the error. For example, if a
// call that takes a file name fails, such as Open or Stat, the error will
// include the failing file name when printed and will be of type *PathError,
// which may be unpacked for more information.
package os
</code><paragraph>Thoughtful application of these approaches can add extra information to errors without much effort and help callers avoid adding redundant annotations.</paragraph><paragraph>See also:</paragraph><heading level="3">Preview</heading><paragraph>Go features a documentation server. It is recommended to preview the documentation your code produces both before and during the code review process. This helps to validate that the godoc formatting is rendered correctly.</paragraph><heading level="3">Godoc formatting</heading><paragraph>Godoc provides some specific syntax to format documentation.</paragraph><list type="ul"><item>A blank line is required to separate paragraphs: // Good: // LoadConfig reads a configuration out of the named file. // // See some/shortlink for config file format details.</item><item>Test files can contain runnable examples that appear attached to the corresponding documentation in godoc: // Good: func ExampleConfig_WriteTo() { cfg := &Config{ Name: "example", } if err := cfg.WriteTo(os.Stdout); err != nil { log.Exitf("Failed to write config: %s", err) } // Output: // { // "name": "example" // } }</item><item>Indenting lines by an additional two spaces formats them verbatim: // Good: // Update runs the function in an atomic transaction. // // This is typically used with an anonymous TransactionFunc: // // if err := db.Update(func(state *State) { state.Foo = bar }); err != nil { // //... // } Note, however, that it can often be more appropriate to put code in a runnable example instead of including it in a comment. This verbatim formatting can be leveraged for formatting that is not native to godoc, such as lists and tables: // Good: // LoadConfig reads a configuration out of the named file. // // LoadConfig treats the following keys in special ways: // "import" will make this configuration inherit from the named file. // "env" if present will be populated with the system environment.</item><item>A single line that begins with a capital letter, contains no punctuation except parentheses and commas, and is followed by another paragraph, is formatted as a header: // Good: // The following line is formatted as a heading. // // Using headings // // Headings come with autogenerated anchor tags for easy linking.</item></list><paragraph>A blank line is required to separate paragraphs:</paragraph><code language="code">// Good:
// LoadConfig reads a configuration out of the named file.
//
// See some/shortlink for config file format details.
</code><paragraph>Test files can contain runnable examples that appear attached to the corresponding documentation in godoc:</paragraph><code language="javascript">// Good:
func ExampleConfig_WriteTo() {
  cfg := &Config{
    Name: "example",
  }
  if err := cfg.WriteTo(os.Stdout); err != nil {
    log.Exitf("Failed to write config: %s", err)
  }
  // Output:
  // {
  //   "name": "example"
  // }
}
</code><paragraph>Indenting lines by an additional two spaces formats them verbatim:</paragraph><code language="javascript">// Good:
// Update runs the function in an atomic transaction.
//
// This is typically used with an anonymous TransactionFunc:
//
//   if err := db.Update(func(state *State) { state.Foo = bar }); err != nil {
//     //...
//   }
</code><paragraph>Note, however, that it can often be more appropriate to put code in a runnable example instead of including it in a comment.</paragraph><paragraph>This verbatim formatting can be leveraged for formatting that is not native to godoc, such as lists and tables:</paragraph><code language="code">// Good:
// LoadConfig reads a configuration out of the named file.
//
// LoadConfig treats the following keys in special ways:
//   "import" will make this configuration inherit from the named file.
//   "env" if present will be populated with the system environment.
</code><paragraph>A single line that begins with a capital letter, contains no punctuation except parentheses and commas, and is followed by another paragraph, is formatted as a header:</paragraph><code language="code">// Good:
// The following line is formatted as a heading.
//
// Using headings
//
// Headings come with autogenerated anchor tags for easy linking.
</code><heading level="3">Signal boosting</heading><paragraph>Sometimes a line of code looks like something common, but actually isn't. One of the best examples of this is an err == nil check (since err != nil is much more common). The following two conditional checks are hard to distinguish:</paragraph><code language="javascript">// Good:
if err := doSomething(); err != nil {
    // ...
}
</code><code language="javascript">// Bad:
if err := doSomething(); err == nil {
    // ...
}
</code><paragraph>You can instead "boost" the signal of the conditional by adding a comment:</paragraph><code language="code">// Good:
if err := doSomething(); err == nil { // if NO error
    // ...
}
</code><paragraph>The comment draws attention to the difference in the conditional.</paragraph><heading level="2">Variable declarations</heading><heading level="3">Initialization</heading><paragraph>For consistency, prefer := over var when initializing a new variable with a non-zero value.</paragraph><heading level="3">Declaring variables with zero values</heading><paragraph>The following declarations use the zero value:</paragraph><code language="javascript">// Good:
var (
    coords Point
    magic  [4]byte
    primes []int
)
</code><paragraph>You should declare values using the zero value when you want to convey an empty value that is ready for later use. Using composite literals with explicit initialization can be clunky:</paragraph><code language="javascript">// Bad:
var (
    coords = Point{X: 0, Y: 0}
    magic  = [4]byte{0, 0, 0, 0}
    primes = []int(nil)
)
</code><paragraph>A common application of zero value declaration is when using a variable as the output when unmarshalling:</paragraph><code language="javascript">// Good:
var coords Point
if err := json.Unmarshal(data, &coords); err != nil {
</code><paragraph>It is also okay to use the zero value in the following form when you need a variable of a pointer type:</paragraph><code language="javascript">// Good:
msg := new(pb.Bar) // or "&pb.Bar{}"
if err := proto.Unmarshal(data, msg); err != nil {
</code><paragraph>If you need a lock or other field that must not be copied in your struct, you can make it a value type to take advantage of zero value initialization. It does mean that the containing type must now be passed via a pointer and not a value. Methods on the type must take pointer receivers.</paragraph><code language="javascript">// Good:
type Counter struct {
    // This field does not have to be "*sync.Mutex". However,
    // users must now pass *Counter objects between themselves, not Counter.
    mu   sync.Mutex
    data map[string]int64
}

// Note this must be a pointer receiver to prevent copying.
func (c *Counter) IncrementBy(name string, n int64)
</code><paragraph>It's acceptable to use value types for local variables of composites (such as structs and arrays) even if they contain such uncopyable fields. However, if the composite is returned by the function, or if all accesses to it end up needing to take an address anyway, prefer declaring the variable as a pointer type at the outset. Similarly, protobufs should be declared as pointer types.</paragraph><code language="javascript">// Good:
func NewCounter(name string) *Counter {
    c := new(Counter) // "&Counter{}" is also fine.
    registerCounter(name, c)
    return c
}

var msg = new(pb.Bar) // or "&pb.Bar{}".
</code><paragraph>This is because *pb.Something satisfies proto.Message while pb.Something does not.</paragraph><code language="javascript">// Bad:
func NewCounter(name string) *Counter {
    var c Counter
    registerCounter(name, &c)
    return &c
}

var msg = pb.Bar{}
</code><paragraph>Important: Map types must be explicitly initialized before they can be modified. However, reading from zero-value maps is perfectly fine.</paragraph><paragraph>For map and slice types, if the code is particularly performance sensitive and if you know the sizes in advance, see the size hints section.</paragraph><heading level="3">Composite literals</heading><paragraph>The following are composite literal declarations:</paragraph><code language="javascript">// Good:
var (
    coords   = Point{X: x, Y: y}
    magic    = [4]byte{'I', 'W', 'A', 'D'}
    primes   = []int{2, 3, 5, 7, 11}
    captains = map[string]string{"Kirk": "James Tiberius", "Picard": "Jean-Luc"}
)
</code><paragraph>You should declare a value using a composite literal when you know initial elements or members.</paragraph><paragraph>In contrast, using composite literals to declare empty or memberless values can be visually noisy compared to zero-value initialization.</paragraph><paragraph>When you need a pointer to a zero value, you have two options: empty composite literals and new. Both are fine, but the new keyword can serve to remind the reader that if a non-zero value were needed, a composite literal wouldn't work:</paragraph><code language="javascript">// Good:
var (
  buf = new(bytes.Buffer) // non-empty Buffers are initialized with constructors.
  msg = new(pb.Message) // non-empty proto messages are initialized with builders or by setting fields one by one.
)
</code><heading level="3">Size hints</heading><paragraph>The following are declarations that take advantage of size hints in order to preallocate capacity:</paragraph><code language="javascript">// Good:
var (
    // Preferred buffer size for target filesystem: st_blksize.
    buf = make([]byte, 131072)
    // Typically process up to 8-10 elements per run (16 is a safe assumption).
    q = make([]Node, 0, 16)
    // Each shard processes shardSize (typically 32000+) elements.
    seen = make(map[string]bool, shardSize)
)
</code><paragraph>Size hints and preallocation are important steps when combined with empirical analysis of the code and its integrations, to create performance-sensitive and resource-efficient code.</paragraph><paragraph>Most code does not need a size hint or preallocation, and can allow the runtime to grow the slice or map as necessary. It is acceptable to preallocate when the final size is known (e.g. when converting between a map and a slice) but this is not a readability requirement, and may not be worth the clutter in small cases.</paragraph><paragraph>Warning: Preallocating more memory than you need can waste memory in the fleet or even harm performance. When in doubt, see GoTip #3: Benchmarking Go Code and default to a zero initialization or a composite literal declaration.</paragraph><heading level="3">Channel direction</heading><paragraph>Specify channel direction where possible.</paragraph><code language="javascript">// Good:
// sum computes the sum of all of the values. It reads from the channel until
// the channel is closed.
func sum(values <-chan int) int {
    // ...
}
</code><paragraph>This prevents casual programming errors that are possible without specification:</paragraph><code language="javascript">// Bad:
func sum(values chan int) (out int) {
    for v := range values {
        out += v
    }
    // values must already be closed for this code to be reachable, which means
    // a second close triggers a panic.
    close(values)
}
</code><paragraph>When the direction is specified, the compiler catches simple errors like this. It also helps to convey a measure of ownership to the type.</paragraph><paragraph>See also Bryan Mills' talk "Rethinking Classical Concurrency Patterns": slides video.</paragraph><heading level="2">Function argument lists</heading><paragraph>Don't let the signature of a function get too long. As more parameters are added to a function, the role of individual parameters becomes less clear, and adjacent parameters of the same type become easier to confuse. Functions with large numbers of arguments are less memorable and more difficult to read at the call-site.</paragraph><paragraph>When designing an API, consider splitting a highly configurable function whose signature is growing complex into several simpler ones. These can share an (unexported) implementation if necessary.</paragraph><paragraph>Where a function requires many inputs, consider introducing an option struct for some of the arguments or employing the more advanced variadic options technique. The primary consideration for which strategy to choose should be how the function call looks across all expected use cases.</paragraph><paragraph>The recommendations below primarily apply to exported APIs, which are held to a higher standard than unexported ones. These techniques may be unnecessary for your use case. Use your judgment, and balance the principles of clarity and least mechanism.</paragraph><paragraph>See also: Go Tip #24: Use Case-Specific Constructions</paragraph><heading level="3">Option structure</heading><paragraph>An option structure is a struct type that collects some or all of the arguments of a function or method, that is then passed as the last argument to the function or method. (The struct should be exported only if it is used in an exported function.)</paragraph><paragraph>Using an option structure has a number of benefits:</paragraph><list type="ul"><item>The struct literal includes both fields and values for each argument, which makes them self-documenting and harder to swap.</item><item>Irrelevant or "default" fields can be omitted.</item><item>Callers can share the option struct and write helpers to operate on it.</item><item>Structs provide cleaner per-field documentation than function arguments.</item><item>Option structs can grow over time without impacting call-sites.</item></list><paragraph>Here is an example of a function that could be improved:</paragraph><code language="javascript">// Bad:
func EnableReplication(ctx context.Context, config *replicator.Config, primaryRegions, readonlyRegions []string, replicateExisting, overwritePolicies bool, replicationInterval time.Duration, copyWorkers int, healthWatcher health.Watcher) {
    // ...
}
</code><paragraph>The function above could be rewritten with an option structure as follows:</paragraph><code language="javascript">// Good:
type ReplicationOptions struct {
    Config              *replicator.Config
    PrimaryRegions      []string
    ReadonlyRegions     []string
    ReplicateExisting   bool
    OverwritePolicies   bool
    ReplicationInterval time.Duration
    CopyWorkers         int
    HealthWatcher       health.Watcher
}

func EnableReplication(ctx context.Context, opts ReplicationOptions) {
    // ...
}
</code><paragraph>The function can then be called in a different package:</paragraph><code language="javascript">// Good:
func foo(ctx context.Context) {
    // Complex call:
    storage.EnableReplication(ctx, storage.ReplicationOptions{
        Config:              config,
        PrimaryRegions:      []string{"us-east1", "us-central2", "us-west3"},
        ReadonlyRegions:     []string{"us-east5", "us-central6"},
        OverwritePolicies:   true,
        ReplicationInterval: 1 * time.Hour,
        CopyWorkers:         100,
        HealthWatcher:       watcher,
    })

    // Simple call:
    storage.EnableReplication(ctx, storage.ReplicationOptions{
        Config:         config,
        PrimaryRegions: []string{"us-east1", "us-central2", "us-west3"},
    })
}
</code><paragraph>Note: Contexts are never included in option structs.</paragraph><paragraph>This option is often preferred when some of the following apply:</paragraph><list type="ul"><item>All callers need to specify one or more of the options.</item><item>A large number of callers need to provide many options.</item><item>The options are shared between multiple functions that the user will call.</item></list><heading level="3">Variadic options</heading><paragraph>Using variadic options, exported functions are created which return closures that can be passed to the variadic (...) parameter of a function. The function takes as its parameters the values of the option (if any), and the returned closure accepts a mutable reference (usually a pointer to a struct type) that will be updated based on the inputs.</paragraph><paragraph>Using variadic options can provide a number of benefits:</paragraph><list type="ul"><item>Options take no space at a call-site when no configuration is needed.</item><item>Options are still values, so callers can share them, write helpers, and accumulate them.</item><item>Options can accept multiple parameters (e.g. cartesian.Translate(dx, dy int) TransformOption).</item><item>The option functions can return a named type to group options together in godoc.</item><item>Packages can allow (or prevent) third-party packages to define (or from defining) their own options.</item></list><paragraph>Note: Using variadic options requires a substantial amount of additional code (see the following example), so it should only be used when the advantages outweigh the overhead.</paragraph><paragraph>Here is an example of a function that could be improved:</paragraph><code language="javascript">// Bad:
func EnableReplication(ctx context.Context, config *placer.Config, primaryCells, readonlyCells []string, replicateExisting, overwritePolicies bool, replicationInterval time.Duration, copyWorkers int, healthWatcher health.Watcher) {
  ...
}
</code><paragraph>The example above could be rewritten with variadic options as follows:</paragraph><code language="javascript">// Good:
type replicationOptions struct {
    readonlyCells       []string
    replicateExisting   bool
    overwritePolicies   bool
    replicationInterval time.Duration
    copyWorkers         int
    healthWatcher       health.Watcher
}

// A ReplicationOption configures EnableReplication.
type ReplicationOption func(*replicationOptions)

// ReadonlyCells adds additional cells that should additionally
// contain read-only replicas of the data.
//
// Passing this option multiple times will add additional
// read-only cells.
//
// Default: none
func ReadonlyCells(cells ...string) ReplicationOption {
    return func(opts *replicationOptions) {
        opts.readonlyCells = append(opts.readonlyCells, cells...)
    }
}

// ReplicateExisting controls whether files that already exist in the
// primary cells will be replicated.  Otherwise, only newly-added
// files will be candidates for replication.
//
// Passing this option again will overwrite earlier values.
//
// Default: false
func ReplicateExisting(enabled bool) ReplicationOption {
    return func(opts *replicationOptions) {
        opts.replicateExisting = enabled
    }
}

// ... other options ...

// DefaultReplicationOptions control the default values before
// applying options passed to EnableReplication.
var DefaultReplicationOptions = []ReplicationOption{
    OverwritePolicies(true),
    ReplicationInterval(12 * time.Hour),
    CopyWorkers(10),
}

func EnableReplication(ctx context.Context, config *placer.Config, primaryCells []string, opts ...ReplicationOption) {
    var options replicationOptions
    for _, opt := range DefaultReplicationOptions {
        opt(&options)
    }
    for _, opt := range opts {
        opt(&options)
    }
}
</code><paragraph>The function can then be called in a different package:</paragraph><code language="javascript">// Good:
func foo(ctx context.Context) {
    // Complex call:
    storage.EnableReplication(ctx, config, []string{"po", "is", "ea"},
        storage.ReadonlyCells("ix", "gg"),
        storage.OverwritePolicies(true),
        storage.ReplicationInterval(1*time.Hour),
        storage.CopyWorkers(100),
        storage.HealthWatcher(watcher),
    )

    // Simple call:
    storage.EnableReplication(ctx, config, []string{"po", "is", "ea"})
}
</code><paragraph>Prefer this option when many of the following apply:</paragraph><list type="ul"><item>Most callers will not need to specify any options.</item><item>Most options are used infrequently.</item><item>There are a large number of options.</item><item>Options require arguments.</item><item>Options could fail or be set incorrectly (in which case the option function returns an error).</item><item>Options require a lot of documentation that can be hard to fit in a struct.</item><item>Users or other packages can provide custom options.</item></list><paragraph>Options in this style should accept parameters rather than using presence to signal their value; the latter can make dynamic composition of arguments much more difficult. For example, binary settings should accept a boolean (e.g. rpc.FailFast(enable bool) is preferable to rpc.EnableFailFast()). An enumerated option should accept an enumerated constant (e.g. log.Format(log.Capacitor) is preferable to log.CapacitorFormat()). The alternative makes it much more difficult for users who must programmatically choose which options to pass; such users are forced to change the actual composition of the parameters rather than simply changing the arguments to the options. Don't assume that all users will know the full set of options statically.</paragraph><paragraph>In general, options should be processed in order. If there is a conflict or if a non-cumulative option is passed multiple times, the last argument should win.</paragraph><paragraph>The parameter to the option function is generally unexported in this pattern, to restrict the options to being defined only within the package itself. This is a good default, though there may be times when it is appropriate to allow other packages to define options.</paragraph><paragraph>See Rob Pike's original blog post and Dave Cheney's talk for a more in-depth look at how these options can be used.</paragraph><heading level="2">Complex command-line interfaces</heading><paragraph>Some programs wish to present users with a rich command-line interface that includes sub-commands. For example, kubectl create, kubectl run, and many other sub-commands are all provided by the program kubectl. There are at least the following libraries in common use for achieving this.</paragraph><paragraph>If you don't have a preference or other considerations are equal, subcommands is recommended, since it is the simplest and is easy to use correctly. However, if you need different features that it doesn't provide, pick one of the other options.</paragraph><list type="ul"><item>cobra Flag convention: getopt Common outside the Google codebase. Many extra features. Pitfalls in usage (see below).</item><item>subcommands Flag convention: Go Simple and easy to use correctly. Recommended if you don't need extra features.</item></list><paragraph>cobra</paragraph><list type="ul"><item>Flag convention: getopt</item><item>Common outside the Google codebase.</item><item>Many extra features.</item><item>Pitfalls in usage (see below).</item></list><paragraph>subcommands</paragraph><list type="ul"><item>Flag convention: Go</item><item>Simple and easy to use correctly.</item><item>Recommended if you don't need extra features.</item></list><paragraph>Warning: cobra command functions should use cmd.Context() to obtain a context rather than creating their own root context with context.Background. Code that uses the subcommands package already receives the correct context as a function parameter.</paragraph><paragraph>You are not required to place each subcommand in a separate package, and it is often not necessary to do so. Apply the same considerations about package boundaries as in any Go codebase. If your code can be used both as a library and as a binary, it is usually beneficial to separate the CLI code and the library, making the CLI just one more of its clients. (This is not specific to CLIs that have subcommands, but is mentioned here because it is a common place where it comes up.)</paragraph><heading level="2">Tests</heading><heading level="3">Leave testing to the Test function</heading><paragraph>Go distinguishes between "test helpers" and "assertion helpers":</paragraph><list type="ul"><item>Test helpers are functions that do setup or cleanup tasks. All failures that occur in test helpers are expected to be failures of the environment (not from the code under test) — for example when a test database cannot be started because there are no more free ports on this machine. For functions like these, calling t.Helper is often appropriate to mark them as a test helper. See error handling in test helpers for more details.</item><item>Assertion helpers are functions that check the correctness of a system and fail the test if an expectation is not met. Assertion helpers are not considered idiomatic in Go.</item></list><paragraph>Test helpers are functions that do setup or cleanup tasks. All failures that occur in test helpers are expected to be failures of the environment (not from the code under test) — for example when a test database cannot be started because there are no more free ports on this machine. For functions like these, calling t.Helper is often appropriate to mark them as a test helper. See error handling in test helpers for more details.</paragraph><paragraph>Assertion helpers are functions that check the correctness of a system and fail the test if an expectation is not met. Assertion helpers are not considered idiomatic in Go.</paragraph><paragraph>The purpose of a test is to report pass/fail conditions of the code under test. The ideal place to fail a test is within the Test function itself, as that ensures that failure messages and the test logic are clear.</paragraph><paragraph>As your testing code grows, it may become necessary to factor out some functionality to separate functions. Standard software engineering considerations still apply, as test code is still code. If the functionality does not interact with the testing framework, then all of the usual rules apply. When the common code interacts with the framework, however, some care must be taken to avoid common pitfalls that can lead to uninformative failure messages and unmaintainable tests.</paragraph><paragraph>If many separate test cases require the same validation logic, arrange the test in one of the following ways instead of using assertion helpers or complex validation functions:</paragraph><list type="ul"><item>Inline the logic (both the validation and the failure) in the Test function, even if it is repetitive. This works best in simple cases.</item><item>If inputs are similar, consider unifying them into a table-driven test while keeping the logic inlined in the loop. This helps to avoid repetition while keeping the validation and failure in the Test.</item><item>If there are multiple callers who need the same validation function but table tests are not suitable (typically because the inputs are not simple enough or the validation is required as part of a sequence of operations), arrange the validation function so that it returns a value (typically an error) rather than taking a testing.T parameter and using it to fail the test. Use logic within the Test to decide whether to fail, and to provide useful test failures. You can also create test helpers to factor out common boilerplate setup code.</item></list><paragraph>The design outlined in the last point maintains orthogonality. For example, package cmp is not designed to fail tests, but rather to compare (and to diff) values. It therefore does not need to know about the context in which the comparison was made, since the caller can supply that. If your common testing code provides a cmp.Transformer for your data type, that can often be the simplest design. For other validations, consider returning an error value.</paragraph><code language="javascript">// Good:
// polygonCmp returns a cmp.Option that equates s2 geometry objects up to
// some small floating-point error.
func polygonCmp() cmp.Option {
    return cmp.Options{
        cmp.Transformer("polygon", func(p *s2.Polygon) []*s2.Loop { return p.Loops() }),
        cmp.Transformer("loop", func(l *s2.Loop) []s2.Point { return l.Vertices() }),
        cmpopts.EquateApprox(0.00000001, 0),
        cmpopts.EquateEmpty(),
    }
}

func TestFenceposts(t *testing.T) {
    // This is a test for a fictional function, Fenceposts, which draws a fence
    // around some Place object. The details are not important, except that
    // the result is some object that has s2 geometry (github.com/golang/geo/s2)
    got := Fencepost(tomsDiner, 1*meter)
    if diff := cmp.Diff(want, got, polygonCmp()); diff != "" {
        t.Errorf("Fencepost(tomsDiner, 1m) returned unexpected diff (-want+got):\n%v", diff)
    }
}

func FuzzFencepost(f *testing.F) {
    // Fuzz test (https://go.dev/doc/fuzz) for the same.

    f.Add(tomsDiner, 1*meter)
    f.Add(school, 3*meter)

    f.Fuzz(func(t *testing.T, geo Place, padding Length) {
        got := Fencepost(geo, padding)
        // Simple reference implementation: not used in prod, but easy to
        // reason about and therefore useful to check against in random tests.
        reference := slowFencepost(geo, padding)

        // In the fuzz test, inputs and outputs can be large so don't
        // bother with printing a diff. cmp.Equal is enough.
        if !cmp.Equal(got, reference, polygonCmp()) {
            t.Errorf("Fencepost returned wrong placement")
        }
    })
}
</code><paragraph>The polygonCmp function is agnostic about how it's called; it doesn't take a concrete input type nor does it police what to do in case two objects don't match. Therefore, more callers can make use of it.</paragraph><paragraph>Note: There is an analogy between test helpers and plain library code. Code in libraries should usually not panic except in rare circumstances; code called from a test should not stop the test unless there is no point in proceeding.</paragraph><heading level="3">Designing extensible validation APIs</heading><paragraph>Most of the advice about testing in the style guide is about testing your own code. This section is about how to provide facilities for other people to test the code they write to ensure that it conforms to your library's requirements.</paragraph><heading level="4">Acceptance testing</heading><paragraph>Such testing is referred to as acceptance testing. The premise of this kind of testing is that the person using the test does not know every last detail of what goes on in the test; they just hand the inputs over to the testing facility to do the work. This can be thought of as a form of inversion of control.</paragraph><paragraph>In a typical Go test, the test function controls the program flow, and the no assert and test functions guidance encourages you to keep it that way. This section explains how to author support for these tests in a way that is consistent with Go style.</paragraph><paragraph>Before diving into how, consider an example from io/fs, excerpted below:</paragraph><code language="javascript">type FS interface {
    Open(name string) (File, error)
}
</code><paragraph>While there exist well-known implementations of fs.FS, a Go developer may be expected to author one. To help validate the user-implemented fs.FS is correct, a generic library has been provided in testing/fstest called fstest.TestFS. This API treats the implementation as a blackbox to make sure it upholds the most basic parts of the io/fs contract.</paragraph><heading level="4">Writing an acceptance test</heading><paragraph>Now that we know what an acceptance test is and why you might use one, let's explore building an acceptance test for package chess, a package used to simulate chess games. Users of chess are expected to implement the chess.Player interface. These implementations are the primary thing we will validate. Our acceptance test concerns itself with whether the player implementation makes legal moves, not whether the moves are smart.</paragraph><list type="ol"><item>Create a new package for the validation behavior, customarily named by appending the word test to the package name (for example, chesstest).</item><item>Create the function that performs the validation by accepting the implementation under test as an argument and exercises it: // ExercisePlayer tests a Player implementation in a single turn on a board. // The board itself is spot checked for sensibility and correctness. // // It returns a nil error if the player makes a correct move in the context // of the provided board. Otherwise ExercisePlayer returns one of this // package's errors to indicate how and why the player failed the // validation. func ExercisePlayer(b *chess.Board, p chess.Player) error The test should note which invariants are broken and how. Your design can choose between two disciplines for failure reporting: Fail fast: return an error as soon as the implementation violates an invariant. This is the simplest approach, and it works well if the acceptance test is expected to execute quickly. Simple error sentinels and custom types can be used easily here, which conversely makes testing the acceptance test easy. for color, army := range b.Armies { // The king should never leave the board, because the game ends at // checkmate. if army.King == nil { return &MissingPieceError{Color: color, Piece: chess.King} } } Aggregate all failures: collect all failures, and report them all. This approach resembles the keep going guidance in feel and may be preferable if the acceptance test is expected to execute slowly. How you aggregate the failures should be dictated by whether you want to give users the ability or yourself the ability to interrogate individual failures (for example, for you to test your acceptance test). Below demonstrates using a custom error type that aggregates errors: var badMoves []error move := p.Move() if putsOwnKingIntoCheck(b, move) { badMoves = append(badMoves, PutsSelfIntoCheckError{Move: move}) } if len(badMoves) > 0 { return SimulationError{BadMoves: badMoves} } return nil</item></list><paragraph>Create a new package for the validation behavior, customarily named by appending the word test to the package name (for example, chesstest).</paragraph><paragraph>Create the function that performs the validation by accepting the implementation under test as an argument and exercises it:</paragraph><code language="go">// ExercisePlayer tests a Player implementation in a single turn on a board.
// The board itself is spot checked for sensibility and correctness.
//
// It returns a nil error if the player makes a correct move in the context
// of the provided board. Otherwise ExercisePlayer returns one of this
// package's errors to indicate how and why the player failed the
// validation.
func ExercisePlayer(b *chess.Board, p chess.Player) error
</code><paragraph>The test should note which invariants are broken and how. Your design can choose between two disciplines for failure reporting:</paragraph><list type="ul"><item>Fail fast: return an error as soon as the implementation violates an invariant. This is the simplest approach, and it works well if the acceptance test is expected to execute quickly. Simple error sentinels and custom types can be used easily here, which conversely makes testing the acceptance test easy. for color, army := range b.Armies { // The king should never leave the board, because the game ends at // checkmate. if army.King == nil { return &MissingPieceError{Color: color, Piece: chess.King} } }</item><item>Aggregate all failures: collect all failures, and report them all. This approach resembles the keep going guidance in feel and may be preferable if the acceptance test is expected to execute slowly. How you aggregate the failures should be dictated by whether you want to give users the ability or yourself the ability to interrogate individual failures (for example, for you to test your acceptance test). Below demonstrates using a custom error type that aggregates errors: var badMoves []error move := p.Move() if putsOwnKingIntoCheck(b, move) { badMoves = append(badMoves, PutsSelfIntoCheckError{Move: move}) } if len(badMoves) > 0 { return SimulationError{BadMoves: badMoves} } return nil</item></list><paragraph>Fail fast: return an error as soon as the implementation violates an invariant.</paragraph><paragraph>This is the simplest approach, and it works well if the acceptance test is expected to execute quickly. Simple error sentinels and custom types can be used easily here, which conversely makes testing the acceptance test easy.</paragraph><code language="javascript">for color, army := range b.Armies {
    // The king should never leave the board, because the game ends at
    // checkmate.
    if army.King == nil {
        return &MissingPieceError{Color: color, Piece: chess.King}
    }
}
</code><paragraph>Aggregate all failures: collect all failures, and report them all.</paragraph><paragraph>This approach resembles the keep going guidance in feel and may be preferable if the acceptance test is expected to execute slowly.</paragraph><paragraph>How you aggregate the failures should be dictated by whether you want to give users the ability or yourself the ability to interrogate individual failures (for example, for you to test your acceptance test). Below demonstrates using a custom error type that aggregates errors:</paragraph><code language="javascript">var badMoves []error

move := p.Move()
if putsOwnKingIntoCheck(b, move) {
    badMoves = append(badMoves, PutsSelfIntoCheckError{Move: move})
}

if len(badMoves) > 0 {
    return SimulationError{BadMoves: badMoves}
}
return nil
</code><paragraph>The acceptance test should honor the keep going guidance by not calling t.Fatal unless the test detects a broken invariant in the system being exercised.</paragraph><paragraph>For example, t.Fatal should be reserved for exceptional cases such as setup failure as usual:</paragraph><code language="javascript">func ExerciseGame(t *testing.T, cfg *Config, p chess.Player) error {
    t.Helper()

    if cfg.Simulation == Modem {
        conn, err := modempool.Allocate()
        if err != nil {
            t.Fatalf("No modem for the opponent could be provisioned: %v", err)
        }
        t.Cleanup(func() { modempool.Return(conn) })
    }
    // Run acceptance test (a whole game).
}
</code><paragraph>This technique can help you create concise, canonical validations. But do not attempt to use it to bypass the guidance on assertions.</paragraph><paragraph>The final product should be in a form similar to this for end users:</paragraph><code language="javascript">// Good:
package deepblue_test

import (
    "chesstest"
    "deepblue"
)

func TestAcceptance(t *testing.T) {
    player := deepblue.New()
    err := chesstest.ExerciseGame(t, chesstest.SimpleGame, player)
    if err != nil {
        t.Errorf("Deep Blue player failed acceptance test: %v", err)
    }
}
</code><heading level="3">Use real transports</heading><paragraph>When testing component integrations, especially where HTTP or RPC are used as the underlying transport between the components, prefer using the real underlying transport to connect to the test version of the backend.</paragraph><paragraph>For example, suppose the code you want to test (sometimes referred to as "system under test" or SUT) interacts with a backend that implements the long running operations API. To test your SUT, use a real OperationsClient that is connected to a test double (e.g., a mock, stub, or fake) of the OperationsServer.</paragraph><paragraph>This is recommended over hand-implementing the client, due to the complexity of imitating client behavior correctly. By using the production client with a test-specific server, you ensure your test is using as much of the real code as possible.</paragraph><paragraph>Tip: Where possible, use a testing library provided by the authors of the service under test.</paragraph><heading level="3">t.Error vs. t.Fatal</heading><paragraph>As discussed in decisions, tests should generally not abort at the first encountered problem.</paragraph><paragraph>However, some situations require that the test not proceed. Calling t.Fatal is appropriate when some piece of test setup fails, especially in test setup helpers, without which you cannot run the rest of the test. In a table-driven test, t.Fatal is appropriate for failures that set up the whole test function before the test loop. Failures that affect a single entry in the test table, which make it impossible to continue with that entry, should be reported as follows:</paragraph><list type="ul"><item>If you're not using t.Run subtests, use t.Error followed by a continue statement to move on to the next table entry.</item><item>If you're using subtests (and you're inside a call to t.Run), use t.Fatal, which ends the current subtest and allows your test case to progress to the next subtest.</item></list><paragraph>Warning: It is not always safe to call t.Fatal and similar functions. More details here.</paragraph><heading level="3">Error handling in test helpers</heading><paragraph>Note: This section discusses test helpers in the sense Go uses the term: functions that perform test setup and cleanup, not common assertion facilities. See the test functions section for more discussion.</paragraph><paragraph>Operations performed by a test helper sometimes fail. For example, setting up a directory with files involves I/O, which can fail. When test helpers fail, their failure often signifies that the test cannot continue, since a setup precondition failed. When this happens, prefer calling one of the Fatal functions in the helper:</paragraph><code language="javascript">// Good:
func mustAddGameAssets(t *testing.T, dir string) {
    t.Helper()
    if err := os.WriteFile(path.Join(dir, "pak0.pak"), pak0, 0644); err != nil {
        t.Fatalf("Setup failed: could not write pak0 asset: %v", err)
    }
    if err := os.WriteFile(path.Join(dir, "pak1.pak"), pak1, 0644); err != nil {
        t.Fatalf("Setup failed: could not write pak1 asset: %v", err)
    }
}
</code><paragraph>This keeps the calling side cleaner than if the helper were to return the error to the test itself:</paragraph><code language="javascript">// Bad:
func addGameAssets(t *testing.T, dir string) error {
    t.Helper()
    if err := os.WriteFile(path.Join(d, "pak0.pak"), pak0, 0644); err != nil {
        return err
    }
    if err := os.WriteFile(path.Join(d, "pak1.pak"), pak1, 0644); err != nil {
        return err
    }
    return nil
}
</code><paragraph>Warning: It is not always safe to call t.Fatal and similar functions. More details here.</paragraph><paragraph>The failure message should include a description of what happened. This is important, as you may be providing a testing API to many users, especially as the number of error-producing steps in the helper increases. When the test fails, the user should know where, and why.</paragraph><paragraph>Tip: Go 1.14 introduced a t.Cleanup function that can be used to register cleanup functions that run when your test completes. The function also works with test helpers. See GoTip #4: Cleaning Up Your Tests for guidance on simplifying test helpers.</paragraph><paragraph>The snippet below in a fictional file called paint_test.go demonstrates how (*testing.T).Helper influences failure reporting in a Go test:</paragraph><code language="javascript">package paint_test

import (
    "fmt"
    "testing"
)

func paint(color string) error {
    return fmt.Errorf("no %q paint today", color)
}

func badSetup(t *testing.T) {
    // This should call t.Helper, but doesn't.
    if err := paint("taupe"); err != nil {
        t.Fatalf("Could not paint the house under test: %v", err) // line 15
    }
}

func mustGoodSetup(t *testing.T) {
    t.Helper()
    if err := paint("lilac"); err != nil {
        t.Fatalf("Could not paint the house under test: %v", err)
    }
}

func TestBad(t *testing.T) {
    badSetup(t)
    // ...
}

func TestGood(t *testing.T) {
    mustGoodSetup(t) // line 32
    // ...
}
</code><paragraph>Here is an example of this output when run. Note the highlighted text and how it differs:</paragraph><code language="code">=== RUN   TestBad
    paint_test.go:15: Could not paint the house under test: no "taupe" paint today
--- FAIL: TestBad (0.00s)
=== RUN   TestGood
    paint_test.go:32: Could not paint the house under test: no "lilac" paint today
--- FAIL: TestGood (0.00s)
FAIL
</code><paragraph>The error with paint_test.go:15 refers to the line of the setup function that failed in badSetup:</paragraph><paragraph>t.Fatalf("Could not paint the house under test: %v", err)</paragraph><paragraph>Whereas paint_test.go:32 refers to the line of the test that failed in TestGood:</paragraph><paragraph>goodSetup(t)</paragraph><paragraph>Correctly using (*testing.T).Helper attributes the location of the failure much better when:</paragraph><list type="ul"><item>the helper functions grow</item><item>the helper functions call other helpers</item><item>the amount of helper usage in the test functions grow</item></list><paragraph>Tip: If a helper calls (*testing.T).Error or (*testing.T).Fatal, provide some context in the format string to help determine what went wrong and why.</paragraph><paragraph>Tip: If nothing a helper does can cause a test to fail, it doesn't need to call t.Helper. Simplify its signature by removing t from the function parameter list.</paragraph><heading level="3">Don't call t.Fatal from separate goroutines</heading><paragraph>As documented in package testing, it is incorrect to call t.FailNow, t.Fatal, etc. from any goroutine but the one running the Test function (or the subtest). If your test starts new goroutines, they must not call these functions from inside these goroutines.</paragraph><paragraph>Test helpers usually don't signal failure from new goroutines, and therefore it is all right for them to use t.Fatal. If in doubt, call t.Error and return instead.</paragraph><code language="javascript">// Good:
func TestRevEngine(t *testing.T) {
    engine, err := Start()
    if err != nil {
        t.Fatalf("Engine failed to start: %v", err)
    }

    num := 11
    var wg sync.WaitGroup
    wg.Add(num)
    for i := 0; i < num; i++ {
        go func() {
            defer wg.Done()
            if err := engine.Vroom(); err != nil {
                // This cannot be t.Fatalf.
                t.Errorf("No vroom left on engine: %v", err)
                return
            }
            if rpm := engine.Tachometer(); rpm > 1e6 {
                t.Errorf("Inconceivable engine rate: %d", rpm)
            }
        }()
    }
    wg.Wait()

    if seen := engine.NumVrooms(); seen != num {
        t.Errorf("engine.NumVrooms() = %d, want %d", seen, num)
    }
}
</code><paragraph>Adding t.Parallel to a test or subtest does not make it unsafe to call t.Fatal.</paragraph><paragraph>When all calls to the testing API are in the test function, it is usually easy to spot incorrect usage because the go keyword is plain to see. Passing testing.T arguments around makes tracking such usage harder. Typically, the reason for passing these arguments is to introduce a test helper, and those should not depend on the system under test. Therefore, if a test helper registers a fatal test failure, it can and should do so from the test's goroutine.</paragraph><heading level="3">Use field names in struct literals</heading><paragraph>In table-driven tests, prefer to specify field names when initializing test case struct literals. This is helpful when the test cases cover a large amount of vertical space (e.g. more than 20-30 lines), when there are adjacent fields with the same type, and also when you wish to omit fields which have the zero value. For example:</paragraph><code language="javascript">// Good:
func TestStrJoin(t *testing.T) {
    tests := []struct {
        slice     []string
        separator string
        skipEmpty bool
        want      string
    }{
        {
            slice:     []string{"a", "b", ""},
            separator: ",",
            want:      "a,b,",
        },
        {
            slice:     []string{"a", "b", ""},
            separator: ",",
            skipEmpty: true,
            want:      "a,b",
        },
        // ...
    }
    // ...
}
</code><heading level="3">Keep setup code scoped to specific tests</heading><paragraph>Where possible, setup of resources and dependencies should be as closely scoped to specific test cases as possible. For example, given a setup function:</paragraph><code language="javascript">// mustLoadDataSet loads a data set for the tests.
//
// This example is very simple and easy to read. Often realistic setup is more
// complex, error-prone, and potentially slow.
func mustLoadDataset(t *testing.T) []byte {
    t.Helper()
    data, err := os.ReadFile("path/to/your/project/testdata/dataset")

    if err != nil {
        t.Fatalf("Could not load dataset: %v", err)
    }
    return data
}
</code><paragraph>Call mustLoadDataset explicitly in test functions that need it:</paragraph><code language="javascript">// Good:
func TestParseData(t *testing.T) {
    data := mustLoadDataset(t)
    parsed, err := ParseData(data)
    if err != nil {
        t.Fatalf("Unexpected error parsing data: %v", err)
    }
    want := &DataTable{ /* ... */ }
    if got := parsed; !cmp.Equal(got, want) {
        t.Errorf("ParseData(data) = %v, want %v", got, want)
    }
}

func TestListContents(t *testing.T) {
    data := mustLoadDataset(t)
    contents, err := ListContents(data)
    if err != nil {
        t.Fatalf("Unexpected error listing contents: %v", err)
    }
    want := []string{ /* ... */ }
    if got := contents; !cmp.Equal(got, want) {
        t.Errorf("ListContents(data) = %v, want %v", got, want)
    }
}

func TestRegression682831(t *testing.T) {
    if got, want := guessOS("zpc79.example.com"), "grhat"; got != want {
        t.Errorf(`guessOS("zpc79.example.com") = %q, want %q`, got, want)
    }
}
</code><paragraph>The test function TestRegression682831 does not use the data set and therefore does not call mustLoadDataset, which could be slow and failure-prone:</paragraph><code language="javascript">// Bad:
var dataset []byte

func TestParseData(t *testing.T) {
    // As documented above without calling mustLoadDataset directly.
}

func TestListContents(t *testing.T) {
    // As documented above without calling mustLoadDataset directly.
}

func TestRegression682831(t *testing.T) {
    if got, want := guessOS("zpc79.example.com"), "grhat"; got != want {
        t.Errorf(`guessOS("zpc79.example.com") = %q, want %q`, got, want)
    }
}

func init() {
    dataset = mustLoadDataset()
}
</code><paragraph>A user may wish to run a function in isolation of the others and should not be penalized by these factors:</paragraph><code language="code"># No reason for this to perform the expensive initialization.
$ go test -run TestRegression682831
</code><heading level="4">When to use a custom TestMain entrypoint</heading><paragraph>If all tests in the package require common setup and the setup requires teardown, you can use a custom testmain entrypoint. This can happen if the resource the test cases require is especially expensive to setup, and the cost should be amortized. Typically you have extracted any unrelated tests from the test suite at that point. It is typically only used for functional tests.</paragraph><paragraph>Using a custom TestMain should not be your first choice due the amount of care that should be taken for correct use. Consider first whether the solution in the amortizing common test setup section or an ordinary test helper is sufficient for your needs.</paragraph><code language="javascript">// Good:
var db *sql.DB

func TestInsert(t *testing.T) { /* omitted */ }

func TestSelect(t *testing.T) { /* omitted */ }

func TestUpdate(t *testing.T) { /* omitted */ }

func TestDelete(t *testing.T) { /* omitted */ }

// runMain sets up the test dependencies and eventually executes the tests.
// It is defined as a separate function to enable the setup stages to clearly
// defer their teardown steps.
func runMain(ctx context.Context, m *testing.M) (code int, err error) {
    ctx, cancel := context.WithCancel(ctx)
    defer cancel()

    d, err := setupDatabase(ctx)
    if err != nil {
        return 0, err
    }
    defer d.Close() // Expressly clean up database.
    db = d          // db is defined as a package-level variable.

    // m.Run() executes the regular, user-defined test functions.
    // Any defer statements that have been made will be run after m.Run()
    // completes.
    return m.Run(), nil
}

func TestMain(m *testing.M) {
    code, err := runMain(context.Background(), m)
    if err != nil {
        // Failure messages should be written to STDERR, which log.Fatal uses.
        log.Fatal(err)
    }
    // NOTE: defer statements do not run past here due to os.Exit
    //       terminating the process.
    os.Exit(code)
}
</code><paragraph>Ideally a test case is hermetic between invocations of itself and between other test cases.</paragraph><paragraph>At the very least, ensure that individual test cases reset any global state they have modified if they have done so (for instance, if the tests are working with an external database).</paragraph><heading level="4">Amortizing common test setup</heading><paragraph>Using a sync.Once may be appropriate, though not required, if all of the following are true about the common setup:</paragraph><list type="ul"><item>It is expensive.</item><item>It only applies to some tests.</item><item>It does not require teardown.</item></list><code language="javascript">// Good:
var dataset struct {
    once sync.Once
    data []byte
    err  error
}

func mustLoadDataset(t *testing.T) []byte {
    t.Helper()
    dataset.once.Do(func() {
        data, err := os.ReadFile("path/to/your/project/testdata/dataset")
        // dataset is defined as a package-level variable.
        dataset.data = data
        dataset.err = err
    })
    if err := dataset.err; err != nil {
        t.Fatalf("Could not load dataset: %v", err)
    }
    return dataset.data
}
</code><paragraph>When mustLoadDataset is used in multiple test functions, its cost is amortized:</paragraph><code language="javascript">// Good:
func TestParseData(t *testing.T) {
    data := mustLoadDataset(t)

    // As documented above.
}

func TestListContents(t *testing.T) {
    data := mustLoadDataset(t)

    // As documented above.
}

func TestRegression682831(t *testing.T) {
    if got, want := guessOS("zpc79.example.com"), "grhat"; got != want {
        t.Errorf(`guessOS("zpc79.example.com") = %q, want %q`, got, want)
    }
}
</code><paragraph>The reason that common teardown is tricky is there is no uniform place to register cleanup routines. If the setup function (in this case loadDataset) relies on a context, sync.Once may be problematic. This is because the second of two racing calls to the setup function would need to wait for the first call to finish before returning. This period of waiting cannot be easily made to respect the context's cancellation.</paragraph><heading level="2">String concatenation</heading><paragraph>There are several ways to concatenate strings in Go. Some examples include:</paragraph><list type="ul"><item>The "+" operator</item><item>fmt.Sprintf</item><item>strings.Builder</item><item>text/template</item><item>safehtml/template</item></list><paragraph>Though there is no one-size-fits-all rule for which to choose, the following guidance outlines when each method is preferred.</paragraph><heading level="3">Prefer "+" for simple cases</heading><paragraph>Prefer using "+" when concatenating few strings. This method is syntactically the simplest and requires no import.</paragraph><code language="code">// Good:
key := "projectid: " + p
</code><heading level="3">Prefer fmt.Sprintf when formatting</heading><paragraph>Prefer using fmt.Sprintf when building a complex string with formatting. Using many "+" operators may obscure the end result.</paragraph><code language="code">// Good:
str := fmt.Sprintf("%s [%s:%d]-> %s", src, qos, mtu, dst)
</code><code language="code">// Bad:
bad := src.String() + " [" + qos.String() + ":" + strconv.Itoa(mtu) + "]-> " + dst.String()
</code><paragraph>Best Practice: When the output of the string-building operation is an io.Writer, don't construct a temporary string with fmt.Sprintf just to send it to the Writer. Instead, use fmt.Fprintf to emit to the Writer directly.</paragraph><paragraph>When the formatting is even more complex, prefer text/template or safehtml/template as appropriate.</paragraph><heading level="3">Prefer strings.Builder for constructing a string piecemeal</heading><paragraph>Prefer using strings.Builder when building a string bit-by-bit. strings.Builder takes amortized linear time, whereas "+" and fmt.Sprintf take quadratic time when called sequentially to form a larger string.</paragraph><code language="javascript">// Good:
b := new(strings.Builder)
for i, d := range digitsOfPi {
    fmt.Fprintf(b, "the %d digit of pi is: %d\n", i, d)
}
str := b.String()
</code><paragraph>Note: For more discussion, see GoTip #29: Building Strings Efficiently.</paragraph><heading level="3">Constant strings</heading><paragraph>Prefer to use backticks (`) when constructing constant, multi-line string literals.</paragraph><code language="code">// Good:
usage := `Usage:

custom_tool [args]`
</code><code language="code">// Bad:
usage := "" +
  "Usage:\n" +
  "\n" +
  "custom_tool [args]"
</code><heading level="2">Global state</heading><paragraph>Libraries should not force their clients to use APIs that rely on global state. They are advised not to expose APIs or export package level variables that control behavior for all clients as parts of their API. The rest of the section uses "global" and "package level state" synonymously.</paragraph><paragraph>Instead, if your functionality maintains state, allow your clients to create and use instance values.</paragraph><paragraph>Important: While this guidance is applicable to all developers, it is most critical for infrastructure providers who offer libraries, integrations, and services to other teams.</paragraph><code language="go">// Good:
// Package sidecar manages subprocesses that provide features for applications.
package sidecar

type Registry struct { plugins map[string]*Plugin }

func New() *Registry { return &Registry{plugins: make(map[string]*Plugin)} }

func (r *Registry) Register(name string, p *Plugin) error { ... }
</code><paragraph>Your users will instantiate the data they need (a *sidecar.Registry) and then pass it as an explicit dependency:</paragraph><code language="javascript">// Good:
package main

func main() {
  sidecars := sidecar.New()
  if err := sidecars.Register("Cloud Logger", cloudlogger.New()); err != nil {
    log.Exitf("Could not setup cloud logger: %v", err)
  }
  cfg := &myapp.Config{Sidecars: sidecars}
  myapp.Run(context.Background(), cfg)
}
</code><paragraph>There are different approaches to migrating existing code to support dependency passing. The main one you will use is passing dependencies as parameters to constructors, functions, methods, or struct fields on the call chain.</paragraph><paragraph>See also:</paragraph><paragraph>APIs that do not support explicit dependency passing become fragile as the number of clients increases:</paragraph><code language="javascript">// Bad:
package sidecar

var registry = make(map[string]*Plugin)

func Register(name string, p *Plugin) error { /* registers plugin in registry */ }
</code><paragraph>Consider what happens in the case of tests exercising code that transitively relies on a sidecar for cloud logging.</paragraph><code language="javascript">// Bad:
package app

import (
  "cloudlogger"
  "sidecar"
  "testing"
)

func TestEndToEnd(t *testing.T) {
  // The system under test (SUT) relies on a sidecar for a production cloud
  // logger already being registered.
  ... // Exercise SUT and check invariants.
}

func TestRegression_NetworkUnavailability(t *testing.T) {
  // We had an outage because of a network partition that rendered the cloud
  // logger inoperative, so we added a regression test to exercise the SUT with
  // a test double that simulates network unavailability with the logger.
  sidecar.Register("cloudlogger", cloudloggertest.UnavailableLogger)
  ... // Exercise SUT and check invariants.
}

func TestRegression_InvalidUser(t *testing.T) {
  // The system under test (SUT) relies on a sidecar for a production cloud
  // logger already being registered.
  //
  // Oops. cloudloggertest.UnavailableLogger is still registered from the
  // previous test.
  ... // Exercise SUT and check invariants.
}
</code><paragraph>Go tests are executed sequentially by default, so the tests above run as:</paragraph><list type="ol"><item>TestEndToEnd</item><item>TestRegression_NetworkUnavailability, which overrides the default value of cloudlogger</item><item>TestRegression_InvalidUser, which requires the default value of cloudlogger registered in package sidecar</item></list><paragraph>This creates an order-dependent test case, which breaks running with test filters, and prevents tests from running in parallel or being sharded.</paragraph><paragraph>Using global state poses problems that lack easy answers for you and the API's clients:</paragraph><list type="ul"><item>What happens if a client needs to use different and separately operating sets of Plugins (for example, to support multiple servers) in the same process space?</item><item>What happens if a client wants to replace a registered Plugin with an alternative implementation in a test, like a test double? What happens if a client's tests require hermeticity between instances of a Plugin, or between all of the plugins registered?</item><item>What happens if multiple clients Register a Plugin under the same name? Which one wins, if any? How should errors be handled? If the code panics or calls log.Fatal, will that always be appropriate for all places in which API would be called? Can a client verify it doesn't do something bad before doing so?</item><item>Are there certain stages in a program's startup phases or lifetime during which Register can be called and when it can't? What happens if Register is called at the wrong time? A client could call Register in func init, before flags are parsed, or after main. The stage at which a function is called affects error handling. If the author of an API assumes the API is only called during program initialization without the requirement that it is, the assumption may nudge the author to design error handling to abort the program by modeling the API as a Must-like function. Aborting is not appropriate for general-purpose library functions that can be used at any stage.</item><item>What if the client's and the designer's concurrency needs are mismatched?</item></list><paragraph>What happens if a client needs to use different and separately operating sets of Plugins (for example, to support multiple servers) in the same process space?</paragraph><paragraph>What happens if a client wants to replace a registered Plugin with an alternative implementation in a test, like a test double?</paragraph><paragraph>What happens if a client's tests require hermeticity between instances of a Plugin, or between all of the plugins registered?</paragraph><paragraph>What happens if multiple clients Register a Plugin under the same name? Which one wins, if any?</paragraph><paragraph>How should errors be handled? If the code panics or calls log.Fatal, will that always be appropriate for all places in which API would be called? Can a client verify it doesn't do something bad before doing so?</paragraph><paragraph>Are there certain stages in a program's startup phases or lifetime during which Register can be called and when it can't?</paragraph><paragraph>What happens if Register is called at the wrong time? A client could call Register in func init, before flags are parsed, or after main. The stage at which a function is called affects error handling. If the author of an API assumes the API is only called during program initialization without the requirement that it is, the assumption may nudge the author to design error handling to abort the program by modeling the API as a Must-like function. Aborting is not appropriate for general-purpose library functions that can be used at any stage.</paragraph><paragraph>What if the client's and the designer's concurrency needs are mismatched?</paragraph><paragraph>See also:</paragraph><paragraph>Global state has cascading effects on the health of the Google codebase. Global state should be approached with extreme scrutiny.</paragraph><paragraph>Global state comes in several forms, and you can use a few litmus tests to identify when it is safe.</paragraph><heading level="3">Major forms of package state APIs</heading><paragraph>Several of the most common problematic API forms are enumerated below:</paragraph><list type="ul"><item>Top-level variables irrespective of whether they are exported. // Bad: package logger // Sinks manages the default output sources for this package's logging API. This // variable should be set at package initialization time and never thereafter. var Sinks []Sink See the litmus tests to know when these are safe.</item><item>The service locator pattern. See the first example. The service locator pattern itself is not problematic, rather the locator being defined as global.</item><item>Registries for callbacks and similar behaviors. // Bad: package health var unhealthyFuncs []func func OnUnhealthy(f func()) { unhealthyFuncs = append(unhealthyFuncs, f) }</item><item>Thick-Client singletons for things like backends, storage, data access layers, and other system resources. These often pose additional problems with service reliability. // Bad: package useradmin var client pb.UserAdminServiceClientInterface func Client() *pb.UserAdminServiceClient { if client == nil { client = ... // Set up client. } return client }</item></list><paragraph>Top-level variables irrespective of whether they are exported.</paragraph><code language="javascript">// Bad:
package logger

// Sinks manages the default output sources for this package's logging API.  This
// variable should be set at package initialization time and never thereafter.
var Sinks []Sink
</code><paragraph>See the litmus tests to know when these are safe.</paragraph><paragraph>The service locator pattern. See the first example. The service locator pattern itself is not problematic, rather the locator being defined as global.</paragraph><paragraph>Registries for callbacks and similar behaviors.</paragraph><code language="javascript">// Bad:
package health

var unhealthyFuncs []func

func OnUnhealthy(f func()) {
  unhealthyFuncs = append(unhealthyFuncs, f)
}
</code><paragraph>Thick-Client singletons for things like backends, storage, data access layers, and other system resources. These often pose additional problems with service reliability.</paragraph><code language="javascript">// Bad:
package useradmin

var client pb.UserAdminServiceClientInterface

func Client() *pb.UserAdminServiceClient {
    if client == nil {
        client = ...  // Set up client.
    }
    return client
}
</code><paragraph>Note: Many legacy APIs in the Google codebase do not follow this guidance; in fact, some Go standard libraries allow for configuration via global values. Nevertheless, the legacy API's contravention of this guidance should not be used as precedent for continuing the pattern.</paragraph><paragraph>It is better to invest in proper API design today than pay for redesigning later.</paragraph><heading level="3">Litmus tests</heading><paragraph>APIs using the patterns above are unsafe when:</paragraph><list type="ul"><item>Multiple functions interact via global state when executed in the same program, despite being otherwise independent (for example, authored by different authors in vastly different directories).</item><item>Independent test cases interact with each other through global state.</item><item>Users of the API are tempted to swap or replace global state for testing purposes, particularly to replace any part of the state with a test double, like a stub, fake, spy, or mock.</item><item>Users have to consider special ordering requirements when interacting with global state: func init, whether flags are parsed yet, etc.</item></list><paragraph>Provided the conditions above are avoided, there are a few limited circumstances under which these APIs are safe, namely when any of the following is true:</paragraph><list type="ul"><item>The global state is logically constant (example).</item><item>The package's observable behavior is stateless. For example, a public function may use a private global variable as a cache, but so long as the caller can't distinguish cache hits from misses, the function is stateless.</item><item>The global state does not bleed into things that are external to the program, like sidecar processes or files on a shared filesystem.</item><item>There is no expectation of predictable behavior (example).</item></list><paragraph>Note: Sidecar processes may not strictly be process-local. They can and often are shared with more than one application process. Moreover, these sidecars often interact with external distributed systems.</paragraph><paragraph>Further, the same stateless, idempotent, and local rules in addition to the base considerations above would apply to the code of the sidecar process itself!</paragraph><paragraph>An example of one of these safe situations is package image with its image.RegisterFormat function. Consider the litmus tests from above applied to a typical decoder, like the one for handling the PNG format:</paragraph><list type="ul"><item>Multiple calls to package image's APIs that use the registered decoders (for example, image.Decode) cannot interfere with one another, similarly for tests. The only exception is image.RegisterFormat, but that is mitigated by the points below.</item><item>It is extremely unlikely that a user would want to replace a decoder with a test double, as the PNG decoder exemplifies a case in which our codebase's preference for real objects applies. However, a user would be more likely to replace a decoder with a test double if the decoder statefully interacted with operating system resources (for example, the network).</item><item>Collisions in registration are conceivable, though they are probably rare in practice.</item><item>The decoders are stateless, idempotent, and pure.</item></list><heading level="3">Providing a default instance</heading><paragraph>While not recommended, it is acceptable to provide a simplified API that uses package level state if you need to maximize convenience for the user.</paragraph><paragraph>Follow the litmus tests with these guidelines in such cases:</paragraph><list type="ol"><item>The package must offer clients the ability to create isolated instances of package types as described above.</item><item>The public APIs that use global state must be a thin proxy to the previous API. A good example of this is http.Handle internally calling (*http.ServeMux).Handle on the package variable http.DefaultServeMux.</item><item>This package-level API must only be used by binary build targets, not libraries, unless the libraries are undertaking a refactoring to support dependency passing. Infrastructure libraries that can be imported by other packages must not rely on package-level state of the packages they import. For example, an infrastructure provider implementing a sidecar that is to be shared with other teams using the API from the top should offer an API to accommodate this: // Good: package cloudlogger func New() *Logger { ... } func Register(r *sidecar.Registry, l *Logger) { r.Register("Cloud Logging", l) }</item><item>This package-level API must document and enforce its invariants (for example, at which stage in the program's life it can be called, whether it can be used concurrently). Further, it must provide an API to reset global state to a known-good default (for example, to facilitate testing).</item></list><paragraph>This package-level API must only be used by binary build targets, not libraries, unless the libraries are undertaking a refactoring to support dependency passing. Infrastructure libraries that can be imported by other packages must not rely on package-level state of the packages they import.</paragraph><paragraph>For example, an infrastructure provider implementing a sidecar that is to be shared with other teams using the API from the top should offer an API to accommodate this:</paragraph><code language="javascript">// Good:
package cloudlogger

func New() *Logger { ... }

func Register(r *sidecar.Registry, l *Logger) {
  r.Register("Cloud Logging", l)
}
</code><paragraph>See also:</paragraph></content>
</page>
<page url="https://google.github.io/styleguide/cppguide.html">
<title>Google C++ Style Guide</title>
<content><heading level="1">Google C++ Style Guide</heading><heading level="2">Background</heading><paragraph>C++ is one of the main development languages used by many of Google's open-source projects. As every C++ programmer knows, the language has many powerful features, but this power brings with it complexity, which in turn can make code more bug-prone and harder to read and maintain.</paragraph><paragraph>The goal of this guide is to manage this complexity by describing in detail the dos and don'ts of writing C++ code. These rules exist to keep the codebase manageable while still allowing coders to use C++ language features productively.</paragraph><paragraph>Style, also known as readability, is what we call the conventions that govern our C++ code. The term Style is a bit of a misnomer, since these conventions cover far more than just source file formatting.</paragraph><paragraph>Most open-source projects developed by Google conform to the requirements in this guide.</paragraph><paragraph>Note that this guide is not a C++ tutorial: we assume that the reader is familiar with the language.</paragraph><heading level="3">Goals of the Style Guide</heading><paragraph>Why do we have this document?</paragraph><paragraph>There are a few core goals that we believe this guide should serve. These are the fundamental whys that underlie all of the individual rules. By bringing these ideas to the fore, we hope to ground discussions and make it clearer to our broader community why the rules are in place and why particular decisions have been made. If you understand what goals each rule is serving, it should be clearer to everyone when a rule may be waived (some can be), and what sort of argument or alternative would be necessary to change a rule in the guide.</paragraph><paragraph>The goals of the style guide as we currently see them are as follows:</paragraph><paragraph>The intent of this document is to provide maximal guidance with reasonable restriction. As always, common sense and good taste should prevail. By this we specifically refer to the established conventions of the entire Google C++ community, not just your personal preferences or those of your team. Be skeptical about and reluctant to use clever or unusual constructs: the absence of a prohibition is not the same as a license to proceed. Use your judgment, and if you are unsure, please don't hesitate to ask your project leads to get additional input.</paragraph><heading level="2">C++ Version</heading><paragraph>Currently, code should target C++20, i.e., should not use C++23 features. The C++ version targeted by this guide will advance (aggressively) over time.</paragraph><paragraph>Do not use non-standard extensions.</paragraph><paragraph>Consider portability to other environments before using features from C++17 and C++20 in your project.</paragraph><paragraph>In general, every .cc file should have an associated .h file. There are some common exceptions, such as unit tests and small .cc files containing just a main() function.</paragraph><paragraph>Correct use of header files can make a huge difference to the readability, size and performance of your code.</paragraph><paragraph>The following rules will guide you through the various pitfalls of using header files.</paragraph><paragraph>Header files should be self-contained (compile on their own) and end in .h. Non-header files that are meant for inclusion should end in .inc and be used sparingly.</paragraph><paragraph>All header files should be self-contained. Users and refactoring tools should not have to adhere to special conditions to include the header. Specifically, a header should have header guards and include all other headers it needs.</paragraph><paragraph>When a header declares inline functions or templates that clients of the header will instantiate, the inline functions and templates must also have definitions in the header, either directly or in files it includes. Do not move these definitions to separately included header (-inl.h) files; this practice was common in the past, but is no longer allowed. When all instantiations of a template occur in one .cc file, either because they're explicit or because the definition is accessible to only the .cc file, the template definition can be kept in that file.</paragraph><paragraph>There are rare cases where a file designed to be included is not self-contained. These are typically intended to be included at unusual locations, such as the middle of another file. They might not use header guards, and might not include their prerequisites. Name such files with the .inc extension. Use sparingly, and prefer self-contained headers when possible.</paragraph><heading level="3">The #define Guard</heading><paragraph>All header files should have #define guards to prevent multiple inclusion. The format of the symbol name should be <PROJECT>_<PATH>_<FILE>_H_.</paragraph><paragraph>To guarantee uniqueness, they should be based on the full path in a project's source tree. For example, the file foo/src/bar/baz.h in project foo should have the following guard:</paragraph><code language="code">#ifndef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_

...

#endif  // FOO_BAR_BAZ_H_
</code><heading level="3">Include What You Use</heading><paragraph>If a source or header file refers to a symbol defined elsewhere, the file should directly include a header file which properly intends to provide a declaration or definition of that symbol. It should not include header files for any other reason.</paragraph><paragraph>Do not rely on transitive inclusions. This allows people to remove no-longer-needed #include statements from their headers without breaking clients. This also applies to related headers - foo.cc should include bar.h if it uses a symbol from it even if foo.h includes bar.h.</paragraph><heading level="3">Forward Declarations</heading><paragraph>Avoid using forward declarations where possible. Instead, include the headers you need.</paragraph><paragraph>A "forward declaration" is a declaration of an entity without an associated definition.</paragraph><code language="code">// In a C++ source file:
class B;
void FuncInB();
extern int variable_in_b;
ABSL_DECLARE_FLAG(flag_in_b);
</code><list type="ul"><item>Forward declarations can save compile time, as #includes force the compiler to open more files and process more input.</item><item>Forward declarations can save on unnecessary recompilation. #includes can force your code to be recompiled more often, due to unrelated changes in the header.</item></list><paragraph>Try to avoid forward declarations of entities defined in another project.</paragraph><paragraph>Include the definition of a function at its point of declaration in a header file only when the definition is short. If the definition otherwise has a reason be in the header, put it in an internal part of the file. If necessary to make the definition ODR-safe, mark it with an inline specifier.</paragraph><paragraph>Functions defined in header files are sometimes referred to as "inline functions", which is a somewhat overloaded term that refers to several distinct but overlapping situations:</paragraph><list type="ol"><item>A textually inline symbol's definition is exposed to the reader at the point of declaration.</item><item>A function or variable defined in a header file is expandable inline since its definition is available for inline expansion by the compiler, which can lead to more efficient object code.</item><item>ODR-safe entities do not violate the "One Definition Rule", which often requires the inline keyword for things defined in header files .</item></list><paragraph>While functions tend to be a more common source of confusion, these definitions apply to variables as well, and so do the rules here.</paragraph><list type="ul"><item>Defining a function textually in-line reduces boilerplate code for simple functions like accessors and mutators.</item><item>As noted above, function definitions in header files can lead to more efficient object code for small functions due to inline expansion by the compiler.</item><item>Function templates and constexpr functions generally need to be defined in the header file that declares them (but not necessarily the public part).</item></list><list type="ul"><item>Embedding a function definition in the public API makes the API harder to skim, and incurs cognitive overhead for readers of that API- the more complex the function the higher the cost.</item><item>Public definitions expose implementation details that are at best harmless and often extraneous.</item></list><paragraph>Only define a function at its public declaration if it is short, say, 10 lines or fewer. Put longer function bodies in the .cc file unless they must be in the header for performance or technical reasons.</paragraph><paragraph>Even if a definition must be in the header, this is not a sufficient reason to put it within the public part. Instead, the definition can be in an internal part of the header, such as the private section of a class, within a namespace that includes the word internal, or below a comment like // Implementation details only below here.</paragraph><paragraph>Once a definition is in a header file, it must be ODR-safe by having the inline specifier or being implicitly specified inline by being a function template or defined in a class body when first declared.</paragraph><code language="javascript">template <typename T>
class Foo {
 public:
  int bar() { return bar_; }

  void MethodWithHugeBody();

 private:
  int bar_;
};

// Implementation details only below here

template <typename T>
void Foo<T>::MethodWithHugeBody() {
  ...
}
</code><heading level="3">Names and Order of Includes</heading><paragraph>Include headers in the following order: Related header, C system headers, C++ standard library headers, other libraries' headers, your project's headers.</paragraph><paragraph>All of a project's header files should be listed as descendants of the project's source directory without use of UNIX directory aliases . (the current directory) or .. (the parent directory). For example, google-awesome-project/src/base/logging.h should be included as:</paragraph><code language="cpp">#include "base/logging.h"
</code><paragraph>Headers should only be included using an angle-bracketed path if the library requires you to do so. In particular, the following headers require angle brackets:</paragraph><list type="ul"><item>C and C++ standard library headers (e.g., <stdlib.h> and <string>).</item><item>POSIX, Linux, and Windows system headers (e.g., <unistd.h> and <windows.h>).</item><item>In rare cases, third_party libraries (e.g., <Python.h>).</item></list><paragraph>In dir/foo.cc or dir/foo_test.cc, whose main purpose is to implement or test the stuff in dir2/foo2.h, order your includes as follows:</paragraph><list type="ol"><item>dir2/foo2.h.</item><item>A blank line</item><item>C system headers, and any other headers in angle brackets with the .h extension, e.g., <unistd.h>, <stdlib.h>, <Python.h>.</item><item>A blank line</item><item>C++ standard library headers (without file extension), e.g., <algorithm>, <cstddef>.</item><item>A blank line</item><item>Other libraries' .h files.</item><item>A blank line</item><item>Your project's .h files.</item></list><paragraph>Separate each non-empty group with one blank line.</paragraph><paragraph>With the preferred ordering, if the related header dir2/foo2.h omits any necessary includes, the build of dir/foo.cc or dir/foo_test.cc will break. Thus, this rule ensures that build breaks show up first for the people working on these files, not for innocent people in other packages.</paragraph><paragraph>dir/foo.cc and dir2/foo2.h are usually in the same directory (e.g., base/basictypes_test.cc and base/basictypes.h), but may sometimes be in different directories too.</paragraph><paragraph>Note that the C headers such as stddef.h are essentially interchangeable with their C++ counterparts (cstddef). Either style is acceptable, but prefer consistency with existing code.</paragraph><paragraph>Within each section the includes should be ordered alphabetically. Note that older code might not conform to this rule and should be fixed when convenient.</paragraph><paragraph>For example, the includes in google-awesome-project/src/foo/internal/fooserver.cc might look like this:</paragraph><code language="cpp">#include "foo/server/fooserver.h"

#include <sys/types.h>
#include <unistd.h>

#include <string>
#include <vector>

#include "base/basictypes.h"
#include "foo/server/bar.h"
#include "third_party/absl/flags/flag.h"
</code><paragraph>Exception:</paragraph><paragraph>Sometimes, system-specific code needs conditional includes. Such code can put conditional includes after other includes. Of course, keep your system-specific code small and localized. Example:</paragraph><code language="cpp">#include "foo/public/fooserver.h"

#ifdef _WIN32
#include <windows.h>
#endif  // _WIN32
</code><heading level="2">Scoping</heading><heading level="3">Namespaces</heading><paragraph>With few exceptions, place code in a namespace. Namespaces should have unique names based on the project name, and possibly its path. Do not use using-directives (e.g., using namespace foo). Do not use inline namespaces. For unnamed namespaces, see Internal Linkage.</paragraph><paragraph>Namespaces subdivide the global scope into distinct, named scopes, and so are useful for preventing name collisions in the global scope.</paragraph><paragraph>Namespaces provide a method for preventing name conflicts in large programs while allowing most code to use reasonably short names.</paragraph><paragraph>For example, if two different projects have a class Foo in the global scope, these symbols may collide at compile time or at runtime. If each project places their code in a namespace, project1::Foo and project2::Foo are now distinct symbols that do not collide, and code within each project's namespace can continue to refer to Foo without the prefix.</paragraph><paragraph>Inline namespaces automatically place their names in the enclosing scope. Consider the following snippet, for example:</paragraph><code language="javascript">namespace outer {
inline namespace inner {
  void foo();
}  // namespace inner
}  // namespace outer
</code><paragraph>The expressions outer::inner::foo() and outer::foo() are interchangeable. Inline namespaces are primarily intended for ABI compatibility across versions.</paragraph><paragraph>Namespaces can be confusing, because they complicate the mechanics of figuring out what definition a name refers to.</paragraph><paragraph>Inline namespaces, in particular, can be confusing because names aren't actually restricted to the namespace where they are declared. They are only useful as part of some larger versioning policy.</paragraph><paragraph>In some contexts, it's necessary to repeatedly refer to symbols by their fully-qualified names. For deeply-nested namespaces, this can add a lot of clutter.</paragraph><paragraph>Namespaces should be used as follows:</paragraph><list type="ul"><item>Follow the rules on Namespace Names.</item><item>Terminate multi-line namespaces with comments as shown in the given examples.</item><item>Namespaces wrap the entire source file after includes, gflags definitions/declarations and forward declarations of classes from other namespaces. // In the .h file namespace mynamespace { // All declarations are within the namespace scope. // Notice the lack of indentation. class MyClass { public: ... void Foo(); }; } // namespace mynamespace // In the .cc file namespace mynamespace { // Definition of functions is within scope of the namespace. void MyClass::Foo() { ... } } // namespace mynamespace More complex .cc files might have additional details, like flags or using-declarations. #include "a.h" ABSL_FLAG(bool, someflag, false, "a flag"); namespace mynamespace { using ::foo::Bar; ...code for mynamespace... // Code goes against the left margin. } // namespace mynamespace</item><item>To place generated protocol message code in a namespace, use the package specifier in the .proto file. See Protocol Buffer Packages for details.</item><item>Do not declare anything in namespace std, including forward declarations of standard library classes. Declaring entities in namespace std is undefined behavior, i.e., not portable. To declare entities from the standard library, include the appropriate header file.</item><item>You may not use a using-directive to make all names from a namespace available. // Forbidden -- This pollutes the namespace. using namespace foo;</item><item>Do not use Namespace aliases at namespace scope in header files except in explicitly marked internal-only namespaces, because anything imported into a namespace in a header file becomes part of the public API exported by that file. Namespace aliases can be used when those conditions don't apply, but they must have appropriate names. // In a .h file, an alias must not be a separate API, or must be hidden in an // implementation detail. namespace librarian { namespace internal { // Internal, not part of the API. namespace sidetable = ::pipeline_diagnostics::sidetable; } // namespace internal inline void my_inline_function() { // Local to a function. namespace baz = ::foo::bar::baz; ... } } // namespace librarian // Remove uninteresting parts of some commonly used names in .cc files. namespace sidetable = ::pipeline_diagnostics::sidetable;</item><item>Do not use inline namespaces.</item><item>Use namespaces with "internal" in the name to document parts of an API that should not be mentioned by users of the API. // We shouldn't use this internal name in non-absl code. using ::absl::container_internal::ImplementationDetail; Note that there is still a risk of collision between libraries within a nested internal namespace, so give each library within a namespace a unique internal namespace by adding the library's filename. For example, gshoe/widget.h would use gshoe::internal_widget as opposed to just gshoe::internal.</item><item>Single-line nested namespace declarations are preferred in new code, but are not required.</item></list><paragraph>Namespaces wrap the entire source file after includes, gflags definitions/declarations and forward declarations of classes from other namespaces.</paragraph><code language="javascript">// In the .h file
namespace mynamespace {

// All declarations are within the namespace scope.
// Notice the lack of indentation.
class MyClass {
 public:
  ...
  void Foo();
};

}  // namespace mynamespace
</code><code language="javascript">// In the .cc file
namespace mynamespace {

// Definition of functions is within scope of the namespace.
void MyClass::Foo() {
  ...
}

}  // namespace mynamespace
</code><paragraph>More complex .cc files might have additional details, like flags or using-declarations.</paragraph><code language="javascript">#include "a.h"

ABSL_FLAG(bool, someflag, false, "a flag");

namespace mynamespace {

using ::foo::Bar;

...code for mynamespace...    // Code goes against the left margin.

}  // namespace mynamespace
</code><paragraph>You may not use a using-directive to make all names from a namespace available.</paragraph><code language="cpp">// Forbidden -- This pollutes the namespace.
using namespace foo;
</code><paragraph>Do not use Namespace aliases at namespace scope in header files except in explicitly marked internal-only namespaces, because anything imported into a namespace in a header file becomes part of the public API exported by that file. Namespace aliases can be used when those conditions don't apply, but they must have appropriate names.</paragraph><code language="javascript">// In a .h file, an alias must not be a separate API, or must be hidden in an
// implementation detail.
namespace librarian {

namespace internal {  // Internal, not part of the API.
namespace sidetable = ::pipeline_diagnostics::sidetable;
}  // namespace internal

inline void my_inline_function() {
  // Local to a function.
  namespace baz = ::foo::bar::baz;
  ...
}

}  // namespace librarian
</code><code language="code">// Remove uninteresting parts of some commonly used names in .cc files.
namespace sidetable = ::pipeline_diagnostics::sidetable;
</code><paragraph>Use namespaces with "internal" in the name to document parts of an API that should not be mentioned by users of the API.</paragraph><code language="code">// We shouldn't use this internal name in non-absl code.
using ::absl::container_internal::ImplementationDetail;
</code><paragraph>Note that there is still a risk of collision between libraries within a nested internal namespace, so give each library within a namespace a unique internal namespace by adding the library's filename. For example, gshoe/widget.h would use gshoe::internal_widget as opposed to just gshoe::internal.</paragraph><paragraph>Single-line nested namespace declarations are preferred in new code, but are not required.</paragraph><heading level="3">Internal Linkage</heading><paragraph>When definitions in a .cc file do not need to be referenced outside that file, give them internal linkage by placing them in an unnamed namespace or declaring them static. Do not use either of these constructs in .h files.</paragraph><paragraph>All declarations can be given internal linkage by placing them in unnamed namespaces. Functions and variables can also be given internal linkage by declaring them static. This means that anything you're declaring can't be accessed from another file. If a different file declares something with the same name, then the two entities are completely independent.</paragraph><paragraph>Use of internal linkage in .cc files is encouraged for all code that does not need to be referenced elsewhere. Do not use internal linkage in .h files.</paragraph><paragraph>Format unnamed namespaces like named namespaces. In the terminating comment, leave the namespace name empty:</paragraph><code language="javascript">namespace {
...
}  // namespace
</code><heading level="3">Nonmember, Static Member, and Global Functions</heading><paragraph>Prefer placing nonmember functions in a namespace; use completely global functions rarely. Do not use a class simply to group static members. Static methods of a class should generally be closely related to instances of the class or the class's static data.</paragraph><paragraph>Nonmember and static member functions can be useful in some situations. Putting nonmember functions in a namespace avoids polluting the global namespace.</paragraph><paragraph>Nonmember and static member functions may make more sense as members of a new class, especially if they access external resources or have significant dependencies.</paragraph><paragraph>Sometimes it is useful to define a function not bound to a class instance. Such a function can be either a static member or a nonmember function. Nonmember functions should not depend on external variables, and should nearly always exist in a namespace. Do not create classes only to group static members; this is no different than just giving the names a common prefix, and such grouping is usually unnecessary anyway.</paragraph><paragraph>If you define a nonmember function and it is only needed in its .cc file, use internal linkage to limit its scope.</paragraph><heading level="3">Local Variables</heading><paragraph>Place a function's variables in the narrowest scope possible, and initialize variables in the declaration.</paragraph><paragraph>C++ allows you to declare variables anywhere in a function. We encourage you to declare them in a scope as local as possible, and as close to the first use as possible. This makes it easier for the reader to find the declaration and see what type the variable is and what it was initialized to. In particular, initialization should be used instead of declaration and assignment, e.g.,:</paragraph><code language="code">int i;
i = f();      // Bad -- initialization separate from declaration.
</code><code language="code">int i = f();  // Good -- declaration has initialization.
</code><code language="code">int jobs = NumJobs();
// More code...
f(jobs);      // Bad -- declaration separate from use.
</code><code language="code">int jobs = NumJobs();
f(jobs);      // Good -- declaration immediately (or closely) followed by use.
</code><code language="code">std::vector<int> v;
v.push_back(1);  // Prefer initializing using brace initialization.
v.push_back(2);
</code><code language="code">std::vector<int> v = {1, 2};  // Good -- v starts initialized.
</code><paragraph>Variables needed for if, while and for statements should normally be declared within those statements, so that such variables are confined to those scopes. For example:</paragraph><code language="code">while (const char* p = strchr(str, '/')) str = p + 1;
</code><paragraph>There is one caveat: if the variable is an object, its constructor is invoked every time it enters scope and is created, and its destructor is invoked every time it goes out of scope.</paragraph><code language="javascript">// Inefficient implementation:
for (int i = 0; i < 1000000; ++i) {
  Foo f;  // My ctor and dtor get called 1000000 times each.
  f.DoSomething(i);
}
</code><paragraph>It may be more efficient to declare such a variable used in a loop outside that loop:</paragraph><code language="javascript">Foo f;  // My ctor and dtor get called once each.
for (int i = 0; i < 1000000; ++i) {
  f.DoSomething(i);
}
</code><heading level="3">Static and Global Variables</heading><paragraph>Objects with static storage duration are forbidden unless they are trivially destructible. Informally this means that the destructor does not do anything, even taking member and base destructors into account. More formally it means that the type has no user-defined or virtual destructor and that all bases and non-static members are trivially destructible. Static function-local variables may use dynamic initialization. Use of dynamic initialization for static class member variables or variables at namespace scope is discouraged, but allowed in limited circumstances; see below for details.</paragraph><paragraph>As a rule of thumb: a global variable satisfies these requirements if its declaration, considered in isolation, could be constexpr.</paragraph><paragraph>Every object has a storage duration, which correlates with its lifetime. Objects with static storage duration live from the point of their initialization until the end of the program. Such objects appear as variables at namespace scope ("global variables"), as static data members of classes, or as function-local variables that are declared with the static specifier. Function-local static variables are initialized when control first passes through their declaration; all other objects with static storage duration are initialized as part of program start-up. All objects with static storage duration are destroyed at program exit (which happens before unjoined threads are terminated).</paragraph><paragraph>Initialization may be dynamic, which means that something non-trivial happens during initialization. (For example, consider a constructor that allocates memory, or a variable that is initialized with the current process ID.) The other kind of initialization is static initialization. The two aren't quite opposites, though: static initialization always happens to objects with static storage duration (initializing the object either to a given constant or to a representation consisting of all bytes set to zero), whereas dynamic initialization happens after that, if required.</paragraph><paragraph>Global and static variables are very useful for a large number of applications: named constants, auxiliary data structures internal to some translation unit, command-line flags, logging, registration mechanisms, background infrastructure, etc.</paragraph><paragraph>Global and static variables that use dynamic initialization or have non-trivial destructors create complexity that can easily lead to hard-to-find bugs. Dynamic initialization is not ordered across translation units, and neither is destruction (except that destruction happens in reverse order of initialization). When one initialization refers to another variable with static storage duration, it is possible that this causes an object to be accessed before its lifetime has begun (or after its lifetime has ended). Moreover, when a program starts threads that are not joined at exit, those threads may attempt to access objects after their lifetime has ended if their destructor has already run.</paragraph><heading level="4">Decision on destruction</heading><paragraph>When destructors are trivial, their execution is not subject to ordering at all (they are effectively not "run"); otherwise we are exposed to the risk of accessing objects after the end of their lifetime. Therefore, we only allow objects with static storage duration if they are trivially destructible. Fundamental types (like pointers and int) are trivially destructible, as are arrays of trivially destructible types. Note that variables marked with constexpr are trivially destructible.</paragraph><code language="javascript">const int kNum = 10;  // Allowed

struct X { int n; };
const X kX[] = {{1}, {2}, {3}};  // Allowed

void foo() {
  static const char* const kMessages[] = {"hello", "world"};  // Allowed
}

// Allowed: constexpr guarantees trivial destructor.
constexpr std::array<int, 3> kArray = {1, 2, 3};</code><code language="javascript">// bad: non-trivial destructor
const std::string kFoo = "foo";

// Bad for the same reason, even though kBar is a reference (the
// rule also applies to lifetime-extended temporary objects).
const std::string& kBar = StrCat("a", "b", "c");

void bar() {
  // Bad: non-trivial destructor.
  static std::map<int, int> kData = {{1, 0}, {2, 0}, {3, 0}};
}</code><paragraph>Note that references are not objects, and thus they are not subject to the constraints on destructibility. The constraint on dynamic initialization still applies, though. In particular, a function-local static reference of the form static T& t = *new T; is allowed.</paragraph><heading level="4">Decision on initialization</heading><paragraph>Initialization is a more complex topic. This is because we must not only consider whether class constructors execute, but we must also consider the evaluation of the initializer:</paragraph><code language="code">int n = 5;    // Fine
int m = f();  // ? (Depends on f)
Foo x;        // ? (Depends on Foo::Foo)
Bar y = g();  // ? (Depends on g and on Bar::Bar)
</code><paragraph>All but the first statement expose us to indeterminate initialization ordering.</paragraph><paragraph>The concept we are looking for is called constant initialization in the formal language of the C++ standard. It means that the initializing expression is a constant expression, and if the object is initialized by a constructor call, then the constructor must be specified as constexpr, too:</paragraph><code language="code">struct Foo { constexpr Foo(int) {} };

int n = 5;  // Fine, 5 is a constant expression.
Foo x(2);   // Fine, 2 is a constant expression and the chosen constructor is constexpr.
Foo a[] = { Foo(1), Foo(2), Foo(3) };  // Fine</code><paragraph>Constant initialization is always allowed. Constant initialization of static storage duration variables should be marked with constexpr or constinit. Any non-local static storage duration variable that is not so marked should be presumed to have dynamic initialization, and reviewed very carefully.</paragraph><paragraph>By contrast, the following initializations are problematic:</paragraph><code language="code">// Some declarations used below.
time_t time(time_t*);      // Not constexpr!
int f();                   // Not constexpr!
struct Bar { Bar() {} };

// Problematic initializations.
time_t m = time(nullptr);  // Initializing expression not a constant expression.
Foo y(f());                // Ditto
Bar b;                     // Chosen constructor Bar::Bar() not constexpr.</code><paragraph>Dynamic initialization of nonlocal variables is discouraged, and in general it is forbidden. However, we do permit it if no aspect of the program depends on the sequencing of this initialization with respect to all other initializations. Under those restrictions, the ordering of the initialization does not make an observable difference. For example:</paragraph><code language="code">int p = getpid();  // Allowed, as long as no other static variable
                   // uses p in its own initialization.</code><paragraph>Dynamic initialization of static local variables is allowed (and common).</paragraph><heading level="4">Common patterns</heading><list type="ul"><item>Global strings: if you require a named global or static string constant, consider using a constexpr variable of string_view, character array, or character pointer, pointing to a string literal. String literals have static storage duration already and are usually sufficient. See TotW #140.</item><item>Maps, sets, and other dynamic containers: if you require a static, fixed collection, such as a set to search against or a lookup table, you cannot use the dynamic containers from the standard library as a static variable, since they have non-trivial destructors. Instead, consider a simple array of trivial types, e.g., an array of arrays of ints (for a "map from int to int"), or an array of pairs (e.g., pairs of int and const char*). For small collections, linear search is entirely sufficient (and efficient, due to memory locality); consider using the facilities from absl/algorithm/container.h for the standard operations. If necessary, keep the collection in sorted order and use a binary search algorithm. If you do really prefer a dynamic container from the standard library, consider using a function-local static pointer, as described below .</item><item>Smart pointers (std::unique_ptr, std::shared_ptr): smart pointers execute cleanup during destruction and are therefore forbidden. Consider whether your use case fits into one of the other patterns described in this section. One simple solution is to use a plain pointer to a dynamically allocated object and never delete it (see last item).</item><item>Static variables of custom types: if you require static, constant data of a type that you need to define yourself, give the type a trivial destructor and a constexpr constructor.</item><item>If all else fails, you can create an object dynamically and never delete it by using a function-local static pointer or reference (e.g., static const auto& impl = *new T(args...);).</item></list><heading level="3">thread_local Variables</heading><paragraph>thread_local variables that aren't declared inside a function must be initialized with a true compile-time constant, and this must be enforced by using the constinit attribute. Prefer thread_local over other ways of defining thread-local data.</paragraph><paragraph>Variables can be declared with the thread_local specifier:</paragraph><code language="code">thread_local Foo foo = ...;
</code><paragraph>Such a variable is actually a collection of objects, so that when different threads access it, they are actually accessing different objects. thread_local variables are much like static storage duration variables in many respects. For instance, they can be declared at namespace scope, inside functions, or as static class members, but not as ordinary class members.</paragraph><paragraph>thread_local variable instances are initialized much like static variables, except that they must be initialized separately for each thread, rather than once at program startup. This means that thread_local variables declared within a function are safe, but other thread_local variables are subject to the same initialization-order issues as static variables (and more besides).</paragraph><paragraph>thread_local variables have a subtle destruction-order issue: during thread shutdown, thread_local variables will be destroyed in the opposite order of their initialization (as is generally true in C++). If code triggered by the destructor of any thread_local variable refers to any already-destroyed thread_local on that thread, we will get a particularly hard to diagnose use-after-free.</paragraph><list type="ul"><item>Thread-local data is inherently safe from races (because only one thread can ordinarily access it), which makes thread_local useful for concurrent programming.</item><item>thread_local is the only standard-supported way of creating thread-local data.</item></list><list type="ul"><item>Accessing a thread_local variable may trigger execution of an unpredictable and uncontrollable amount of other code during thread-start or first use on a given thread.</item><item>thread_local variables are effectively global variables, and have all the drawbacks of global variables other than lack of thread-safety.</item><item>The memory consumed by a thread_local variable scales with the number of running threads (in the worst case), which can be quite large in a program.</item><item>Data members cannot be thread_local unless they are also static.</item><item>We may suffer from use-after-free bugs if thread_local variables have complex destructors. In particular, the destructor of any such variable must not call any code (transitively) that refers to any potentially-destroyed thread_local. This property is hard to enforce.</item><item>Approaches for avoiding use-after-free in global/static contexts do not work for thread_locals. Specifically, skipping destructors for globals and static variables is allowable because their lifetimes end at program shutdown. Thus, any "leak" is managed immediately by the OS cleaning up our memory and other resources. By contrast, skipping destructors for thread_local variables leads to resource leaks proportional to the total number of threads that terminate during the lifetime of the program.</item></list><paragraph>thread_local variables at class or namespace scope must be initialized with a true compile-time constant (i.e., they must have no dynamic initialization). To enforce this, thread_local variables at class or namespace scope must be annotated with constinit (or constexpr, but that should be rare):</paragraph><code language="code">   constinit thread_local Foo foo = ...;
  </code><paragraph>thread_local variables inside a function have no initialization concerns, but still risk use-after-free during thread exit. Note that you can use a function-scope thread_local to simulate a class- or namespace-scope thread_local by defining a function or static method that exposes it:</paragraph><code language="javascript">Foo& MyThreadLocalFoo() {
  thread_local Foo result = ComplicatedInitialization();
  return result;
}
</code><paragraph>Note that thread_local variables will be destroyed whenever a thread exits. If the destructor of any such variable refers to any other (potentially-destroyed) thread_local we will suffer from hard to diagnose use-after-free bugs. Prefer trivial types, or types that provably run no user-provided code at destruction to minimize the potential of accessing any other thread_local.</paragraph><paragraph>thread_local should be preferred over other mechanisms for defining thread-local data.</paragraph><heading level="2">Classes</heading><paragraph>Classes are the fundamental unit of code in C++. Naturally, we use them extensively. This section lists the main dos and don'ts you should follow when writing a class.</paragraph><heading level="3">Doing Work in Constructors</heading><paragraph>Avoid virtual method calls in constructors, and avoid initialization that can fail if you can't signal an error.</paragraph><paragraph>It is possible to perform arbitrary initialization in the body of the constructor.</paragraph><list type="ul"><item>No need to worry about whether the class has been initialized or not.</item><item>Objects that are fully initialized by constructor call can be const and may also be easier to use with standard containers or algorithms.</item></list><list type="ul"><item>If the work calls virtual functions, these calls will not get dispatched to the subclass implementations. Future modification to your class can quietly introduce this problem even if your class is not currently subclassed, causing much confusion.</item><item>There is no easy way for constructors to signal errors, short of crashing the program (not always appropriate) or using exceptions (which are forbidden).</item><item>If the work fails, we now have an object whose initialization code failed, so it may be an unusual state requiring a bool IsValid() state checking mechanism (or similar) which is easy to forget to call.</item><item>You cannot take the address of a constructor, so whatever work is done in the constructor cannot easily be handed off to, for example, another thread.</item></list><paragraph>Constructors should never call virtual functions. If appropriate for your code , terminating the program may be an appropriate error handling response. Otherwise, consider a factory function or Init() method as described in TotW #42 . Avoid Init() methods on objects with no other states that affect which public methods may be called (semi-constructed objects of this form are particularly hard to work with correctly).</paragraph><heading level="3">Implicit Conversions</heading><paragraph>Do not define implicit conversions. Use the explicit keyword for conversion operators and single-argument constructors.</paragraph><paragraph>Implicit conversions allow an object of one type (called the source type) to be used where a different type (called the destination type) is expected, such as when passing an int argument to a function that takes a double parameter.</paragraph><paragraph>In addition to the implicit conversions defined by the language, users can define their own, by adding appropriate members to the class definition of the source or destination type. An implicit conversion in the source type is defined by a type conversion operator named after the destination type (e.g., operator bool()). An implicit conversion in the destination type is defined by a constructor that can take the source type as its only argument (or only argument with no default value).</paragraph><paragraph>The explicit keyword can be applied to a constructor or a conversion operator, to ensure that it can only be used when the destination type is explicit at the point of use, e.g., with a cast. This applies not only to implicit conversions, but to list initialization syntax:</paragraph><code language="javascript">class Foo {
  explicit Foo(int x, double y);
  ...
};

void Func(Foo f);
</code><code language="code">Func({42, 3.14});  // Error
</code><paragraph>This kind of code isn't technically an implicit conversion, but the language treats it as one as far as explicit is concerned.</paragraph><list type="ul"><item>Implicit conversions can make a type more usable and expressive by eliminating the need to explicitly name a type when it's obvious.</item><item>Implicit conversions can be a simpler alternative to overloading, such as when a single function with a string_view parameter takes the place of separate overloads for std::string and const char*.</item><item>List initialization syntax is a concise and expressive way of initializing objects.</item></list><list type="ul"><item>Implicit conversions can hide type-mismatch bugs, where the destination type does not match the user's expectation, or the user is unaware that any conversion will take place.</item><item>Implicit conversions can make code harder to read, particularly in the presence of overloading, by making it less obvious what code is actually getting called.</item><item>Constructors that take a single argument may accidentally be usable as implicit type conversions, even if they are not intended to do so.</item><item>When a single-argument constructor is not marked explicit, there's no reliable way to tell whether it's intended to define an implicit conversion, or the author simply forgot to mark it.</item><item>Implicit conversions can lead to call-site ambiguities, especially when there are bidirectional implicit conversions. This can be caused either by having two types that both provide an implicit conversion, or by a single type that has both an implicit constructor and an implicit type conversion operator.</item><item>List initialization can suffer from the same problems if the destination type is implicit, particularly if the list has only a single element.</item></list><paragraph>Type conversion operators, and constructors that are callable with a single argument, must be marked explicit in the class definition. As an exception, copy and move constructors should not be explicit, since they do not perform type conversion.</paragraph><paragraph>Implicit conversions can sometimes be necessary and appropriate for types that are designed to be interchangeable, for example when objects of two types are just different representations of the same underlying value. In that case, contact your project leads to request a waiver of this rule.</paragraph><paragraph>Constructors that cannot be called with a single argument may omit explicit. Constructors that take a single std::initializer_list parameter should also omit explicit, in order to support copy-initialization (e.g., MyType m = {1, 2};).</paragraph><heading level="3">Copyable and Movable Types</heading><paragraph>A class's public API must make clear whether the class is copyable, move-only, or neither copyable nor movable. Support copying and/or moving if these operations are clear and meaningful for your type.</paragraph><paragraph>A movable type is one that can be initialized and assigned from temporaries.</paragraph><paragraph>A copyable type is one that can be initialized or assigned from any other object of the same type (so is also movable by definition), with the stipulation that the value of the source does not change. std::unique_ptr<int> is an example of a movable but not copyable type (since the value of the source std::unique_ptr<int> must be modified during assignment to the destination). int and std::string are examples of movable types that are also copyable. (For int, the move and copy operations are the same; for std::string, there exists a move operation that is less expensive than a copy.)</paragraph><paragraph>For user-defined types, the copy behavior is defined by the copy constructor and the copy-assignment operator. Move behavior is defined by the move constructor and the move-assignment operator, if they exist, or by the copy constructor and the copy-assignment operator otherwise.</paragraph><paragraph>The copy/move constructors can be implicitly invoked by the compiler in some situations, e.g., when passing objects by value.</paragraph><paragraph>Objects of copyable and movable types can be passed and returned by value, which makes APIs simpler, safer, and more general. Unlike when passing objects by pointer or reference, there's no risk of confusion over ownership, lifetime, mutability, and similar issues, and no need to specify them in the contract. It also prevents non-local interactions between the client and the implementation, which makes them easier to understand, maintain, and optimize by the compiler. Further, such objects can be used with generic APIs that require pass-by-value, such as most containers, and they allow for additional flexibility in e.g., type composition.</paragraph><paragraph>Copy/move constructors and assignment operators are usually easier to define correctly than alternatives like Clone(), CopyFrom() or Swap(), because they can be generated by the compiler, either implicitly or with = default. They are concise, and ensure that all data members are copied. Copy and move constructors are also generally more efficient, because they don't require heap allocation or separate initialization and assignment steps, and they're eligible for optimizations such as copy elision.</paragraph><paragraph>Move operations allow the implicit and efficient transfer of resources out of rvalue objects. This allows a plainer coding style in some cases.</paragraph><paragraph>Some types do not need to be copyable, and providing copy operations for such types can be confusing, nonsensical, or outright incorrect. Types representing singleton objects (Registerer), objects tied to a specific scope (Cleanup), or closely coupled to object identity (Mutex) cannot be copied meaningfully. Copy operations for base class types that are to be used polymorphically are hazardous, because use of them can lead to object slicing. Defaulted or carelessly-implemented copy operations can be incorrect, and the resulting bugs can be confusing and difficult to diagnose.</paragraph><paragraph>Copy constructors are invoked implicitly, which makes the invocation easy to miss. This may cause confusion for programmers used to languages where pass-by-reference is conventional or mandatory. It may also encourage excessive copying, which can cause performance problems.</paragraph><paragraph>Every class's public interface must make clear which copy and move operations the class supports. This should usually take the form of explicitly declaring and/or deleting the appropriate operations in the public section of the declaration.</paragraph><paragraph>Specifically, a copyable class should explicitly declare the copy operations, a move-only class should explicitly declare the move operations, and a non-copyable/movable class should explicitly delete the copy operations. A copyable class may also declare move operations in order to support efficient moves. Explicitly declaring or deleting all four copy/move operations is permitted, but not required. If you provide a copy or move assignment operator, you must also provide the corresponding constructor.</paragraph><code language="javascript">class Copyable {
 public:
  Copyable(const Copyable& other) = default;
  Copyable& operator=(const Copyable& other) = default;

  // The implicit move operations are suppressed by the declarations above.
  // You may explicitly declare move operations to support efficient moves.
};

class MoveOnly {
 public:
  MoveOnly(MoveOnly&& other) = default;
  MoveOnly& operator=(MoveOnly&& other) = default;

  // The copy operations are implicitly deleted, but you can
  // spell that out explicitly if you want:
  MoveOnly(const MoveOnly&) = delete;
  MoveOnly& operator=(const MoveOnly&) = delete;
};

class NotCopyableOrMovable {
 public:
  // Not copyable or movable
  NotCopyableOrMovable(const NotCopyableOrMovable&) = delete;
  NotCopyableOrMovable& operator=(const NotCopyableOrMovable&)
      = delete;

  // The move operations are implicitly disabled, but you can
  // spell that out explicitly if you want:
  NotCopyableOrMovable(NotCopyableOrMovable&&) = delete;
  NotCopyableOrMovable& operator=(NotCopyableOrMovable&&)
      = delete;
};
</code><paragraph>These declarations/deletions can be omitted only if they are obvious:</paragraph><list type="ul"><item>If the class has no private section, like a struct or an interface-only base class, then the copyability/movability can be determined by the copyability/movability of any public data members.</item><item>If a base class clearly isn't copyable or movable, derived classes naturally won't be either. An interface-only base class that leaves these operations implicit is not sufficient to make concrete subclasses clear.</item><item>Note that if you explicitly declare or delete either the constructor or assignment operation for copy, the other copy operation is not obvious and must be declared or deleted. Likewise for move operations.</item></list><paragraph>A type should not be copyable/movable if the meaning of copying/moving is unclear to a casual user, or if it incurs unexpected costs. Move operations for copyable types are strictly a performance optimization and are a potential source of bugs and complexity, so avoid defining them unless they are significantly more efficient than the corresponding copy operations. If your type provides copy operations, it is recommended that you design your class so that the default implementation of those operations is correct. Remember to review the correctness of any defaulted operations as you would any other code.</paragraph><paragraph>To eliminate the risk of slicing, prefer to make base classes abstract, by making their constructors protected, by declaring their destructors protected, or by giving them one or more pure virtual member functions. Prefer to avoid deriving from concrete classes.</paragraph><heading level="3">Structs vs. Classes</heading><paragraph>Use a struct only for passive objects that carry data; everything else is a class.</paragraph><paragraph>The struct and class keywords behave almost identically in C++. We add our own semantic meanings to each keyword, so you should use the appropriate keyword for the data-type you're defining.</paragraph><paragraph>structs should be used for passive objects that carry data, and may have associated constants. All fields must be public. The struct must not have invariants that imply relationships between different fields, since direct user access to those fields may break those invariants. Constructors, destructors, and helper methods may be present; however, these methods must not require or enforce any invariants.</paragraph><paragraph>If more functionality or invariants are required, or struct has wide visibility and expected to evolve, then a class is more appropriate. If in doubt, make it a class.</paragraph><paragraph>For consistency with STL, you can use struct instead of class for stateless types, such as traits, template metafunctions, and some functors.</paragraph><paragraph>Note that member variables in structs and classes have different naming rules.</paragraph><heading level="3">Structs vs. Pairs and Tuples</heading><paragraph>Prefer to use a struct instead of a pair or a tuple whenever the elements can have meaningful names.</paragraph><paragraph>While using pairs and tuples can avoid the need to define a custom type, potentially saving work when writing code, a meaningful field name will almost always be much clearer when reading code than .first, .second, or std::get<X>. While C++14's introduction of std::get<Type> to access a tuple element by type rather than index (when the type is unique) can sometimes partially mitigate this, a field name is usually substantially clearer and more informative than a type.</paragraph><paragraph>Pairs and tuples may be appropriate in generic code where there are not specific meanings for the elements of the pair or tuple. Their use may also be required in order to interoperate with existing code or APIs.</paragraph><heading level="3">Inheritance</heading><paragraph>Composition is often more appropriate than inheritance. When using inheritance, make it public.</paragraph><paragraph>When a sub-class inherits from a base class, it includes the definitions of all the data and operations that the base class defines. "Interface inheritance" is inheritance from a pure abstract base class (one with no state or defined methods); all other inheritance is "implementation inheritance".</paragraph><paragraph>Implementation inheritance reduces code size by re-using the base class code as it specializes an existing type. Because inheritance is a compile-time declaration, you and the compiler can understand the operation and detect errors. Interface inheritance can be used to programmatically enforce that a class expose a particular API. Again, the compiler can detect errors, in this case, when a class does not define a necessary method of the API.</paragraph><paragraph>For implementation inheritance, because the code implementing a sub-class is spread between the base and the sub-class, it can be more difficult to understand an implementation. The sub-class cannot override functions that are not virtual, so the sub-class cannot change implementation.</paragraph><paragraph>Multiple inheritance is especially problematic, because it often imposes a higher performance overhead (in fact, the performance drop from single inheritance to multiple inheritance can often be greater than the performance drop from ordinary to virtual dispatch), and because it risks leading to "diamond" inheritance patterns, which are prone to ambiguity, confusion, and outright bugs.</paragraph><paragraph>All inheritance should be public. If you want to do private inheritance, you should be including an instance of the base class as a member instead. You may use final on classes when you don't intend to support using them as base classes.</paragraph><paragraph>Do not overuse implementation inheritance. Composition is often more appropriate. Try to restrict use of inheritance to the "is-a" case: Bar subclasses Foo if it can reasonably be said that Bar "is a kind of" Foo.</paragraph><paragraph>Limit the use of protected to those member functions that might need to be accessed from subclasses. Note that data members should be private.</paragraph><paragraph>Explicitly annotate overrides of virtual functions or virtual destructors with exactly one of an override or (less frequently) final specifier. Do not use virtual when declaring an override. Rationale: A function or destructor marked override or final that is not an override of a base class virtual function will not compile, and this helps catch common errors. The specifiers serve as documentation; if no specifier is present, the reader has to check all ancestors of the class in question to determine if the function or destructor is virtual or not.</paragraph><paragraph>Multiple inheritance is permitted, but multiple implementation inheritance is strongly discouraged.</paragraph><heading level="3">Operator Overloading</heading><paragraph>Overload operators judiciously. Do not use user-defined literals.</paragraph><paragraph>C++ permits user code to declare overloaded versions of the built-in operators using the operator keyword, so long as one of the parameters is a user-defined type. The operator keyword also permits user code to define new kinds of literals using operator"", and to define type-conversion functions such as operator bool().</paragraph><paragraph>Operator overloading can make code more concise and intuitive by enabling user-defined types to behave the same as built-in types. Overloaded operators are the idiomatic names for certain operations (e.g., ==, <, =, and <<), and adhering to those conventions can make user-defined types more readable and enable them to interoperate with libraries that expect those names.</paragraph><paragraph>User-defined literals are a very concise notation for creating objects of user-defined types.</paragraph><list type="ul"><item>Providing a correct, consistent, and unsurprising set of operator overloads requires some care, and failure to do so can lead to confusion and bugs.</item><item>Overuse of operators can lead to obfuscated code, particularly if the overloaded operator's semantics don't follow convention.</item><item>The hazards of function overloading apply just as much to operator overloading, if not more so.</item><item>Operator overloads can fool our intuition into thinking that expensive operations are cheap, built-in operations.</item><item>Finding the call sites for overloaded operators may require a search tool that's aware of C++ syntax, rather than, e.g., grep.</item><item>If you get the argument type of an overloaded operator wrong, you may get a different overload rather than a compiler error. For example, foo < bar may do one thing, while &foo < &bar does something totally different.</item><item>Certain operator overloads are inherently hazardous. Overloading unary & can cause the same code to have different meanings depending on whether the overload declaration is visible. Overloads of &&, ||, and , (comma) cannot match the evaluation-order semantics of the built-in operators.</item><item>Operators are often defined outside the class, so there's a risk of different files introducing different definitions of the same operator. If both definitions are linked into the same binary, this results in undefined behavior, which can manifest as subtle run-time bugs.</item><item>User-defined literals (UDLs) allow the creation of new syntactic forms that are unfamiliar even to experienced C++ programmers, such as "Hello World"sv as a shorthand for std::string_view("Hello World"). Existing notations are clearer, though less terse.</item><item>Because they can't be namespace-qualified, uses of UDLs also require use of either using-directives (which we ban) or using-declarations (which we ban in header files except when the imported names are part of the interface exposed by the header file in question). Given that header files would have to avoid UDL suffixes, we prefer to avoid having conventions for literals differ between header files and source files.</item></list><paragraph>Define overloaded operators only if their meaning is obvious, unsurprising, and consistent with the corresponding built-in operators. For example, use | as a bitwise- or logical-or, not as a shell-style pipe.</paragraph><paragraph>Define operators only on your own types. More precisely, define them in the same headers, .cc files, and namespaces as the types they operate on. That way, the operators are available wherever the type is, minimizing the risk of multiple definitions. If possible, avoid defining operators as templates, because they must satisfy this rule for any possible template arguments. If you define an operator, also define any related operators that make sense, and make sure they are defined consistently.</paragraph><paragraph>Prefer to define non-modifying binary operators as non-member functions. If a binary operator is defined as a class member, implicit conversions will apply to the right-hand argument, but not the left-hand one. It will confuse your users if a + b compiles but b + a doesn't.</paragraph><paragraph>For a type T whose values can be compared for equality, define a non-member operator== and document when two values of type T are considered equal. If there is a single obvious notion of when a value t1 of type T is less than another such value t2 then you may also define operator<=>, which should be consistent with operator==. Prefer not to overload the other comparison and ordering operators.</paragraph><paragraph>Don't go out of your way to avoid defining operator overloads. For example, prefer to define ==, =, and <<, rather than Equals(), CopyFrom(), and PrintTo(). Conversely, don't define operator overloads just because other libraries expect them. For example, if your type doesn't have a natural ordering, but you want to store it in a std::set, use a custom comparator rather than overloading <.</paragraph><paragraph>Do not overload &&, ||, , (comma), or unary &. Do not overload operator"", i.e., do not introduce user-defined literals. Do not use any such literals provided by others (including the standard library).</paragraph><paragraph>Type conversion operators are covered in the section on implicit conversions. The = operator is covered in the section on copy constructors. Overloading << for use with streams is covered in the section on streams. See also the rules on function overloading, which apply to operator overloading as well.</paragraph><heading level="3">Access Control</heading><paragraph>Make classes' data members private, unless they are constants. This simplifies reasoning about invariants, at the cost of some easy boilerplate in the form of accessors (usually const) if necessary.</paragraph><paragraph>For technical reasons, we allow data members of a test fixture class defined in a .cc file to be protected when using Google Test. If a test fixture class is defined outside of the .cc file it is used in, for example in a .h file, make data members private.</paragraph><heading level="3">Declaration Order</heading><paragraph>Group similar declarations together, placing public parts earlier.</paragraph><paragraph>A class definition should usually start with a public: section, followed by protected:, then private:. Omit sections that would be empty.</paragraph><paragraph>Within each section, prefer grouping similar kinds of declarations together, and prefer the following order:</paragraph><list type="ol"><item>Types and type aliases (typedef, using, enum, nested structs and classes, and friend types)</item><item>(Optionally, for structs only) non-static data members</item><item>Static constants</item><item>Factory functions</item><item>Constructors and assignment operators</item><item>Destructor</item><item>All other functions (static and non-static member functions, and friend functions)</item><item>All other data members (static and non-static)</item></list><paragraph>Do not put large method definitions inline in the class definition. Usually, only trivial or performance-critical, and very short, methods may be defined inline. See Defining Functions in Header Files for more details.</paragraph><heading level="2">Functions</heading><heading level="3">Inputs and Outputs</heading><paragraph>The output of a C++ function is naturally provided via a return value and sometimes via output parameters (or in/out parameters).</paragraph><paragraph>Prefer using return values over output parameters: they improve readability, and often provide the same or better performance. See TotW #176.</paragraph><paragraph>Prefer to return by value or, failing that, return by reference. Avoid returning a raw pointer unless it can be null.</paragraph><paragraph>Parameters are either inputs to the function, outputs from the function, or both. Non-optional input parameters should usually be values or const references, while non-optional output and input/output parameters should usually be references (which cannot be null). Generally, use std::optional to represent optional by-value inputs, and use a const pointer when the non-optional form would have used a reference. Use non-const pointers to represent optional outputs and optional input/output parameters.</paragraph><paragraph>Avoid defining functions that require a reference parameter to outlive the call. In some cases reference parameters can bind to temporaries, leading to lifetime bugs. Instead, find a way to eliminate the lifetime requirement (for example, by copying the parameter), or pass retained parameters by pointer and document the lifetime and non-null requirements. See TotW 116 for more.</paragraph><paragraph>When ordering function parameters, put all input-only parameters before any output parameters. In particular, do not add new parameters to the end of the function just because they are new; place new input-only parameters before the output parameters. This is not a hard-and-fast rule. Parameters that are both input and output muddy the waters, and, as always, consistency with related functions may require you to bend the rule. Variadic functions may also require unusual parameter ordering.</paragraph><heading level="3">Write Short Functions</heading><paragraph>Prefer small and focused functions.</paragraph><paragraph>We recognize that long functions are sometimes appropriate, so no hard limit is placed on functions length. If a function exceeds about 40 lines, think about whether it can be broken up without harming the structure of the program.</paragraph><paragraph>Even if your long function works perfectly now, someone modifying it in a few months may add new behavior. This could result in bugs that are hard to find. Keeping your functions short and simple makes it easier for other people to read and modify your code. Small functions are also easier to test.</paragraph><paragraph>You could find long and complicated functions when working with some code. Do not be intimidated by modifying existing code: if working with such a function proves to be difficult, you find that errors are hard to debug, or you want to use a piece of it in several different contexts, consider breaking up the function into smaller and more manageable pieces.</paragraph><heading level="3">Function Overloading</heading><paragraph>Use overloaded functions (including constructors) only if a reader looking at a call site can get a good idea of what is happening without having to first figure out exactly which overload is being called.</paragraph><paragraph>You may write a function that takes a const std::string& and overload it with another that takes const char*. However, in this case consider std::string_view instead.</paragraph><code language="javascript">class MyClass {
 public:
  void Analyze(const std::string &text);
  void Analyze(const char *text, size_t textlen);
};
</code><paragraph>Overloading can make code more intuitive by allowing an identically-named function to take different arguments. It may be necessary for templatized code, and it can be convenient for Visitors.</paragraph><paragraph>Overloading based on const or ref qualification may make utility code more usable, more efficient, or both. See TotW #148 for more.</paragraph><paragraph>If a function is overloaded by the argument types alone, a reader may have to understand C++'s complex matching rules in order to tell what's going on. Also many people are confused by the semantics of inheritance if a derived class overrides only some of the variants of a function.</paragraph><paragraph>You may overload a function when there are no semantic differences between variants. These overloads may vary in types, qualifiers, or argument count. However, a reader of such a call must not need to know which member of the overload set is chosen, only that something from the set is being called.</paragraph><paragraph>To reflect this unified design, prefer a single, comprehensive "umbrella" comment that documents the entire overload set and is placed before the first declaration.</paragraph><paragraph>Where a reader might have difficulty connecting the umbrella comment to a specific overload, it's okay to have a comment for specific overloads.</paragraph><heading level="3">Default Arguments</heading><paragraph>Default arguments are allowed on non-virtual functions when the default is guaranteed to always have the same value. Follow the same restrictions as for function overloading, and prefer overloaded functions if the readability gained with default arguments doesn't outweigh the downsides below.</paragraph><paragraph>Often you have a function that uses default values, but occasionally you want to override the defaults. Default parameters allow an easy way to do this without having to define many functions for the rare exceptions. Compared to overloading the function, default arguments have a cleaner syntax, with less boilerplate and a clearer distinction between 'required' and 'optional' arguments.</paragraph><paragraph>Defaulted arguments are another way to achieve the semantics of overloaded functions, so all the reasons not to overload functions apply.</paragraph><paragraph>The defaults for arguments in a virtual function call are determined by the static type of the target object, and there's no guarantee that all overrides of a given function declare the same defaults.</paragraph><paragraph>Default parameters are re-evaluated at each call site, which can bloat the generated code. Readers may also expect the default's value to be fixed at the declaration instead of varying at each call.</paragraph><paragraph>Function pointers are confusing in the presence of default arguments, since the function signature often doesn't match the call signature. Adding function overloads avoids these problems.</paragraph><paragraph>Default arguments are banned on virtual functions, where they don't work properly, and in cases where the specified default might not evaluate to the same value depending on when it was evaluated. (For example, don't write void f(int n = counter++);.)</paragraph><paragraph>In some other cases, default arguments can improve the readability of their function declarations enough to overcome the downsides above, so they are allowed. When in doubt, use overloads.</paragraph><heading level="3">Trailing Return Type Syntax</heading><paragraph>Use trailing return types only where using the ordinary syntax (leading return types) is impractical or much less readable.</paragraph><paragraph>C++ allows two different forms of function declarations. In the older form, the return type appears before the function name. For example:</paragraph><code language="code">int foo(int x);
</code><paragraph>The newer form uses the auto keyword before the function name and a trailing return type after the argument list. For example, the declaration above could equivalently be written:</paragraph><code language="code">auto foo(int x) -> int;
</code><paragraph>The trailing return type is in the function's scope. This doesn't make a difference for a simple case like int but it matters for more complicated cases, like types declared in class scope or types written in terms of the function parameters.</paragraph><paragraph>Trailing return types are the only way to explicitly specify the return type of a lambda expression. In some cases the compiler is able to deduce a lambda's return type, but not in all cases. Even when the compiler can deduce it automatically, sometimes specifying it explicitly would be clearer for readers.</paragraph><paragraph>Sometimes it's easier and more readable to specify a return type after the function's parameter list has already appeared. This is particularly true when the return type depends on template parameters. For example:</paragraph><code language="code">    template <typename T, typename U>
    auto add(T t, U u) -> decltype(t + u);
  </code><paragraph>versus</paragraph><code language="code">    template <typename T, typename U>
    decltype(declval<T&>() + declval<U&>()) add(T t, U u);
  </code><paragraph>Trailing return type syntax is relatively new and it has no analogue in C++-like languages such as C and Java, so some readers may find it unfamiliar.</paragraph><paragraph>Existing codebases have an enormous number of function declarations that aren't going to get changed to use the new syntax, so the realistic choices are using the old syntax only or using a mixture of the two. Using a single version is better for uniformity of style.</paragraph><paragraph>In most cases, continue to use the older style of function declaration where the return type goes before the function name. Use the new trailing-return-type form only in cases where it's required (such as lambdas) or where, by putting the type after the function's parameter list, it allows you to write the type in a much more readable way. The latter case should be rare; it's mostly an issue in fairly complicated template code, which is discouraged in most cases.</paragraph><heading level="2">Google-Specific Magic</heading><paragraph>There are various tricks and utilities that we use to make C++ code more robust, and various ways we use C++ that may differ from what you see elsewhere.</paragraph><heading level="3">Ownership and Smart Pointers</heading><paragraph>Prefer to have single, fixed owners for dynamically allocated objects. Prefer to transfer ownership with smart pointers.</paragraph><paragraph>"Ownership" is a bookkeeping technique for managing dynamically allocated memory (and other resources). The owner of a dynamically allocated object is an object or function that is responsible for ensuring that it is deleted when no longer needed. Ownership can sometimes be shared, in which case the last owner is typically responsible for deleting it. Even when ownership is not shared, it can be transferred from one piece of code to another.</paragraph><paragraph>"Smart" pointers are classes that act like pointers, e.g., by overloading the * and -> operators. Some smart pointer types can be used to automate ownership bookkeeping, to ensure these responsibilities are met. std::unique_ptr is a smart pointer type which expresses exclusive ownership of a dynamically allocated object; the object is deleted when the std::unique_ptr goes out of scope. It cannot be copied, but can be moved to represent ownership transfer. std::shared_ptr is a smart pointer type that expresses shared ownership of a dynamically allocated object. std::shared_ptrs can be copied; ownership of the object is shared among all copies, and the object is deleted when the last std::shared_ptr is destroyed.</paragraph><list type="ul"><item>It's virtually impossible to manage dynamically allocated memory without some sort of ownership logic.</item><item>Transferring ownership of an object can be cheaper than copying it (if copying it is even possible).</item><item>Transferring ownership can be simpler than 'borrowing' a pointer or reference, because it reduces the need to coordinate the lifetime of the object between the two users.</item><item>Smart pointers can improve readability by making ownership logic explicit, self-documenting, and unambiguous.</item><item>Smart pointers can eliminate manual ownership bookkeeping, simplifying the code and ruling out large classes of errors.</item><item>For const objects, shared ownership can be a simple and efficient alternative to deep copying.</item></list><list type="ul"><item>Ownership must be represented and transferred via pointers (whether smart or plain). Pointer semantics are more complicated than value semantics, especially in APIs: you have to worry not just about ownership, but also aliasing, lifetime, and mutability, among other issues.</item><item>The performance costs of value semantics are often overestimated, so the performance benefits of ownership transfer might not justify the readability and complexity costs.</item><item>APIs that transfer ownership force their clients into a single memory management model.</item><item>Code using smart pointers is less explicit about where the resource releases take place.</item><item>std::unique_ptr expresses ownership transfer using move semantics, which are relatively new and may confuse some programmers.</item><item>Shared ownership can be a tempting alternative to careful ownership design, obfuscating the design of a system.</item><item>Shared ownership requires explicit bookkeeping at run-time, which can be costly.</item><item>In some cases (e.g., cyclic references), objects with shared ownership may never be deleted.</item><item>Smart pointers are not perfect substitutes for plain pointers.</item></list><paragraph>If dynamic allocation is necessary, prefer to keep ownership with the code that allocated it. If other code needs access to the object, consider passing it a copy, or passing a pointer or reference without transferring ownership. Prefer to use std::unique_ptr to make ownership transfer explicit. For example:</paragraph><code language="code">std::unique_ptr<Foo> FooFactory();
void FooConsumer(std::unique_ptr<Foo> ptr);
</code><paragraph>Do not design your code to use shared ownership without a very good reason. One such reason is to avoid expensive copy operations, but you should only do this if the performance benefits are significant, and the underlying object is immutable (i.e., std::shared_ptr<const Foo>). If you do use shared ownership, prefer to use std::shared_ptr.</paragraph><paragraph>Never use std::auto_ptr. Instead, use std::unique_ptr.</paragraph><heading level="3">cpplint</heading><paragraph>Use cpplint.py to detect style errors.</paragraph><paragraph>cpplint.py is a tool that reads a source file and identifies many style errors. It is not perfect, and has both false positives and false negatives, but it is still a valuable tool.</paragraph><paragraph>Some projects have instructions on how to run cpplint.py from their project tools. If the project you are contributing to does not, you can download cpplint.py separately.</paragraph><heading level="2">Other C++ Features</heading><heading level="3">Rvalue References</heading><paragraph>Use rvalue references only in certain special cases listed below.</paragraph><paragraph>Rvalue references are a type of reference that can only bind to temporary objects. The syntax is similar to traditional reference syntax. For example, void f(std::string&& s); declares a function whose argument is an rvalue reference to a std::string.</paragraph><paragraph>When the token '&&' is applied to an unqualified template argument in a function parameter, special template argument deduction rules apply. Such a reference is called a forwarding reference.</paragraph><list type="ul"><item>Defining a move constructor (a constructor taking an rvalue reference to the class type) makes it possible to move a value instead of copying it. If v1 is a std::vector<std::string>, for example, then auto v2(std::move(v1)) will probably just result in some simple pointer manipulation instead of copying a large amount of data. In many cases this can result in a major performance improvement.</item><item>Rvalue references make it possible to implement types that are movable but not copyable, which can be useful for types that have no sensible definition of copying but where you might still want to pass them as function arguments, put them in containers, etc.</item><item>std::move is necessary to make effective use of some standard-library types, such as std::unique_ptr.</item><item>Forwarding references which use the rvalue reference token make it possible to write a generic function wrapper that forwards its arguments to another function, and works whether or not its arguments are temporary objects and/or const. This is called 'perfect forwarding'.</item></list><list type="ul"><item>Rvalue references are not yet widely understood. Rules like reference collapsing and the special deduction rule for forwarding references are somewhat obscure.</item><item>Rvalue references are often misused. Using rvalue references is counter-intuitive in signatures where the argument is expected to have a valid specified state after the function call, or where no move operation is performed.</item></list><paragraph>Do not use rvalue references (or apply the && qualifier to methods), except as follows:</paragraph><list type="ul"><item>You may use them to define move constructors and move assignment operators (as described in Copyable and Movable Types).</item><item>You may use them to define &&-qualified methods that logically "consume" *this, leaving it in an unusable or empty state. Note that this applies only to method qualifiers (which come after the closing parenthesis of the function signature); if you want to "consume" an ordinary function parameter, prefer to pass it by value.</item><item>You may use forwarding references in conjunction with std::forward, to support perfect forwarding.</item><item>You may use them to define pairs of overloads, such as one taking Foo&& and the other taking const Foo&. Usually the preferred solution is just to pass by value, but an overloaded pair of functions sometimes yields better performance, for example if the functions sometimes don't consume the input. As always: if you're writing more complicated code for the sake of performance, make sure you have evidence that it actually helps.</item></list><heading level="3">Friends</heading><paragraph>We allow use of friend classes and functions, within reason.</paragraph><paragraph>Friends should usually be defined in the same file so that the reader does not have to look in another file to find uses of the private members of a class. A common use of friend is to have a FooBuilder class be a friend of Foo so that it can construct the inner state of Foo correctly, without exposing this state to the world. In some cases it may be useful to make a unit test class a friend of the class it tests.</paragraph><paragraph>Friends extend, but do not break, the encapsulation boundary of a class. In some cases this is better than making a member public when you want to give only one other class access to it. However, most classes should interact with other classes solely through their public members.</paragraph><heading level="3">Exceptions</heading><paragraph>We do not use C++ exceptions.</paragraph><list type="ul"><item>Exceptions allow higher levels of an application to decide how to handle "can't happen" failures in deeply nested functions, without the obscuring and error-prone bookkeeping of error codes.</item><item>Exceptions are used by most other modern languages. Using them in C++ would make it more consistent with Python, Java, and the C++ that others are familiar with.</item><item>Some third-party C++ libraries use exceptions, and turning them off internally makes it harder to integrate with those libraries.</item><item>Exceptions are the only way for a constructor to fail. We can simulate this with a factory function or an Init() method, but these require heap allocation or a new "invalid" state, respectively.</item><item>Exceptions are really handy in testing frameworks.</item></list><list type="ul"><item>When you add a throw statement to an existing function, you must examine all of its transitive callers. Either they must make at least the basic exception safety guarantee, or they must never catch the exception and be happy with the program terminating as a result. For instance, if f() calls g() calls h(), and h throws an exception that f catches, g has to be careful or it may not clean up properly.</item><item>More generally, exceptions make the control flow of programs difficult to evaluate by looking at code: functions may return in places you don't expect. This causes maintainability and debugging difficulties. You can minimize this cost via some rules on how and where exceptions can be used, but at the cost of more that a developer needs to know and understand.</item><item>Exception safety requires both RAII and different coding practices. Lots of supporting machinery is needed to make writing correct exception-safe code easy. Further, to avoid requiring readers to understand the entire call graph, exception-safe code must isolate logic that writes to persistent state into a "commit" phase. This will have both benefits and costs (perhaps where you're forced to obfuscate code to isolate the commit). Allowing exceptions would force us to always pay those costs even when they're not worth it.</item><item>Turning on exceptions adds data to each binary produced, increasing compile time (probably slightly) and possibly increasing address space pressure.</item><item>The availability of exceptions may encourage developers to throw them when they are not appropriate or recover from them when it's not safe to do so. For example, invalid user input should not cause exceptions to be thrown. We would need to make the style guide even longer to document these restrictions!</item></list><paragraph>On their face, the benefits of using exceptions outweigh the costs, especially in new projects. However, for existing code, the introduction of exceptions has implications on all dependent code. If exceptions can be propagated beyond a new project, it also becomes problematic to integrate the new project into existing exception-free code. Because most existing C++ code at Google is not prepared to deal with exceptions, it is comparatively difficult to adopt new code that generates exceptions.</paragraph><paragraph>Given that Google's existing code is not exception-tolerant, the costs of using exceptions are somewhat greater than the costs in a new project. The conversion process would be slow and error-prone. We don't believe that the available alternatives to exceptions, such as error codes and assertions, introduce a significant burden.</paragraph><paragraph>Our advice against using exceptions is not predicated on philosophical or moral grounds, but practical ones. Because we'd like to use our open-source projects at Google and it's difficult to do so if those projects use exceptions, we need to advise against exceptions in Google open-source projects as well. Things would probably be different if we had to do it all over again from scratch.</paragraph><paragraph>This prohibition also applies to exception handling related features such as std::exception_ptr and std::nested_exception.</paragraph><paragraph>There is an exception to this rule (no pun intended) for Windows code.</paragraph><heading level="3">noexcept</heading><paragraph>Specify noexcept when it is useful and correct.</paragraph><paragraph>The noexcept specifier is used to specify whether a function will throw exceptions or not. If an exception escapes from a function marked noexcept, the program crashes via std::terminate.</paragraph><paragraph>The noexcept operator performs a compile-time check that returns true if an expression is declared to not throw any exceptions.</paragraph><list type="ul"><item>Specifying move constructors as noexcept improves performance in some cases, e.g., std::vector<T>::resize() moves rather than copies the objects if T's move constructor is noexcept.</item><item>Specifying noexcept on a function can trigger compiler optimizations in environments where exceptions are enabled, e.g., compiler does not have to generate extra code for stack-unwinding, if it knows that no exceptions can be thrown due to a noexcept specifier.</item></list><list type="ul"><item>In projects following this guide that have exceptions disabled it is hard to ensure that noexcept specifiers are correct, and hard to define what correctness even means.</item><item>It's hard, if not impossible, to undo noexcept because it eliminates a guarantee that callers may be relying on, in ways that are hard to detect.</item></list><paragraph>You may use noexcept when it is useful for performance if it accurately reflects the intended semantics of your function, i.e., that if an exception is somehow thrown from within the function body then it represents a fatal error. You can assume that noexcept on move constructors has a meaningful performance benefit. If you think there is significant performance benefit from specifying noexcept on some other function, please discuss it with your project leads.</paragraph><paragraph>Prefer unconditional noexcept if exceptions are completely disabled (i.e., most Google C++ environments). Otherwise, use conditional noexcept specifiers with simple conditions, in ways that evaluate false only in the few cases where the function could potentially throw. The tests might include type traits check on whether the involved operation might throw (e.g., std::is_nothrow_move_constructible for move-constructing objects), or on whether allocation can throw (e.g., absl::default_allocator_is_nothrow for standard default allocation). Note in many cases the only possible cause for an exception is allocation failure (we believe move constructors should not throw except due to allocation failure), and there are many applications where it's appropriate to treat memory exhaustion as a fatal error rather than an exceptional condition that your program should attempt to recover from. Even for other potential failures you should prioritize interface simplicity over supporting all possible exception throwing scenarios: instead of writing a complicated noexcept clause that depends on whether a hash function can throw, for example, simply document that your component doesn't support hash functions throwing and make it unconditionally noexcept.</paragraph><heading level="3">Run-Time Type Information (RTTI)</heading><paragraph>Avoid using run-time type information (RTTI).</paragraph><paragraph>RTTI allows a programmer to query the C++ class of an object at run-time. This is done by use of typeid or dynamic_cast.</paragraph><paragraph>The standard alternatives to RTTI (described below) require modification or redesign of the class hierarchy in question. Sometimes such modifications are infeasible or undesirable, particularly in widely-used or mature code.</paragraph><paragraph>RTTI can be useful in some unit tests. For example, it is useful in tests of factory classes where the test has to verify that a newly created object has the expected dynamic type. It is also useful in managing the relationship between objects and their mocks.</paragraph><paragraph>RTTI is useful when considering multiple abstract objects. Consider</paragraph><code language="javascript">bool Base::Equal(Base* other) = 0;
bool Derived::Equal(Base* other) {
  Derived* that = dynamic_cast<Derived*>(other);
  if (that == nullptr)
    return false;
  ...
}
</code><paragraph>Querying the type of an object at run-time frequently means a design problem. Needing to know the type of an object at runtime is often an indication that the design of your class hierarchy is flawed.</paragraph><paragraph>Undisciplined use of RTTI makes code hard to maintain. It can lead to type-based decision trees or switch statements scattered throughout the code, all of which must be examined when making further changes.</paragraph><paragraph>RTTI has legitimate uses but is prone to abuse, so you must be careful when using it. You may use it freely in unit tests, but avoid it when possible in other code. In particular, think twice before using RTTI in new code. If you find yourself needing to write code that behaves differently based on the class of an object, consider one of the following alternatives to querying the type:</paragraph><list type="ul"><item>Virtual methods are the preferred way of executing different code paths depending on a specific subclass type. This puts the work within the object itself.</item><item>If the work belongs outside the object and instead in some processing code, consider a double-dispatch solution, such as the Visitor design pattern. This allows a facility outside the object itself to determine the type of class using the built-in type system.</item></list><paragraph>When the logic of a program guarantees that a given instance of a base class is in fact an instance of a particular derived class, then a dynamic_cast may be used freely on the object. Usually one can use a static_cast as an alternative in such situations.</paragraph><paragraph>Decision trees based on type are a strong indication that your code is on the wrong track.</paragraph><code language="javascript">if (typeid(*data) == typeid(D1)) {
  ...
} else if (typeid(*data) == typeid(D2)) {
  ...
} else if (typeid(*data) == typeid(D3)) {
...
</code><paragraph>Code such as this usually breaks when additional subclasses are added to the class hierarchy. Moreover, when properties of a subclass change, it is difficult to find and modify all the affected code segments.</paragraph><paragraph>Do not hand-implement an RTTI-like workaround. The arguments against RTTI apply just as much to workarounds like class hierarchies with type tags. Moreover, workarounds disguise your true intent.</paragraph><heading level="3">Casting</heading><paragraph>Use C++-style casts like static_cast<float>(double_value), or brace initialization for conversion of arithmetic types like int64_t y = int64_t{1} << 42. Do not use cast formats like (int)x unless the cast is to void. You may use cast formats like T(x) only when T is a class type.</paragraph><paragraph>C++ introduced a different cast system from C that distinguishes the types of cast operations.</paragraph><paragraph>The problem with C casts is the ambiguity of the operation; sometimes you are doing a conversion (e.g., (int)3.5) and sometimes you are doing a cast (e.g., (int)"hello"). Brace initialization and C++ casts can often help avoid this ambiguity. Additionally, C++ casts are more visible when searching for them.</paragraph><paragraph>The C++-style cast syntax is verbose and cumbersome.</paragraph><paragraph>In general, do not use C-style casts. Instead, use these C++-style casts when explicit type conversion is necessary.</paragraph><list type="ul"><item>Use brace initialization to convert arithmetic types (e.g., int64_t{x}). This is the safest approach because code will not compile if conversion can result in information loss. The syntax is also concise.</item><item>When explicitly converting to a class type, use a function-style cast; e.g., prefer std::string(some_cord) to static_cast<std::string>(some_cord).</item><item>Use absl::implicit_cast to safely cast up a type hierarchy, e.g., casting a Foo* to a SuperclassOfFoo* or casting a Foo* to a const Foo*. C++ usually does this automatically but some situations need an explicit up-cast, such as use of the ?: operator.</item><item>Use static_cast as the equivalent of a C-style cast that does value conversion, when you need to explicitly up-cast a pointer from a class to its superclass, or when you need to explicitly cast a pointer from a superclass to a subclass. In this last case, you must be sure your object is actually an instance of the subclass.</item><item>Use const_cast to remove the const qualifier (see const).</item><item>Use reinterpret_cast to do unsafe conversions of pointer types to and from integer and other pointer types, including void*. Use this only if you know what you are doing and you understand the aliasing issues. Also, consider dereferencing the pointer (without a cast) and using std::bit_cast to cast the resulting value.</item><item>Use std::bit_cast to interpret the raw bits of a value using a different type of the same size (a type pun), such as interpreting the bits of a double as int64_t.</item></list><paragraph>See the RTTI section for guidance on the use of dynamic_cast.</paragraph><heading level="3">Streams</heading><paragraph>Use streams where appropriate, and stick to "simple" usages. Overload << for streaming only for types representing values, and write only the user-visible value, not any implementation details.</paragraph><paragraph>Streams are the standard I/O abstraction in C++, as exemplified by the standard header <iostream>. They are widely used in Google code, mostly for debug logging and test diagnostics.</paragraph><paragraph>The << and >> stream operators provide an API for formatted I/O that is easily learned, portable, reusable, and extensible. printf, by contrast, doesn't even support std::string, to say nothing of user-defined types, and is very difficult to use portably. printf also obliges you to choose among the numerous slightly different versions of that function, and navigate the dozens of conversion specifiers.</paragraph><paragraph>Streams provide first-class support for console I/O via std::cin, std::cout, std::cerr, and std::clog. The C APIs do as well, but are hampered by the need to manually buffer the input.</paragraph><list type="ul"><item>Stream formatting can be configured by mutating the state of the stream. Such mutations are persistent, so the behavior of your code can be affected by the entire previous history of the stream, unless you go out of your way to restore it to a known state every time other code might have touched it. User code can not only modify the built-in state, it can add new state variables and behaviors through a registration system.</item><item>It is difficult to precisely control stream output, due to the above issues, the way code and data are mixed in streaming code, and the use of operator overloading (which may select a different overload than you expect).</item><item>The practice of building up output through chains of << operators interferes with internationalization, because it bakes word order into the code, and streams' support for localization is flawed.</item><item>The streams API is subtle and complex, so programmers must develop experience with it in order to use it effectively.</item><item>Resolving the many overloads of << is extremely costly for the compiler. When used pervasively in a large codebase, it can consume as much as 20% of the parsing and semantic analysis time.</item></list><paragraph>Use streams only when they are the best tool for the job. This is typically the case when the I/O is ad-hoc, local, human-readable, and targeted at other developers rather than end-users. Be consistent with the code around you, and with the codebase as a whole; if there's an established tool for your problem, use that tool instead. In particular, logging libraries are usually a better choice than std::cerr or std::clog for diagnostic output, and the libraries in absl/strings or the equivalent are usually a better choice than std::stringstream.</paragraph><paragraph>Avoid using streams for I/O that faces external users or handles untrusted data. Instead, find and use the appropriate templating libraries to handle issues like internationalization, localization, and security hardening.</paragraph><paragraph>If you do use streams, avoid the stateful parts of the streams API (other than error state), such as imbue(), xalloc(), and register_callback(). Use explicit formatting functions (such as absl::StreamFormat()) rather than stream manipulators or formatting flags to control formatting details such as number base, precision, or padding.</paragraph><paragraph>Overload << as a streaming operator for your type only if your type represents a value, and << writes out a human-readable string representation of that value. Avoid exposing implementation details in the output of <<; if you need to print object internals for debugging, use named functions instead (a method named DebugString() is the most common convention).</paragraph><heading level="3">Preincrement and Predecrement</heading><paragraph>Use the prefix form (++i) of the increment and decrement operators unless you need postfix semantics.</paragraph><paragraph>When a variable is incremented (++i or i++) or decremented (--i or i--) and the value of the expression is not used, one must decide whether to preincrement (decrement) or postincrement (decrement).</paragraph><paragraph>A postfix increment/decrement expression evaluates to the value as it was before it was modified. This can result in code that is more compact but harder to read. The prefix form is generally more readable, is never less efficient, and can be more efficient because it doesn't need to make a copy of the value as it was before the operation.</paragraph><paragraph>The tradition developed, in C, of using post-increment, even when the expression value is not used, especially in for loops.</paragraph><paragraph>Use prefix increment/decrement, unless the code explicitly needs the result of the postfix increment/decrement expression.</paragraph><heading level="3">Use of const</heading><paragraph>In APIs, use const whenever it makes sense. constexpr is a better choice for some uses of const.</paragraph><paragraph>Declared variables and parameters can be preceded by the keyword const to indicate the variables are not changed (e.g., const int foo). Class functions can have the const qualifier to indicate the function does not change the state of the class member variables (e.g., class Foo { int Bar(char c) const; };).</paragraph><paragraph>Easier for people to understand how variables are being used. Allows the compiler to do better type checking, and, conceivably, generate better code. Helps people convince themselves of program correctness because they know the functions they call are limited in how they can modify your variables. Helps people know what functions are safe to use without locks in multi-threaded programs.</paragraph><paragraph>const is viral: if you pass a const variable to a function, that function must have const in its prototype (or the variable will need a const_cast). This can be a particular problem when calling library functions.</paragraph><paragraph>We strongly recommend using const in APIs (i.e., on function parameters, methods, and non-local variables) wherever it is meaningful and accurate. This provides consistent, mostly compiler-verified documentation of what objects an operation can mutate. Having a consistent and reliable way to distinguish reads from writes is critical to writing thread-safe code, and is useful in many other contexts as well. In particular:</paragraph><list type="ul"><item>If a function guarantees that it will not modify an argument passed by reference or by pointer, the corresponding function parameter should be a reference-to-const (const T&) or pointer-to-const (const T*), respectively.</item><item>For a function parameter passed by value, const has no effect on the caller, thus is not recommended in function declarations. See TotW #109.</item><item>Declare methods to be const unless they alter the logical state of the object (or enable the user to modify that state, e.g., by returning a non-const reference, but that's rare), or they can't safely be invoked concurrently.</item></list><paragraph>Using const on local variables is neither encouraged nor discouraged.</paragraph><paragraph>All of a class's const operations should be safe to invoke concurrently with each other. If that's not feasible, the class must be clearly documented as "thread-unsafe".</paragraph><heading level="4">Where to put the const</heading><paragraph>Some people favor the form int const *foo to const int* foo. They argue that this is more readable because it's more consistent: it keeps the rule that const always follows the object it's describing. However, this consistency argument doesn't apply in codebases with few deeply-nested pointer expressions since most const expressions have only one const, and it applies to the underlying value. In such cases, there's no consistency to maintain. Putting the const first is arguably more readable, since it follows English in putting the "adjective" (const) before the "noun" (int).</paragraph><paragraph>That said, while we encourage putting const first, we do not require it. But be consistent with the code around you!</paragraph><heading level="3">Use of constexpr, constinit, and consteval</heading><paragraph>Use constexpr to define true constants or to ensure constant initialization. Use constinit to ensure constant initialization for non-constant variables.</paragraph><paragraph>Some variables can be declared constexpr to indicate the variables are true constants, i.e., fixed at compilation/link time. Some functions and constructors can be declared constexpr which enables them to be used in defining a constexpr variable. Functions can be declared consteval to restrict their use to compile time.</paragraph><paragraph>Use of constexpr enables definition of constants with floating-point expressions rather than just literals; definition of constants of user-defined types; and definition of constants with function calls.</paragraph><paragraph>Prematurely marking something as constexpr may cause migration problems if later on it has to be downgraded. Current restrictions on what is allowed in constexpr functions and constructors may invite obscure workarounds in these definitions.</paragraph><paragraph>constexpr definitions enable a more robust specification of the constant parts of an interface. Use constexpr to specify true constants and the functions that support their definitions. consteval may be used for code that must not be invoked at runtime. Avoid complexifying function definitions to enable their use with constexpr. Do not use constexpr or consteval to force inlining.</paragraph><heading level="3">Integer Types</heading><paragraph>Of the built-in C++ integer types, the only one used is int. If a program needs an integer type of a different size, use an exact-width integer type from <stdint.h>, such as int16_t. If you have a value that could ever be greater than or equal to 2^31, use a 64-bit type such as int64_t. Keep in mind that even if your value won't ever be too large for an int, it may be used in intermediate calculations which may require a larger type. When in doubt, choose a larger type.</paragraph><paragraph>C++ does not specify exact sizes for the integer types like int. Common sizes on contemporary architectures are 16 bits for short, 32 bits for int, 32 or 64 bits for long, and 64 bits for long long, but different platforms make different choices, in particular for long.</paragraph><paragraph>Uniformity of declaration.</paragraph><paragraph>The sizes of integral types in C++ can vary based on compiler and architecture.</paragraph><paragraph>The standard library header <stdint.h> defines types like int16_t, uint32_t, int64_t, etc. You should always use those in preference to short, unsigned long long, and the like, when you need a guarantee on the size of an integer. Prefer to omit the std:: prefix for these types, as the extra 5 characters do not merit the added clutter. Of the built-in integer types, only int should be used. When appropriate, you are welcome to use standard type aliases like size_t and ptrdiff_t.</paragraph><paragraph>We use int very often, for integers we know are not going to be too big, e.g., loop counters. Use plain old int for such things. You should assume that an int is at least 32 bits, but don't assume that it has more than 32 bits. If you need a 64-bit integer type, use int64_t or uint64_t.</paragraph><paragraph>For integers we know can be "big", use int64_t.</paragraph><paragraph>You should not use the unsigned integer types such as uint32_t, unless there is a valid reason such as representing a bit pattern rather than a number, or you need defined overflow modulo 2^N. In particular, do not use unsigned types to say a number will never be negative. Instead, use assertions for this.</paragraph><paragraph>If your code is a container that returns a size, be sure to use a type that will accommodate any possible usage of your container. When in doubt, use a larger type rather than a smaller type.</paragraph><paragraph>Use care when converting integer types. Integer conversions and promotions can cause undefined behavior, leading to security bugs and other problems.</paragraph><heading level="4">On Unsigned Integers</heading><paragraph>Unsigned integers are good for representing bitfields and modular arithmetic. Because of historical accident, the C++ standard also uses unsigned integers to represent the size of containers - many members of the standards body believe this to be a mistake, but it is effectively impossible to fix at this point. The fact that unsigned arithmetic doesn't model the behavior of a simple integer, but is instead defined by the standard to model modular arithmetic (wrapping around on overflow/underflow), means that a significant class of bugs cannot be diagnosed by the compiler. In other cases, the defined behavior impedes optimization.</paragraph><paragraph>That said, mixing signedness of integer types is responsible for an equally large class of problems. The best advice we can provide: try to use iterators and containers rather than pointers and sizes, try not to mix signedness, and try to avoid unsigned types (except for representing bitfields or modular arithmetic). Do not use an unsigned type merely to assert that a variable is non-negative.</paragraph><heading level="3">Floating-Point Types</heading><paragraph>Of the built-in C++ floating-point types, the only ones used are float and double. You may assume that these types represent IEEE-754 binary32 and binary64, respectively.</paragraph><paragraph>Do not use long double, as it gives non-portable results.</paragraph><heading level="3">Architecture Portability</heading><paragraph>Write architecture-portable code. Do not rely on CPU features specific to a single processor.</paragraph><heading level="3">Preprocessor Macros</heading><paragraph>Avoid defining macros, especially in headers; prefer inline functions, enums, and const variables. Name macros with a project-specific prefix. Do not use macros to define pieces of a C++ API.</paragraph><paragraph>Macros mean that the code you see is not the same as the code the compiler sees. This can introduce unexpected behavior, especially since macros have global scope.</paragraph><paragraph>The problems introduced by macros are especially severe when they are used to define pieces of a C++ API, and still more so for public APIs. Every error message from the compiler when developers incorrectly use that interface now must explain how the macros formed the interface. Refactoring and analysis tools have a dramatically harder time updating the interface. As a consequence, we specifically disallow using macros in this way. For example, avoid patterns like:</paragraph><code language="python">class WOMBAT_TYPE(Foo) {
  // ...

 public:
  EXPAND_PUBLIC_WOMBAT_API(Foo)

  EXPAND_WOMBAT_COMPARISONS(Foo, ==, <)
};
</code><paragraph>Luckily, macros are not nearly as necessary in C++ as they are in C. Instead of using a macro to inline performance-critical code, use an inline function. Instead of using a macro to store a constant, use a const variable. Instead of using a macro to "abbreviate" a long variable name, use a reference. Instead of using a macro to conditionally compile code ... well, don't do that at all (except, of course, for the #define guards to prevent double inclusion of header files). It makes testing much more difficult.</paragraph><paragraph>Macros can do things these other techniques cannot, and you do see them in the codebase, especially in the lower-level libraries. And some of their special features (like stringifying, concatenation, and so forth) are not available through the language proper. But before using a macro, consider carefully whether there's a non-macro way to achieve the same result. If you need to use a macro to define an interface, contact your project leads to request a waiver of this rule.</paragraph><paragraph>The following usage pattern will avoid many problems with macros; if you use macros, follow it whenever possible:</paragraph><list type="ul"><item>Don't define macros in a .h file.</item><item>#define macros right before you use them, and #undef them right after.</item><item>Do not just #undef an existing macro before replacing it with your own; instead, pick a name that's likely to be unique.</item><item>Try not to use macros that expand to unbalanced C++ constructs, or at least document that behavior well.</item><item>Prefer not using ## to generate function/class/variable names.</item></list><paragraph>Exporting macros from headers (i.e., defining them in a header without #undefing them before the end of the header) is extremely strongly discouraged. If you do export a macro from a header, it must have a globally unique name. To achieve this, it must be named with a prefix consisting of your project's namespace name (but upper case).</paragraph><heading level="3">0 and nullptr/NULL</heading><paragraph>Use nullptr for pointers, and '\0' for chars (and not the 0 literal).</paragraph><paragraph>For pointers (address values), use nullptr, as this provides type-safety.</paragraph><paragraph>Use '\0' for the null character. Using the correct type makes the code more readable.</paragraph><heading level="3">sizeof</heading><paragraph>Prefer sizeof(varname) to sizeof(type).</paragraph><paragraph>Use sizeof(varname) when you take the size of a particular variable. sizeof(varname) will update appropriately if someone changes the variable type either now or later. You may use sizeof(type) for code unrelated to any particular variable, such as code that manages an external or internal data format where a variable of an appropriate C++ type is not convenient.</paragraph><code language="code">MyStruct data;
memset(&data, 0, sizeof(data));
</code><code language="code">memset(&data, 0, sizeof(MyStruct));
</code><code language="javascript">if (raw_size < sizeof(int)) {
  LOG(ERROR) << "compressed record not big enough for count: " << raw_size;
  return false;
}
</code><heading level="3">Type Deduction (including auto)</heading><paragraph>Use type deduction only if it makes the code clearer to readers who aren't familiar with the project, or if it makes the code safer. Do not use it merely to avoid the inconvenience of writing an explicit type.</paragraph><paragraph>There are several contexts in which C++ allows (or even requires) types to be deduced by the compiler, rather than spelled out explicitly in the code:</paragraph><code language="code">template <typename T>
void f(T t);

f(0);  // Invokes f<int>(0)</code><code language="code">auto a = 42;  // a is an int
auto& b = a;  // b is an int&
auto c = b;   // c is an int
auto d{42};   // d is an int, not a std::initializer_list<int>
</code><code language="code">auto f() { return 0; }  // The return type of f is int</code><code language="code">// Sort `vec` in decreasing order
std::sort(vec.begin(), vec.end(), [](auto lhs, auto rhs) { return lhs > rhs; });</code><code language="code">[x = 42, y = "foo"] { ... }  // x is an int, and y is a const char*</code><code language="javascript">auto [iter, success] = my_map.insert({key, value});
if (!success) {
  iter->second = value;
}</code><paragraph>(These summaries omit many details and caveats; see the links for further information.)</paragraph><list type="ul"><item>C++ type names can be long and cumbersome, especially when they involve templates or namespaces.</item><item>When a C++ type name is repeated within a single declaration or a small code region, the repetition may not be aiding readability.</item><item>It is sometimes safer to let the type be deduced, since that avoids the possibility of unintended copies or type conversions.</item></list><paragraph>C++ code is usually clearer when types are explicit, especially when type deduction would depend on information from distant parts of the code. In expressions like:</paragraph><code language="code">auto foo = x.add_foo();
auto i = y.Find(key);
</code><paragraph>it may not be obvious what the resulting types are if the type of y isn't very well known, or if y was declared many lines earlier.</paragraph><paragraph>Programmers have to understand when type deduction will or won't produce a reference type, or they'll get copies when they didn't mean to.</paragraph><paragraph>If a deduced type is used as part of an interface, then a programmer might change its type while only intending to change its value, leading to a more radical API change than intended.</paragraph><paragraph>The fundamental rule is: use type deduction only to make the code clearer or safer, and do not use it merely to avoid the inconvenience of writing an explicit type. When judging whether the code is clearer, keep in mind that your readers are not necessarily on your team, or familiar with your project, so types that you and your reviewer experience as unnecessary clutter will very often provide useful information to others. For example, you can assume that the return type of make_unique<Foo>() is obvious, but the return type of MyWidgetFactory() probably isn't.</paragraph><paragraph>These principles apply to all forms of type deduction, but the details vary, as described in the following sections.</paragraph><heading level="4">Function template argument deduction</heading><paragraph>Function template argument deduction is almost always OK. Type deduction is the expected default way of interacting with function templates, because it allows function templates to act like infinite sets of ordinary function overloads. Consequently, function templates are almost always designed so that template argument deduction is clear and safe, or doesn't compile.</paragraph><heading level="4">Local variable type deduction</heading><paragraph>For local variables, you can use type deduction to make the code clearer by eliminating type information that is obvious or irrelevant, so that the reader can focus on the meaningful parts of the code:</paragraph><code language="code">std::unique_ptr<WidgetWithBellsAndWhistles> widget =
    std::make_unique<WidgetWithBellsAndWhistles>(arg1, arg2);
absl::flat_hash_map<std::string,
                    std::unique_ptr<WidgetWithBellsAndWhistles>>::const_iterator
    it = my_map_.find(key);
std::array<int, 6> numbers = {4, 8, 15, 16, 23, 42};</code><code language="code">auto widget = std::make_unique<WidgetWithBellsAndWhistles>(arg1, arg2);
auto it = my_map_.find(key);
std::array numbers = {4, 8, 15, 16, 23, 42};</code><paragraph>Types sometimes contain a mixture of useful information and boilerplate, such as it in the example above: it's obvious that the type is an iterator, and in many contexts the container type and even the key type aren't relevant, but the type of the values is probably useful. In such situations, it's often possible to define local variables with explicit types that convey the relevant information:</paragraph><code language="javascript">if (auto it = my_map_.find(key); it != my_map_.end()) {
  WidgetWithBellsAndWhistles& widget = *it->second;
  // Do stuff with `widget`
}</code><paragraph>If the type is a template instance, and the parameters are boilerplate but the template itself is informative, you can use class template argument deduction to suppress the boilerplate. However, cases where this actually provides a meaningful benefit are quite rare. Note that class template argument deduction is also subject to a separate style rule.</paragraph><paragraph>Do not use decltype(auto) if a simpler option will work; because it's a fairly obscure feature, it has a high cost in code clarity.</paragraph><heading level="4">Return type deduction</heading><paragraph>Use return type deduction (for both functions and lambdas) only if the function body has a very small number of return statements, and very little other code, because otherwise the reader may not be able to tell at a glance what the return type is. Furthermore, use it only if the function or lambda has a very narrow scope, because functions with deduced return types don't define abstraction boundaries: the implementation is the interface. In particular, public functions in header files should almost never have deduced return types.</paragraph><heading level="4">Parameter type deduction</heading><paragraph>auto parameter types for lambdas should be used with caution, because the actual type is determined by the code that calls the lambda, rather than by the definition of the lambda. Consequently, an explicit type will almost always be clearer unless the lambda is explicitly called very close to where it's defined (so that the reader can easily see both), or the lambda is passed to an interface so well-known that it's obvious what arguments it will eventually be called with (e.g., the std::sort example above).</paragraph><heading level="4">Lambda init captures</heading><paragraph>Init captures are covered by a more specific style rule, which largely supersedes the general rules for type deduction.</paragraph><heading level="4">Structured bindings</heading><paragraph>Unlike other forms of type deduction, structured bindings can actually give the reader additional information, by giving meaningful names to the elements of a larger object. This means that a structured binding declaration may provide a net readability improvement over an explicit type, even in cases where auto would not. Structured bindings are especially beneficial when the object is a pair or tuple (as in the insert example above), because they don't have meaningful field names to begin with, but note that you generally shouldn't use pairs or tuples unless a pre-existing API like insert forces you to.</paragraph><paragraph>If the object being bound is a struct, it may sometimes be helpful to provide names that are more specific to your usage, but keep in mind that this may also mean the names are less recognizable to your reader than the field names. We recommend using a comment to indicate the name of the underlying field, if it doesn't match the name of the binding, using the same syntax as for function parameter comments:</paragraph><code language="code">auto [/*field_name1=*/bound_name1, /*field_name2=*/bound_name2] = ...</code><paragraph>As with function parameter comments, this can enable tools to detect if you get the order of the fields wrong.</paragraph><heading level="3">Class Template Argument Deduction</heading><paragraph>Use class template argument deduction only with templates that have explicitly opted into supporting it.</paragraph><paragraph>Class template argument deduction (often abbreviated "CTAD") occurs when a variable is declared with a type that names a template, and the template argument list is not provided (not even empty angle brackets):</paragraph><code language="code">std::array a = {1, 2, 3};  // `a` is a std::array<int, 3></code><paragraph>The compiler deduces the arguments from the initializer using the template's "deduction guides", which can be explicit or implicit.</paragraph><paragraph>Explicit deduction guides look like function declarations with trailing return types, except that there's no leading auto, and the function name is the name of the template. For example, the above example relies on this deduction guide for std::array:</paragraph><code language="javascript">namespace std {
template <class T, class... U>
array(T, U...) -> std::array<T, 1 + sizeof...(U)>;
}</code><paragraph>Constructors in a primary template (as opposed to a template specialization) also implicitly define deduction guides.</paragraph><paragraph>When you declare a variable that relies on CTAD, the compiler selects a deduction guide using the rules of constructor overload resolution, and that guide's return type becomes the type of the variable.</paragraph><paragraph>CTAD can sometimes allow you to omit boilerplate from your code.</paragraph><paragraph>The implicit deduction guides that are generated from constructors may have undesirable behavior, or be outright incorrect. This is particularly problematic for constructors written before CTAD was introduced in C++17, because the authors of those constructors had no way of knowing about (much less fixing) any problems that their constructors would cause for CTAD. Furthermore, adding explicit deduction guides to fix those problems might break any existing code that relies on the implicit deduction guides.</paragraph><paragraph>CTAD also suffers from many of the same drawbacks as auto, because they are both mechanisms for deducing all or part of a variable's type from its initializer. CTAD does give the reader more information than auto, but it also doesn't give the reader an obvious cue that information has been omitted.</paragraph><paragraph>Do not use CTAD with a given template unless the template's maintainers have opted into supporting use of CTAD by providing at least one explicit deduction guide (all templates in the std namespace are also presumed to have opted in). This should be enforced with a compiler warning if available.</paragraph><paragraph>Uses of CTAD must also follow the general rules on Type deduction.</paragraph><heading level="3">Designated Initializers</heading><paragraph>Use designated initializers only in their C++20-compliant form.</paragraph><paragraph>Designated initializers are a syntax that allows for initializing an aggregate ("plain old struct") by naming its fields explicitly:</paragraph><code language="javascript">  struct Point {
    float x = 0.0;
    float y = 0.0;
    float z = 0.0;
  };

  Point p = {
    .x = 1.0,
    .y = 2.0,
    // z will be 0.0
  };</code><paragraph>The explicitly listed fields will be initialized as specified, and others will be initialized in the same way they would be in a traditional aggregate initialization expression like Point{1.0, 2.0}.</paragraph><paragraph>Designated initializers can make for convenient and highly readable aggregate expressions, especially for structs with less straightforward ordering of fields than the Point example above.</paragraph><paragraph>While designated initializers have long been part of the C standard and supported by C++ compilers as an extension, they were not supported by C++ prior to C++20.</paragraph><paragraph>The rules in the C++ standard are stricter than in C and compiler extensions, requiring that the designated initializers appear in the same order as the fields appear in the struct definition. So in the example above, it is legal according to C++20 to initialize x and then z, but not y and then x.</paragraph><paragraph>Use designated initializers only in the form that is compatible with the C++20 standard: with initializers in the same order as the corresponding fields appear in the struct definition.</paragraph><heading level="3">Lambda Expressions</heading><paragraph>Use lambda expressions where appropriate. Prefer explicit captures when the lambda will escape the current scope.</paragraph><paragraph>Lambda expressions are a concise way of creating anonymous function objects. They're often useful when passing functions as arguments. For example:</paragraph><code language="javascript">std::sort(v.begin(), v.end(), [](int x, int y) {
  return Weight(x) < Weight(y);
});
</code><paragraph>They further allow capturing variables from the enclosing scope either explicitly by name, or implicitly using a default capture. Explicit captures require each variable to be listed, as either a value or reference capture:</paragraph><code language="javascript">int weight = 3;
int sum = 0;
// Captures `weight` by value and `sum` by reference.
std::for_each(v.begin(), v.end(), [weight, &sum](int x) {
  sum += weight * x;
});
</code><paragraph>Default captures implicitly capture any variable referenced in the lambda body, including this if any members are used:</paragraph><code language="javascript">const std::vector<int> lookup_table = ...;
std::vector<int> indices = ...;
// Captures `lookup_table` by reference, sorts `indices` by the value
// of the associated element in `lookup_table`.
std::sort(indices.begin(), indices.end(), [&](int a, int b) {
  return lookup_table[a] < lookup_table[b];
});
</code><paragraph>A variable capture can also have an explicit initializer, which can be used for capturing move-only variables by value, or for other situations not handled by ordinary reference or value captures:</paragraph><code language="javascript">std::unique_ptr<Foo> foo = ...;
[foo = std::move(foo)] () {
  ...
}</code><paragraph>Such captures (often called "init captures" or "generalized lambda captures") need not actually "capture" anything from the enclosing scope, or even have a name from the enclosing scope; this syntax is a fully general way to define members of a lambda object:</paragraph><code language="javascript">[foo = std::vector<int>({1, 2, 3})] () {
  ...
}</code><paragraph>The type of a capture with an initializer is deduced using the same rules as auto.</paragraph><list type="ul"><item>Lambdas are much more concise than other ways of defining function objects to be passed to STL algorithms, which can be a readability improvement.</item><item>Appropriate use of default captures can remove redundancy and highlight important exceptions from the default.</item><item>Lambdas, std::function, and std::bind can be used in combination as a general purpose callback mechanism; they make it easy to write functions that take bound functions as arguments.</item></list><list type="ul"><item>Variable capture in lambdas can be a source of dangling-pointer bugs, particularly if a lambda escapes the current scope.</item><item>Default captures by value can be misleading because they do not prevent dangling-pointer bugs. Capturing a pointer by value doesn't cause a deep copy, so it often has the same lifetime issues as capture by reference. This is especially confusing when capturing this by value, since the use of this is often implicit.</item><item>Captures actually declare new variables (whether or not the captures have initializers), but they look nothing like any other variable declaration syntax in C++. In particular, there's no place for the variable's type, or even an auto placeholder (although init captures can indicate it indirectly, e.g., with a cast). This can make it difficult to even recognize them as declarations.</item><item>Init captures inherently rely on type deduction, and suffer from many of the same drawbacks as auto, with the additional problem that the syntax doesn't even cue the reader that deduction is taking place.</item><item>It's possible for use of lambdas to get out of hand; very long nested anonymous functions can make code harder to understand.</item></list><list type="ul"><item>Use lambda expressions where appropriate, with formatting as described below.</item><item>Prefer explicit captures if the lambda may escape the current scope. For example, instead of: { Foo foo; ... executor->Schedule([&] { Frobnicate(foo); }) ... } // BAD! The fact that the lambda makes use of a reference to `foo` and // possibly `this` (if `Frobnicate` is a member function) may not be // apparent on a cursory inspection. If the lambda is invoked after // the function returns, that would be bad, because both `foo` // and the enclosing object could have been destroyed. prefer to write: { Foo foo; ... executor->Schedule([&foo] { Frobnicate(foo); }) ... } // BETTER - The compile will fail if `Frobnicate` is a member // function, and it's clearer that `foo` is dangerously captured by // reference.</item><item>Use default capture by reference ([&]) only when the lifetime of the lambda is obviously shorter than any potential captures.</item><item>Use default capture by value ([=]) only as a means of binding a few variables for a short lambda, where the set of captured variables is obvious at a glance, and which does not result in capturing this implicitly. (That means that a lambda that appears in a non-static class member function and refers to non-static class members in its body must capture this explicitly or via [&].) Prefer not to write long or complex lambdas with default capture by value.</item><item>Use captures only to actually capture variables from the enclosing scope. Do not use captures with initializers to introduce new names, or to substantially change the meaning of an existing name. Instead, declare a new variable in the conventional way and then capture it, or avoid the lambda shorthand and define a function object explicitly.</item><item>See the section on type deduction for guidance on specifying the parameter and return types.</item></list><code language="javascript">{
  Foo foo;
  ...
  executor->Schedule([&] { Frobnicate(foo); })
  ...
}
// BAD! The fact that the lambda makes use of a reference to `foo` and
// possibly `this` (if `Frobnicate` is a member function) may not be
// apparent on a cursory inspection. If the lambda is invoked after
// the function returns, that would be bad, because both `foo`
// and the enclosing object could have been destroyed.
</code><code language="javascript">{
  Foo foo;
  ...
  executor->Schedule([&foo] { Frobnicate(foo); })
  ...
}
// BETTER - The compile will fail if `Frobnicate` is a member
// function, and it's clearer that `foo` is dangerously captured by
// reference.
</code><paragraph>Avoid complicated template programming.</paragraph><paragraph>Template metaprogramming refers to a family of techniques that exploit the fact that the C++ template instantiation mechanism is Turing complete and can be used to perform arbitrary compile-time computation in the type domain.</paragraph><paragraph>Template metaprogramming allows extremely flexible interfaces that are type safe and high performance. Facilities like GoogleTest, std::tuple, std::function, and Boost.Spirit would be impossible without it.</paragraph><paragraph>The techniques used in template metaprogramming are often obscure to anyone but language experts. Code that uses templates in complicated ways is often unreadable, and is hard to debug or maintain.</paragraph><paragraph>Template metaprogramming often leads to extremely poor compile time error messages: even if an interface is simple, the complicated implementation details become visible when the user does something wrong.</paragraph><paragraph>Template metaprogramming interferes with large scale refactoring by making the job of refactoring tools harder. First, the template code is expanded in multiple contexts, and it's hard to verify that the transformation makes sense in all of them. Second, some refactoring tools work with an AST that only represents the structure of the code after template expansion. It can be difficult to automatically work back to the original source construct that needs to be rewritten.</paragraph><paragraph>Template metaprogramming sometimes allows cleaner and easier-to-use interfaces than would be possible without it, but it's also often a temptation to be overly clever. It's best used in a small number of low level components where the extra maintenance burden is spread out over a large number of uses.</paragraph><paragraph>Think twice before using template metaprogramming or other complicated template techniques; think about whether the average member of your team will be able to understand your code well enough to maintain it after you switch to another project, or whether a non-C++ programmer or someone casually browsing the codebase will be able to understand the error messages or trace the flow of a function they want to call. If you're using recursive template instantiations or type lists or metafunctions or expression templates, or relying on SFINAE or on the sizeof trick for detecting function overload resolution, then there's a good chance you've gone too far.</paragraph><paragraph>If you use template metaprogramming, you should expect to put considerable effort into minimizing and isolating the complexity. You should hide metaprogramming as an implementation detail whenever possible, so that user-facing headers are readable, and you should make sure that tricky code is especially well commented. You should carefully document how the code is used, and you should say something about what the "generated" code looks like. Pay extra attention to the error messages that the compiler emits when users make mistakes. The error messages are part of your user interface, and your code should be tweaked as necessary so that the error messages are understandable and actionable from a user point of view.</paragraph><heading level="3">Concepts and Constraints</heading><paragraph>Use concepts sparingly. In general, concepts and constraints should only be used in cases where templates would have been used prior to C++20. Avoid introducing new concepts in headers, unless the headers are marked as internal to the library. Do not define concepts that are not enforced by the compiler. Prefer constraints over template metaprogramming, and avoid the template<Concept T> syntax; instead, use the requires(Concept<T>) syntax.</paragraph><paragraph>The concept keyword is a new mechanism for defining requirements (such as type traits or interface specifications) for a template parameter. The requires keyword provides mechanisms for placing anonymous constraints on templates and verifying that constraints are satisfied at compile time. Concepts and constraints are often used together, but can be also used independently.</paragraph><list type="ul"><item>Concepts allow the compiler to generate much better error messages when templates are involved, which can reduce confusion and significantly improve the development experience.</item><item>Concepts can reduce the boilerplate necessary for defining and using compile-time constraints, often increasing the clarity of the resulting code.</item><item>Constraints provide some capabilities that are difficult to achieve with templates and SFINAE techniques.</item></list><list type="ul"><item>As with templates, concepts can make code significantly more complex and difficult to understand.</item><item>Concept syntax can be confusing to readers, as concepts appear similar to class types at their usage sites.</item><item>Concepts, especially at API boundaries, increase code coupling, rigidity, and ossification.</item><item>Concepts and constraints can replicate logic from a function body, resulting in code duplication and increased maintenance costs.</item><item>Concepts muddy the source of truth for their underlying contracts, as they are standalone named entities that can be utilized in multiple locations, all of which evolve separately from each other. This can cause the stated and implied requirements to diverge over time.</item><item>Concepts and constraints affect overload resolution in novel and non-obvious ways.</item><item>As with SFINAE, constraints make it harder to refactor code at scale.</item></list><paragraph>Predefined concepts in the standard library should be preferred to type traits, when equivalent ones exist. (e.g., if std::is_integral_v would have been used before C++20, then std::integral should be used in C++20 code.) Similarly, prefer modern constraint syntax (via requires(Condition)). Avoid legacy template metaprogramming constructs (such as std::enable_if<Condition>) as well as the template<Concept T> syntax.</paragraph><paragraph>Do not manually re-implement any existing concepts or traits. For example, use requires(std::default_initializable<T>) instead of requires(requires { T v; }) or the like.</paragraph><paragraph>New concept declarations should be rare, and only defined internally within a library, such that they are not exposed at API boundaries. More generally, do not use concepts or constraints in cases where you wouldn't use their legacy template equivalents in C++17.</paragraph><paragraph>Do not define concepts that duplicate the function body, or impose requirements that would be insignificant or obvious from reading the body of the code or the resulting error messages. For example, avoid the following:</paragraph><code language="code">template <typename T>     // Bad - redundant with negligible benefit
concept Addable = std::copyable<T> && requires(T a, T b) { a + b; };
template <Addable T>
T Add(T x, T y, T z) { return x + y + z; }
</code><paragraph>Instead, prefer to leave code as an ordinary template unless you can demonstrate that concepts result in significant improvement for that particular case, such as in the resulting error messages for a deeply nested or non-obvious requirement.</paragraph><paragraph>Concepts should be statically verifiable by the compiler. Do not use any concept whose primary benefits would come from a semantic (or otherwise unenforced) constraint. Requirements that are unenforced at compile time should instead be imposed via other mechanisms such as comments, assertions, or tests.</paragraph><heading level="3">C++20 modules</heading><paragraph>Do not use C++20 Modules.</paragraph><paragraph>C++20 introduces "modules", a new language feature designed as an alternative to textual inclusion of header files. It introduces three new keywords to support this: module, export, and import.</paragraph><paragraph>Modules are a big shift in how C++ is written and compiled, and we are still assessing how they may fit into Google's C++ ecosystem in the future. Furthermore, they are not currently well-supported by our build systems, compilers, and other tooling, and need further exploration as to the best practices when writing and using them.</paragraph><heading level="3">Coroutines</heading><paragraph>Only use C++20 coroutines via libraries that have been approved by your project leads.</paragraph><paragraph>C++20 introduced coroutines: functions that can suspend and resume executing later. They are especially convenient for asynchronous programming, where they can provide substantial improvements over traditional callback-based frameworks.</paragraph><paragraph>Unlike most other programming languages (Kotlin, Rust, TypeScript, etc.), C++ does not provide a concrete implementation of coroutines. Instead, it requires users to implement their own awaitable type (using a promise type) which determines coroutine parameter types, how coroutines are executed, and allows running user-defined code during different stages of their execution.</paragraph><list type="ul"><item>Coroutines can be used to implement safe and efficient libraries suited for specific tasks, such as asynchronous programming.</item><item>Coroutines are syntactically almost identical to non-coroutine functions, which can make them substantially more readable than alternatives.</item><item>The high degree of customization makes it possible to insert more detailed debugging information into coroutines, compared to alternatives.</item></list><list type="ul"><item>There is no standard coroutine promise type, and each user-defined implementation is likely going to be unique in some aspect.</item><item>Because of load-bearing interactions between the return type, the various customizable hooks in the promise type, and compiler-generated code, coroutine semantics are extremely difficult to deduce from reading user code.</item><item>The many customizable aspects of coroutines introduce a large number of pitfalls, especially around dangling references and race conditions.</item></list><paragraph>In summary, designing a high-quality and interoperable coroutine library requires a large amount of difficult work, careful thought, and extensive documentation.</paragraph><paragraph>Use only coroutine libraries that have been approved for project-wide use by your project leads. Do not roll your own promise or awaitable types.</paragraph><heading level="3">Boost</heading><paragraph>Use only approved libraries from the Boost library collection.</paragraph><paragraph>The Boost library collection is a popular collection of peer-reviewed, free, open-source C++ libraries.</paragraph><paragraph>Boost code is generally very high-quality, is widely portable, and fills many important gaps in the C++ standard library, such as type traits and better binders.</paragraph><paragraph>Some Boost libraries encourage coding practices which can hamper readability, such as metaprogramming and other advanced template techniques, and an excessively "functional" style of programming.</paragraph><paragraph>In order to maintain a high level of readability for all contributors who might read and maintain code, we only allow an approved subset of Boost features. Currently, the following libraries are permitted:</paragraph><paragraph>We are actively considering adding other Boost features to the list, so this list may be expanded in the future.</paragraph><heading level="3">Disallowed standard library features</heading><paragraph>As with Boost, some modern C++ library functionality encourages coding practices that hamper readability — for example by removing checked redundancy (such as type names) that may be helpful to readers, or by encouraging template metaprogramming. Other extensions duplicate functionality available through existing mechanisms, which may lead to confusion and conversion costs.</paragraph><paragraph>The following C++ standard library features may not be used:</paragraph><list type="ul"><item>Compile-time rational numbers (<ratio>), because of concerns that it's tied to a more template-heavy interface style.</item><item>The <cfenv> and <fenv.h> headers, because many compilers do not support those features reliably.</item><item>The <filesystem> header, which does not have sufficient support for testing, and suffers from inherent security vulnerabilities.</item></list><heading level="3">Nonstandard Extensions</heading><paragraph>Nonstandard extensions to C++ may not be used unless otherwise specified.</paragraph><paragraph>Compilers support various extensions that are not part of standard C++. Such extensions include GCC's __attribute__, intrinsic functions such as __builtin_prefetch or SIMD, #pragma, inline assembly, __COUNTER__, __PRETTY_FUNCTION__, compound statement expressions (e.g., foo = ({ int x; Bar(&x); x }), variable-length arrays and alloca(), and the "Elvis Operator" a?:b.</paragraph><list type="ul"><item>Nonstandard extensions may provide useful features that do not exist in standard C++.</item><item>Important performance guidance to the compiler can only be specified using extensions.</item></list><list type="ul"><item>Nonstandard extensions do not work in all compilers. Use of nonstandard extensions reduces portability of code.</item><item>Even if they are supported in all targeted compilers, the extensions are often not well-specified, and there may be subtle behavior differences between compilers.</item><item>Nonstandard extensions add features to the language that a reader must know to understand the code.</item><item>Nonstandard extensions require additional work to port across architectures.</item></list><paragraph>Do not use nonstandard extensions. You may use portability wrappers that are implemented using nonstandard extensions, so long as those wrappers are provided by a designated project-wide portability header.</paragraph><heading level="3">Aliases</heading><paragraph>Public aliases are for the benefit of an API's user, and should be clearly documented.</paragraph><paragraph>There are several ways to create names that are aliases of other entities:</paragraph><code language="code">using Bar = Foo;
typedef Foo Bar;  // But prefer `using` in C++ code.
using ::other_namespace::Foo;
using enum MyEnumType;  // Creates aliases for all enumerators in MyEnumType.
</code><paragraph>In new code, using is preferable to typedef, because it provides a more consistent syntax with the rest of C++ and works with templates.</paragraph><paragraph>Like other declarations, aliases declared in a header file are part of that header's public API unless they're in a function definition, in the private portion of a class, or in an explicitly-marked internal namespace. Aliases in such areas or in .cc files are implementation details (because client code can't refer to them), and are not restricted by this rule.</paragraph><list type="ul"><item>Aliases can improve readability by simplifying a long or complicated name.</item><item>Aliases can reduce duplication by naming in one place a type used repeatedly in an API, which might make it easier to change the type later.</item></list><list type="ul"><item>When placed in a header where client code can refer to them, aliases increase the number of entities in that header's API, increasing its complexity.</item><item>Clients can easily rely on unintended details of public aliases, making changes difficult.</item><item>It can be tempting to create a public alias that is only intended for use in the implementation, without considering its impact on the API, or on maintainability.</item><item>Aliases can create risk of name collisions.</item><item>Aliases can reduce readability by giving a familiar construct an unfamiliar name.</item><item>Type aliases can create an unclear API contract: it is unclear whether the alias is guaranteed to be identical to the type it aliases, to have the same API, or only to be usable in specified narrow ways.</item></list><paragraph>Don't put an alias in your public API just to save typing in the implementation; do so only if you intend it to be used by your clients.</paragraph><paragraph>When defining a public alias, document the intent of the new name, including whether it is guaranteed to always be the same as the type it's currently aliased to, or whether a more limited compatibility is intended. This lets the user know whether they can treat the types as substitutable or whether more specific rules must be followed, and can help the implementation retain some degree of freedom to change the alias.</paragraph><paragraph>Don't put namespace aliases in your public API. (See also Namespaces.)</paragraph><paragraph>For example, these aliases document how they are intended to be used in client code:</paragraph><code language="javascript">namespace mynamespace {
// Used to store field measurements. DataPoint may change from Bar* to some internal type.
// Client code should treat it as an opaque pointer.
using DataPoint = ::foo::Bar*;

// A set of measurements. Just an alias for user convenience.
using TimeSeries = std::unordered_set<DataPoint, std::hash<DataPoint>, DataPointComparator>;
}  // namespace mynamespace
</code><paragraph>These aliases don't document intended use, and half of them aren't meant for client use:</paragraph><code language="javascript">namespace mynamespace {
// Bad: none of these say how they should be used.
using DataPoint = ::foo::Bar*;
using ::std::unordered_set;  // Bad: just for local convenience
using ::std::hash;           // Bad: just for local convenience
typedef unordered_set<DataPoint, hash<DataPoint>, DataPointComparator> TimeSeries;
}  // namespace mynamespace
</code><paragraph>However, local convenience aliases are fine in function definitions, private sections of classes, explicitly-marked internal namespaces, and in .cc files:</paragraph><code language="code">// In a .cc file
using ::foo::Bar;
</code><heading level="3">Switch Statements</heading><paragraph>If not conditional on an enumerated value, switch statements should always have a default case (in the case of an enumerated value, the compiler will warn you if any values are not handled). If the default case should never execute, treat this as an error. For example:</paragraph><code language="javascript">switch (var) {
  case 0: {
    ...
    break;
  }
  case 1: {
    ...
    break;
  }
  default: {
    LOG(FATAL) << "Invalid value in switch statement: " << var;
  }
}
</code><paragraph>Fall-through from one case label to another must be annotated using the [[fallthrough]]; attribute. [[fallthrough]]; should be placed at a point of execution where a fall-through to the next case label occurs. A common exception is consecutive case labels without intervening code, in which case no annotation is needed.</paragraph><code language="javascript">switch (x) {
  case 41:  // No annotation needed here.
  case 43:
    if (dont_be_picky) {
      // Use this instead of or along with annotations in comments.
      [[fallthrough]];
    } else {
      CloseButNoCigar();
      break;
    }
  case 42:
    DoSomethingSpecial();
    [[fallthrough]];
  default:
    DoSomethingGeneric();
    break;
}
</code><heading level="2">Inclusive Language</heading><paragraph>In all code, including naming and comments, use inclusive language and avoid terms that other programmers might find disrespectful or offensive (such as "master" and "slave", "blacklist" and "whitelist", or "redline"), even if the terms also have an ostensibly neutral meaning. Similarly, use gender-neutral language unless you're referring to a specific person (and using their pronouns). For example, use "they"/"them"/"their" for people of unspecified gender (even when singular), and "it"/"its" for software, computers, and other things that aren't people.</paragraph><heading level="2">Naming</heading><paragraph>The most important consistency rules are those that govern naming. The style of a name immediately informs us what sort of thing the named entity is: a type, a variable, a function, a constant, a macro, etc., without requiring us to search for the declaration of that entity. The pattern-matching engine in our brains relies a great deal on these naming rules.</paragraph><paragraph>Style rules about naming are pretty arbitrary, but we feel that consistency is more important than individual preferences in this area, so regardless of whether you find them sensible or not, the rules are the rules.</paragraph><paragraph>For the purposes of the naming rules below, a "word" is anything that you would write in English without internal spaces. Either words are all lowercase, with underscores between words ("snake_case"), or words are mixed case with the first letter of each word capitalized ("camelCase" or "PascalCase").</paragraph><heading level="3">Choosing Names</heading><paragraph>Give things names that make their purpose or intent understandable to a new reader, even someone on a different team than the owners. Do not worry about saving horizontal space as it is far more important to make your code immediately understandable by a new reader.</paragraph><paragraph>Consider the context in which the name will be used. A name should be descriptive even if it is used far from the code that makes it available for use. However, a name should not distract the reader by repeating information that's present in the immediate context. Generally, this means that descriptiveness should be proportional to the name's scope of visibility. A free function declared in a header should probably mention the header's library, while a local variable probably shouldn't explain what function it's within.</paragraph><paragraph>Minimize the use of abbreviations that would likely be unknown to someone outside your project (especially acronyms and initialisms). Do not abbreviate by deleting letters within a word. When an abbreviation is used, prefer to capitalize it as a single "word", e.g., StartRpc() rather than StartRPC(). As a rule of thumb, an abbreviation is probably OK if it's listed in Wikipedia. Note that certain universally-known abbreviations are OK, such as i for a loop index and T for a template parameter.</paragraph><paragraph>The names you see most frequently are not like most names; a small number of "vocabulary" names are reused so widely that they are always in context. These names tend to be short or even abbreviated and their full meaning comes from explicit long-form documentation rather than from just comments on their definition and the words within the names. For example, absl::Status has a dedicated page in a devguide, documenting its proper use. You probably won't define new vocabulary names very often, but if you do, get additional design review to make sure the chosen names work well when used widely.</paragraph><code language="javascript">class MyClass {
 public:
  int CountFooErrors(const std::vector<Foo>& foos) {
    int n = 0;  // Clear meaning given limited scope and context
    for (const auto& foo : foos) {
      ...
      ++n;
    }
    return n;
  }
  // Function comment doesn't need to explain that this returns non-OK on
  // failure as that is implied by the `absl::Status` return type, but it
  // might document behavior for some specific codes.
  absl::Status DoSomethingImportant() {
    std::string fqdn = ...;  // Well-known abbreviation for Fully Qualified Domain Name
    return absl::OkStatus();
  }
 private:
  const int kMaxAllowedConnections = ...;  // Clear meaning within context
};
</code><code language="javascript">class MyClass {
 public:
  int CountFooErrors(const std::vector<Foo>& foos) {
    int total_number_of_foo_errors = 0;  // Overly verbose given limited scope and context
    for (int foo_index = 0; foo_index < foos.size(); ++foo_index) {  // Use idiomatic `i`
      ...
      ++total_number_of_foo_errors;
    }
    return total_number_of_foo_errors;
  }
  // A return type with a generic name is unclear without widespread education.
  Result DoSomethingImportant() {
    int cstmr_id = ...;  // Deletes internal letters
  }
 private:
  const int kNum = ...;  // Unclear meaning within broad scope
};
</code><heading level="3">File Names</heading><paragraph>Filenames should be all lowercase and can include underscores (_) or dashes (-). Follow the convention that your project uses. If there is no consistent local pattern to follow, prefer "_".</paragraph><paragraph>Examples of acceptable file names:</paragraph><list type="ul"><item>my_useful_class.cc</item><item>my-useful-class.cc</item><item>myusefulclass.cc</item><item>myusefulclass_test.cc // _unittest and _regtest are deprecated.</item></list><paragraph>C++ files should have a .cc filename extension, and header files should have a .h extension. Files that rely on being textually included at specific points should end in .inc (see also the section on self-contained headers).</paragraph><paragraph>Do not use filenames that already exist in /usr/include, such as db.h.</paragraph><paragraph>In general, make your filenames very specific. For example, use http_server_logs.h rather than logs.h. A very common case is to have a pair of files called, e.g., foo_bar.h and foo_bar.cc, defining a class called FooBar.</paragraph><heading level="3">Type Names</heading><paragraph>Type names start with a capital letter and have a capital letter for each new word, with no underscores: MyExcitingClass, MyExcitingEnum.</paragraph><paragraph>The names of all types — classes, structs, type aliases, enums, and type template parameters — have the same naming convention. Type names should start with a capital letter and have a capital letter for each new word. No underscores. For example:</paragraph><code language="code">// classes and structs
class UrlTable { ...
class UrlTableTester { ...
struct UrlTableProperties { ...

// typedefs
typedef hash_map<UrlTableProperties *, std::string> PropertiesMap;

// using aliases
using PropertiesMap = hash_map<UrlTableProperties *, std::string>;

// enums
enum class UrlTableError { ...
</code><heading level="3">Concept Names</heading><paragraph>Concept names follow the same rules as</paragraph><paragraph>.</paragraph><heading level="3">Variable Names</heading><paragraph>The names of variables (including function parameters) and data members are snake_case (all lowercase, with underscores between words). Data members of classes (but not structs) additionally have trailing underscores. For instance: a_local_variable, a_struct_data_member, a_class_data_member_.</paragraph><heading level="4">Common Variable names</heading><paragraph>For example:</paragraph><code language="code">std::string table_name;  // OK - snake_case.
</code><code language="code">std::string tableName;   // Bad - mixed case.
</code><heading level="4">Class Data Members</heading><paragraph>Data members of classes, both static and non-static, are named like ordinary nonmember variables, but with a trailing underscore. The exception to this is static constant class members, which should follow the rules for naming constants.</paragraph><code language="javascript">class TableInfo {
 public:
  ...
  static const int kTableVersion = 3;  // OK - constant naming.
  ...

 private:
  std::string table_name_;             // OK - underscore at end.
  static Pool<TableInfo>* pool_;       // OK.
};
</code><heading level="4">Struct Data Members</heading><paragraph>Data members of structs, both static and non-static, are named like ordinary nonmember variables. They do not have the trailing underscores that data members in classes have.</paragraph><code language="javascript">struct UrlTableProperties {
  std::string name;
  int num_entries;
  static Pool<UrlTableProperties>* pool;
};
</code><paragraph>See Structs vs. Classes for a discussion of when to use a struct versus a class.</paragraph><heading level="3">Constant Names</heading><paragraph>Variables declared constexpr or const, and whose value is fixed for the duration of the program, are named with a leading "k" followed by mixed case. Underscores can be used as separators in the rare cases where capitalization cannot be used for separation. For example:</paragraph><code language="javascript">const int kDaysInAWeek = 7;
const int kAndroid8_0_0 = 24;  // Android 8.0.0
</code><paragraph>All such variables with static storage duration (i.e., statics and globals, see Storage Duration for details) should be named this way, including those that are static constant class data members and those in templates where different instantiations of the template may have different values. This convention is optional for variables of other storage classes, e.g., automatic variables; otherwise the usual variable naming rules apply. For example:</paragraph><code language="javascript">void ComputeFoo(absl::string_view suffix) {
  // Either of these is acceptable.
  const absl::string_view kPrefix = "prefix";
  const absl::string_view prefix = "prefix";
  ...
}
</code><code language="javascript">void ComputeFoo(absl::string_view suffix) {
  // Bad - different invocations of ComputeFoo give kCombined different values.
  const std::string kCombined = absl::StrCat(kPrefix, suffix);
  ...
}
</code><heading level="3">Function Names</heading><paragraph>Ordinarily, functions follow PascalCase: start with a capital letter and have a capital letter for each new word.</paragraph><code language="sql">AddTableEntry()
DeleteUrl()
OpenFileOrDie()
</code><paragraph>The same naming rule applies to class- and namespace-scope constants that are exposed as part of an API and that are intended to look like functions, because the fact that they're objects rather than functions is an unimportant implementation detail.</paragraph><paragraph>Accessors and mutators (get and set functions) may be named like variables, in snake_case. These often correspond to actual member variables, but this is not required. For example, int count() and void set_count(int count).</paragraph><heading level="3">Namespace Names</heading><paragraph>Namespace names are snake_case (all lowercase, with underscores between words).</paragraph><paragraph>When choosing names for namespaces, note that names must be fully qualified when used in a header outside the namespace, because unqualified Aliases are generally banned.</paragraph><paragraph>Top-level namespaces must be globally unique and recognizable, so each one should be owned by a single project or team, with a name based on the name of that project or team. Usually, all code in the namespace should be under one or more directories with the same name as the namespace.</paragraph><paragraph>Nested namespaces should avoid the names of well-known top-level namespaces, especially std and absl, because in C++, nested namespaces do not protect from collisions with names in other namespaces (see TotW #130).</paragraph><heading level="3">Enumerator Names</heading><paragraph>Enumerators (for both scoped and unscoped enums) should be named like constants, not like macros. That is, use kEnumName not ENUM_NAME.</paragraph><code language="javascript">enum class UrlTableError {
  kOk = 0,
  kOutOfMemory,
  kMalformedInput,
};
</code><code language="javascript">enum class AlternateUrlTableError {
  OK = 0,
  OUT_OF_MEMORY = 1,
  MALFORMED_INPUT = 2,
};
</code><paragraph>Until January 2009, the style was to name enum values like macros. This caused problems with name collisions between enum values and macros. Hence, the change to prefer constant-style naming was put in place. New code should use constant-style naming.</paragraph><heading level="3">Template Parameter Names</heading><paragraph>Template parameters should follow the naming style for their category: type template parameters should follow the rules for naming types, and non-type template parameters should follow the rules for naming variables or constants.</paragraph><heading level="3">Macro Names</heading><paragraph>You're not really going to define a macro, are you? If you do, they're like this: MY_MACRO_THAT_SCARES_SMALL_CHILDREN_AND_ADULTS_ALIKE.</paragraph><paragraph>Please see the description of macros; in general macros should not be used. However, if they are absolutely needed, then they should be named with all capitals and underscores, and with a project-specific prefix.</paragraph><code language="code">#define MYPROJECT_ROUND(x) ...
</code><heading level="3">Aliases</heading><paragraph>The name for an alias follows the same principles as any other new name, applied in the context where the alias is defined rather than where the original name appears.</paragraph><heading level="3">Exceptions to Naming Rules</heading><paragraph>If you are naming something that is analogous to an existing C or C++ entity then you can follow the existing naming convention scheme.</paragraph><paragraph>Comments are absolutely vital to keeping our code readable. The following rules describe what you should comment and where. But remember: while comments are very important, the best code is self-documenting. Giving sensible names to types and variables is much better than using obscure names that you must then explain through comments.</paragraph><paragraph>When writing your comments, write for your audience: the next contributor who will need to understand your code. Be generous — the next one may be you!</paragraph><paragraph>Use either the // or /* */ syntax, as long as you are consistent.</paragraph><paragraph>While either syntax is acceptable, // is much more common. Be consistent with how you comment and what style you use where.</paragraph><paragraph>Start each file with license boilerplate.</paragraph><paragraph>If a source file (such as a .h file) declares multiple user-facing abstractions (common functions, related classes, etc.), include a comment describing the collection of those abstractions. Include enough detail for future authors to know what does not fit there. However, the detailed documentation about individual abstractions belongs with those abstractions, not at the file level.</paragraph><paragraph>For instance, if you write a file comment for frobber.h, you do not need to include a file comment in frobber.cc or frobber_test.cc. On the other hand, if you write a collection of classes in registered_objects.cc that has no associated header file, you must include a file comment in registered_objects.cc.</paragraph><heading level="4">Legal Notice and Author Line</heading><paragraph>Every file should contain license boilerplate. Choose the appropriate boilerplate for the license used by the project (for example, Apache 2.0, BSD, LGPL, GPL).</paragraph><paragraph>If you make significant changes to a file with an author line, consider deleting the author line. New files should usually not contain copyright notice or author line.</paragraph><paragraph>Every non-obvious class or struct declaration should have an accompanying comment that describes what it is for and how it should be used.</paragraph><code language="javascript">// Iterates over the contents of a GargantuanTable.
// Example:
//    std::unique_ptr<GargantuanTableIterator> iter = table->NewIterator();
//    for (iter->Seek("foo"); !iter->done(); iter->Next()) {
//      process(iter->key(), iter->value());
//    }
class GargantuanTableIterator {
  ...
};
</code><paragraph>The class comment should provide the reader with enough information to know how and when to use the class, as well as any additional considerations necessary to correctly use the class. Document the synchronization assumptions the class makes, if any. If an instance of the class can be accessed by multiple threads, take extra care to document the rules and invariants surrounding multithreaded use.</paragraph><paragraph>The class comment is often a good place for a small example code snippet demonstrating a simple and focused usage of the class.</paragraph><paragraph>When sufficiently separated (e.g., .h and .cc files), comments describing the use of the class should go together with its interface definition; comments about the class operation and implementation should accompany the implementation of the class's methods.</paragraph><paragraph>Declaration comments describe use of the function (when it is non-obvious); comments at the definition of a function describe operation.</paragraph><heading level="4">Function Declarations</heading><paragraph>Almost every function declaration should have comments immediately preceding it that describe what the function does and how to use it. These comments may be omitted only if the function is simple and obvious (e.g., simple accessors for obvious properties of the class). Private methods and functions declared in .cc files are not exempt. Function comments should be written with an implied subject of This function and should start with the verb phrase; for example, "Opens the file", rather than "Open the file". In general, these comments do not describe how the function performs its task. Instead, that should be left to comments in the function definition.</paragraph><paragraph>Types of things to mention in comments at the function declaration:</paragraph><list type="ul"><item>What the inputs and outputs are. If function argument names are provided in `backticks`, then code-indexing tools may be able to present the documentation better.</item><item>For class member functions: whether the object remembers reference or pointer arguments beyond the duration of the method call. This is quite common for pointer/reference arguments to constructors.</item><item>For each pointer argument, whether it is allowed to be null and what happens if it is.</item><item>For each output or input/output argument, what happens to any state that argument is in (e.g., is the state appended to or overwritten?).</item><item>If there are any performance implications of how a function is used.</item></list><paragraph>Here is an example:</paragraph><code language="code">// Returns an iterator for this table, positioned at the first entry
// lexically greater than or equal to `start_word`. If there is no
// such entry, returns a null pointer. The client must not use the
// iterator after the underlying GargantuanTable has been destroyed.
//
// This method is equivalent to:
//    std::unique_ptr<Iterator> iter = table->NewIterator();
//    iter->Seek(start_word);
//    return iter;
std::unique_ptr<Iterator> GetIterator(absl::string_view start_word) const;
</code><paragraph>However, do not be unnecessarily verbose or state the completely obvious.</paragraph><paragraph>When documenting function overrides, focus on the specifics of the override itself, rather than repeating the comment from the overridden function. In many of these cases, the override needs no additional documentation and thus no comment is required.</paragraph><paragraph>When commenting constructors and destructors, remember that the person reading your code knows what constructors and destructors are for, so comments that just say something like "destroys this object" are not useful. Document what constructors do with their arguments (for example, if they take ownership of pointers), and what cleanup the destructor does. If this is trivial, just skip the comment. It is quite common for destructors not to have a header comment.</paragraph><heading level="4">Function Definitions</heading><paragraph>If there is anything tricky about how a function does its job, the function definition should have an explanatory comment. For example, in the definition comment you might describe any coding tricks you use, give an overview of the steps you go through, or explain why you chose to implement the function in the way you did rather than using a viable alternative. For instance, you might mention why it must acquire a lock for the first half of the function but why it is not needed for the second half.</paragraph><paragraph>Note you should not just repeat the comments given with the function declaration, in the .h file or wherever. It's okay to recapitulate briefly what the function does, but the focus of the comments should be on how it does it.</paragraph><paragraph>In general the actual name of the variable should be descriptive enough to give a good idea of what the variable is used for. In certain cases, more comments are required.</paragraph><heading level="4">Class Data Members</heading><paragraph>The purpose of each class data member (also called an instance variable or member variable) must be clear. If there are any invariants (special values, relationships between members, lifetime requirements) not clearly expressed by the type and name, they must be commented. However, if the type and name suffice (int num_events_;), no comment is needed.</paragraph><paragraph>In particular, add comments to describe the existence and meaning of sentinel values, such as nullptr or -1, when they are not obvious. For example:</paragraph><code language="code">private:
 // Used to bounds-check table accesses. -1 means
 // that we don't yet know how many entries the table has.
 int num_total_entries_;
</code><heading level="4">Global Variables</heading><paragraph>All global variables should have a comment describing what they are, what they are used for, and (if unclear) why they need to be global. For example:</paragraph><code language="javascript">// The total number of test cases that we run through in this regression test.
const int kNumTestCases = 6;
</code><paragraph>In your implementation you should have comments in tricky, non-obvious, interesting, or important parts of your code.</paragraph><heading level="4">Explanatory Comments</heading><paragraph>Tricky or complicated code blocks should have comments before them.</paragraph><paragraph>When the meaning of a function argument is nonobvious, consider one of the following remedies:</paragraph><list type="ul"><item>If the argument is a literal constant, and the same constant is used in multiple function calls in a way that tacitly assumes they're the same, you should use a named constant to make that constraint explicit, and to guarantee that it holds.</item><item>Consider changing the function signature to replace a bool argument with an enum argument. This will make the argument values self-describing.</item><item>For functions that have several configuration options, consider defining a single class or struct to hold all the options , and pass an instance of that. This approach has several advantages. Options are referenced by name at the call site, which clarifies their meaning. It also reduces function argument count, which makes function calls easier to read and write. As an added benefit, you don't have to change call sites when you add another option.</item><item>Replace large or complex nested expressions with named variables.</item><item>As a last resort, use comments to clarify argument meanings at the call site.</item></list><paragraph>Consider the following example:</paragraph><code language="javascript">// What are these arguments?
const DecimalNumber product = CalculateProduct(values, 7, false, nullptr);
</code><paragraph>versus:</paragraph><code language="javascript">ProductOptions options;
options.set_precision_decimals(7);
options.set_use_cache(ProductOptions::kDontUseCache);
const DecimalNumber product =
    CalculateProduct(values, options, /*completion_callback=*/nullptr);
</code><paragraph>Do not state the obvious. In particular, don't literally describe what code does, unless the behavior is nonobvious to a reader who understands C++ well. Instead, provide higher-level comments that describe why the code does what it does, or make the code self-describing.</paragraph><paragraph>Compare this:</paragraph><code language="javascript">// Find the element in the vector.  <-- Bad: obvious!
if (std::find(v.begin(), v.end(), element) != v.end()) {
  Process(element);
}
</code><paragraph>To this:</paragraph><code language="javascript">// Process "element" unless it was already processed.
if (std::find(v.begin(), v.end(), element) != v.end()) {
  Process(element);
}
</code><paragraph>Self-describing code doesn't need a comment. The comment from the example above would be obvious:</paragraph><code language="javascript">if (!IsAlreadyProcessed(element)) {
  Process(element);
}
</code><heading level="3">Punctuation, Spelling, and Grammar</heading><paragraph>Pay attention to punctuation, spelling, and grammar; it is easier to read well-written comments than badly written ones.</paragraph><paragraph>Comments should be as readable as narrative text, with proper capitalization and punctuation. In many cases, complete sentences are more readable than sentence fragments. Shorter comments, such as comments at the end of a line of code, can sometimes be less formal, but you should be consistent with your style.</paragraph><paragraph>Although it can be frustrating to have a code reviewer point out that you are using a comma when you should be using a semicolon, it is very important that source code maintain a high level of clarity and readability. Proper punctuation, spelling, and grammar help with that goal.</paragraph><paragraph>Use TODO comments for code that is temporary, a short-term solution, or good-enough but not perfect.</paragraph><paragraph>TODOs should include the string TODO in all caps, followed by the bug ID, name, e-mail address, or other identifier of the person or issue with the best context about the problem referenced by the TODO.</paragraph><code language="code">// TODO: bug 12345678 - Remove this after the 2047q4 compatibility window expires.
// TODO: example.com/my-design-doc - Manually fix up this code the next time it's touched.
// TODO(bug 12345678): Update this list after the Foo service is turned down.
// TODO(John): Use a "\*" here for concatenation operator.
</code><paragraph>If your TODO is of the form "At a future date do something" make sure that you either include a very specific date ("Fix by November 2005") or a very specific event ("Remove this code when all clients can handle XML responses.").</paragraph><heading level="2">Formatting</heading><paragraph>Coding style and formatting are pretty arbitrary, but a project is much easier to follow if everyone uses the same style. Individuals may not agree with every aspect of the formatting rules, and some of the rules may take some getting used to, but it is important that all project contributors follow the style rules so that they can all read and understand everyone's code easily.</paragraph><heading level="3">Line Length</heading><paragraph>Each line of text in your code should be at most 80 characters long.</paragraph><paragraph>We recognize that this rule is controversial, but so much existing code already adheres to it, and we feel that consistency is important.</paragraph><paragraph>Those who favor this rule argue that it is rude to force them to resize their windows and there is no need for anything longer. Some folks are used to having several code windows side-by-side, and thus don't have room to widen their windows in any case. People set up their work environment assuming a particular maximum window width, and 80 columns has been the traditional standard. Why change it?</paragraph><paragraph>Proponents of change argue that a wider line can make code more readable. The 80-column limit is an hidebound throwback to 1960s mainframes; modern equipment has wide screens that can easily show longer lines.</paragraph><paragraph>80 characters is the maximum.</paragraph><paragraph>A line may exceed 80 characters if it is</paragraph><list type="ul"><item>a comment line which is not feasible to split without harming readability, ease of cut and paste or auto-linking -- e.g., if a line contains an example command or a literal URL longer than 80 characters.</item><item>a string literal that cannot easily be wrapped at 80 columns. This may be because it contains URIs or other semantically-critical pieces, or because the literal contains an embedded language, or because it is a multiline literal whose newlines are significant, such as help messages. In these cases, breaking up the literal would reduce readability, searchability, ability to click links, etc. Except for test code, such literals should appear at namespace scope near the top of a file. If a tool like Clang-Format doesn't recognize the unsplittable content, disable the tool around the content as necessary. (We must balance between usability/searchability of such literals and the readability of the code around them.)</item><item>an include statement.</item><item>a header guard.</item><item>a using-declaration.</item></list><heading level="3">Non-ASCII Characters</heading><paragraph>Non-ASCII characters should be rare, and must use UTF-8 formatting.</paragraph><paragraph>You shouldn't hard-code user-facing text in source, even English, so use of non-ASCII characters should be rare. However, in certain cases it is appropriate to include such words in your code. For example, if your code parses data files from foreign sources, it may be appropriate to hard-code the non-ASCII string(s) used in those data files as delimiters. More commonly, unit test code (which does not need to be localized) might contain non-ASCII strings. In such cases, you should use UTF-8, since that is an encoding understood by most tools able to handle more than just ASCII.</paragraph><paragraph>Hex encoding is also OK, and encouraged where it enhances readability — for example, "\xEF\xBB\xBF", or, even more simply, "\uFEFF", is the Unicode zero-width no-break space character, which would be invisible if included in the source as straight UTF-8.</paragraph><paragraph>When possible, avoid the u8 prefix. It has significantly different semantics starting in C++20 than in C++17, producing arrays of char8_t rather than char, and will change again in C++23.</paragraph><paragraph>You shouldn't use char16_t and char32_t character types, since they're for non-UTF-8 text. For similar reasons you also shouldn't use wchar_t (unless you're writing code that interacts with the Windows API, which uses wchar_t extensively).</paragraph><heading level="3">Spaces vs. Tabs</heading><paragraph>Use only spaces, and indent 2 spaces at a time.</paragraph><paragraph>We use spaces for indentation. Do not use tabs in your code. You should set your editor to emit spaces when you hit the tab key.</paragraph><heading level="3">Function Declarations and Definitions</heading><paragraph>Return type on the same line as function name, parameters on the same line if they fit. Wrap parameter lists which do not fit on a single line as you would wrap arguments in a function call.</paragraph><paragraph>Functions look like this:</paragraph><code language="javascript">ReturnType ClassName::FunctionName(Type par_name1, Type par_name2) {
  DoSomething();
  ...
}
</code><paragraph>If you have too much text to fit on one line:</paragraph><code language="javascript">ReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2,
                                             Type par_name3) {
  DoSomething();
  ...
}
</code><paragraph>or if you cannot fit even the first parameter:</paragraph><code language="javascript">ReturnType LongClassName::ReallyReallyReallyLongFunctionName(
    Type par_name1,  // 4 space indent
    Type par_name2,
    Type par_name3) {
  DoSomething();  // 2 space indent
  ...
}
</code><paragraph>Some points to note:</paragraph><list type="ul"><item>Choose good parameter names.</item><item>A parameter name may be omitted only if the parameter is not used in the function's definition.</item><item>If you cannot fit the return type and the function name on a single line, break between them.</item><item>If you break after the return type of a function declaration or definition, do not indent.</item><item>The open parenthesis is always on the same line as the function name.</item><item>There is never a space between the function name and the open parenthesis.</item><item>There is never a space between the parentheses and the parameters.</item><item>The open curly brace is always on the end of the last line of the function declaration, not the start of the next line.</item><item>The close curly brace is either on the last line by itself or on the same line as the open curly brace.</item><item>There should be a space between the close parenthesis and the open curly brace.</item><item>All parameters should be aligned if possible.</item><item>Default indentation is 2 spaces.</item><item>Wrapped parameters have a 4 space indent.</item></list><paragraph>Unused parameters that are obvious from context may omit the name:</paragraph><code language="javascript">class Foo {
 public:
  Foo(const Foo&) = delete;
  Foo& operator=(const Foo&) = delete;
};
</code><paragraph>Unused parameters that might not be obvious should comment out the variable name in the function definition:</paragraph><code language="javascript">class Shape {
 public:
  virtual void Rotate(double radians) = 0;
};

class Circle : public Shape {
 public:
  void Rotate(double radians) override;
};

void Circle::Rotate(double /*radians*/) {}
</code><code language="code">// Bad - if someone wants to implement later, it's not clear what the
// variable means.
void Circle::Rotate(double) {}
</code><paragraph>Attributes, and macros that expand to attributes, appear at the very beginning of the function declaration or definition, before the return type:</paragraph><code language="code">  ABSL_ATTRIBUTE_NOINLINE void ExpensiveFunction();
  [[nodiscard]] bool IsOk();
</code><heading level="3">Lambda Expressions</heading><paragraph>Format parameters and bodies as for any other function, and capture lists like other comma-separated lists.</paragraph><paragraph>For by-reference captures, do not leave a space between the ampersand (&) and the variable name.</paragraph><code language="code">int x = 0;
auto x_plus_n = [&x](int n) -> int { return x + n; }
</code><paragraph>Short lambdas may be written inline as function arguments.</paragraph><code language="javascript">absl::flat_hash_set<int> to_remove = {7, 8, 9};
std::vector<int> digits = {3, 9, 1, 8, 4, 7, 1};
digits.erase(std::remove_if(digits.begin(), digits.end(), [&to_remove](int i) {
               return to_remove.contains(i);
             }),
             digits.end());
</code><heading level="3">Floating-point Literals</heading><paragraph>Floating-point literals should always have a radix point, with digits on both sides, even if they use exponential notation. Readability is improved if all floating-point literals take this familiar form, as this helps ensure that they are not mistaken for integer literals, and that the E/e of the exponential notation is not mistaken for a hexadecimal digit. It is fine to initialize a floating-point variable with an integer literal (assuming the variable type can exactly represent that integer), but note that a number in exponential notation is never an integer literal.</paragraph><code language="code">float f = 1.f;
long double ld = -.5L;
double d = 1248e6;
</code><code language="code">float f = 1.0f;
float f2 = 1.0;  // Also OK
float f3 = 1;    // Also OK
long double ld = -0.5L;
double d = 1248.0e6;
</code><heading level="3">Function Calls</heading><paragraph>Either write the call all on a single line, wrap the arguments at the parenthesis, or start the arguments on a new line indented by four spaces and continue at that 4 space indent. In the absence of other considerations, use the minimum number of lines, including placing multiple arguments on each line where appropriate.</paragraph><paragraph>Function calls have the following format:</paragraph><code language="code">bool result = DoSomething(argument1, argument2, argument3);
</code><paragraph>If the arguments do not all fit on one line, they should be broken up onto multiple lines, with each subsequent line aligned with the first argument. Do not add spaces after the open paren or before the close paren:</paragraph><code language="code">bool result = DoSomething(averyveryveryverylongargument1,
                          argument2, argument3);
</code><paragraph>Arguments may optionally all be placed on subsequent lines with a four space indent:</paragraph><code language="javascript">if (...) {
  ...
  ...
  if (...) {
    bool result = DoSomething(
        argument1, argument2,  // 4 space indent
        argument3, argument4);
    ...
  }
</code><paragraph>Put multiple arguments on a single line to reduce the number of lines necessary for calling a function unless there is a specific readability problem. Some find that formatting with strictly one argument on each line is more readable and simplifies editing of the arguments. However, we prioritize for the reader over the ease of editing arguments, and most readability problems are better addressed with the following techniques.</paragraph><paragraph>If having multiple arguments in a single line decreases readability due to the complexity or confusing nature of the expressions that make up some arguments, try creating variables that capture those arguments in a descriptive name:</paragraph><code language="code">int my_heuristic = scores[x] * y + bases[x];
bool result = DoSomething(my_heuristic, x, y, z);
</code><paragraph>Or put the confusing argument on its own line with an explanatory comment:</paragraph><code language="code">bool result = DoSomething(scores[x] * y + bases[x],  // Score heuristic.
                          x, y, z);
</code><paragraph>If there is still a case where one argument is significantly more readable on its own line, then put it on its own line. The decision should be specific to the argument which is made more readable rather than a general policy.</paragraph><paragraph>Sometimes arguments form a structure that is important for readability. In those cases, feel free to format the arguments according to that structure:</paragraph><code language="code">// Transform the widget by a 3x3 matrix.
my_widget.Transform(x1, x2, x3,
                    y1, y2, y3,
                    z1, z2, z3);
</code><heading level="3">Braced Initializer List Format</heading><paragraph>Format a braced initializer list exactly like you would format a function call in its place.</paragraph><paragraph>If the braced list follows a name (e.g., a type or variable name), format as if the {} were the parentheses of a function call with that name. If there is no name, assume a zero-length name.</paragraph><code language="javascript">// Examples of braced init list on a single line.
return {foo, bar};
functioncall({foo, bar});
std::pair<int, int> p{foo, bar};

// When you have to wrap.
SomeFunction(
    {"assume a zero-length name before {"},
    some_other_function_parameter);
SomeType variable{
    some, other, values,
    {"assume a zero-length name before {"},
    SomeOtherType{
        "Very long string requiring the surrounding breaks.",
        some, other, values},
    SomeOtherType{"Slightly shorter string",
                  some, other, values}};
SomeType variable{
    "This is too long to fit all in one line"};
MyType m = {  // Here, you could also break before {.
    superlongvariablename1,
    superlongvariablename2,
    {short, interior, list},
    {interiorwrappinglist,
     interiorwrappinglist2}};
</code><heading level="3">Looping and branching statements</heading><paragraph>At a high level, looping or branching statements consist of the following components:</paragraph><list type="ul"><item>One or more statement keywords (e.g., if, else, switch, while, do, or for).</item><item>One condition or iteration specifier, inside parentheses.</item><item>One or more controlled statements, or blocks of controlled statements.</item></list><paragraph>For these statements:</paragraph><list type="ul"><item>The components of the statement should be separated by single spaces (not line breaks).</item><item>Inside the condition or iteration specifier, put one space (or a line break) between each semicolon and the next token, except if the token is a closing parenthesis or another semicolon.</item><item>Inside the condition or iteration specifier, do not put a space after the opening parenthesis or before the closing parenthesis.</item><item>Put any controlled statements inside blocks (i.e., use curly braces).</item><item>Inside the controlled blocks, put one line break immediately after the opening brace, and one line break immediately before the closing brace.</item></list><code language="javascript">if (condition) {                   // Good - no spaces inside parentheses, space before brace.
  DoOneThing();                    // Good - two-space indent.
  DoAnotherThing();
} else if (int a = f(); a != 3) {  // Good - closing brace on new line, else on same line.
  DoAThirdThing(a);
} else {
  DoNothing();
}

// Good - the same rules apply to loops.
while (condition) {
  RepeatAThing();
}

// Good - the same rules apply to loops.
do {
  RepeatAThing();
} while (condition);

// Good - the same rules apply to loops.
for (int i = 0; i < 10; ++i) {
  RepeatAThing();
}
</code><code language="javascript">if(condition) {}                   // Bad - space missing after `if`.
else if ( condition ) {}           // Bad - space between the parentheses and the condition.
else if (condition){}              // Bad - space missing before `{`.
else if(condition){}               // Bad - multiple spaces missing.

for (int a = f();a == 10) {}       // Bad - space missing after the semicolon.

// Bad - `if ... else` statement does not have braces everywhere.
if (condition)
  foo;
else {
  bar;
}

// Bad - `if` statement too long to omit braces.
if (condition)
  // Comment
  DoSomething();

// Bad - `if` statement too long to omit braces.
if (condition1 &&
    condition2)
  DoSomething();
</code><paragraph>For historical reasons, we allow one exception to the above rules: the curly braces for the controlled statement or the line breaks inside the curly braces may be omitted if as a result the entire statement appears on either a single line (in which case there is a space between the closing parenthesis and the controlled statement) or on two lines (in which case there is a line break after the closing parenthesis and there are no braces).</paragraph><code language="code">// OK - fits on one line.
if (x == kFoo) { return new Foo(); }

// OK - braces are optional in this case.
if (x == kFoo) return new Foo();

// OK - condition fits on one line, body fits on another.
if (x == kBar)
  Bar(arg1, arg2, arg3);
</code><paragraph>This exception does not apply to multi-keyword statements like if ... else or do ... while.</paragraph><code language="code">// Bad - `if ... else` statement is missing braces.
if (x) DoThis();
else DoThat();

// Bad - `do ... while` statement is missing braces.
do DoThis();
while (x);
</code><paragraph>Use this style only when the statement is brief, and consider that loops and branching statements with complex conditions or controlled statements may be more readable with curly braces. Some projects require curly braces always.</paragraph><paragraph>case blocks in switch statements can have curly braces or not, depending on your preference. If you do include curly braces, they should be placed as shown below.</paragraph><code language="javascript">switch (var) {
  case 0: {  // 2 space indent
    Foo();   // 4 space indent
    break;
  }
  default: {
    Bar();
  }
}
</code><paragraph>Empty loop bodies should use either an empty pair of braces or continue with no braces, rather than a single semicolon.</paragraph><code language="javascript">while (condition) {}  // Good - `{}` indicates no logic.
while (condition) {
  // Comments are okay, too
}
while (condition) continue;  // Good - `continue` indicates no logic.
</code><code language="code">while (condition);  // Bad - looks like part of `do-while` loop.
</code><heading level="3">Pointer and Reference Expressions and Types</heading><paragraph>No spaces around period or arrow. Pointer operators do not have trailing spaces.</paragraph><paragraph>The following are examples of correctly-formatted pointer and reference expressions:</paragraph><code language="code">x = *p;
p = &x;
x = r.y;
x = r->y;
</code><paragraph>Note that:</paragraph><list type="ul"><item>There are no spaces around the period or arrow when accessing a member.</item><item>Pointer operators have no space after the * or &.</item></list><paragraph>When referring to a pointer or reference (variable declarations or definitions, arguments, return types, template parameters, etc.), you must not place a space before the asterisk/ampersand. Use a space to separate the type from the declared name (if present).</paragraph><code language="javascript">// These are fine.
char* c;
const std::string& str;
int* GetPointer();
std::vector<char*>  // Note no space between '*' and '>'
</code><paragraph>It is allowed (if unusual) to declare multiple variables in the same declaration, but it is disallowed if any of those have pointer or reference decorations. Such declarations are easily misread.</paragraph><code language="code">// Fine if helpful for readability.
int x, y;
</code><code language="javascript">int x, *y;  // Disallowed - no & or * in multiple declaration
int *x, *y;  // Disallowed - no & or * in multiple declaration
int *x;  // Disallowed - & or * must be left of the space
char * c;  // Bad - spaces on both sides of *
const std::string & str;  // Bad - spaces on both sides of &
</code><heading level="3">Boolean Expressions</heading><paragraph>When you have a boolean expression that is longer than the standard line length, be consistent in how you break up the lines.</paragraph><paragraph>In this example, the logical AND operator is always at the end of the lines:</paragraph><code language="javascript">if (this_one_thing > this_other_thing &&
    a_third_thing == a_fourth_thing &&
    yet_another && last_one) {
  ...
}
</code><paragraph>Note that when the code wraps in this example, both of the && logical AND operators are at the end of the line. This is more common in Google code, though wrapping all operators at the beginning of the line is also allowed. Feel free to insert extra parentheses judiciously because they can be very helpful in increasing readability when used appropriately, but be careful about overuse. Also note that you should always use the punctuation operators, such as && and ~, rather than the word operators, such as and and compl.</paragraph><heading level="3">Return Values</heading><paragraph>Do not needlessly surround the return expression with parentheses.</paragraph><paragraph>Use parentheses in return expr; only where you would use them in x = expr;.</paragraph><code language="code">return result;                  // No parentheses in the simple case.
// Parentheses OK to make a complex expression more readable.
return (some_long_condition &&
        another_condition);
</code><code language="code">return (value);                // You wouldn't write var = (value);
return(result);                // return is not a function!
</code><heading level="3">Variable and Array Initialization</heading><paragraph>You may choose between =, (), and {}; the following are all correct:</paragraph><code language="code">int x = 3;
int x(3);
int x{3};
std::string name = "Some Name";
std::string name("Some Name");
std::string name{"Some Name"};
</code><paragraph>Be careful when using a braced initialization list {...} on a type with an std::initializer_list constructor. A nonempty braced-init-list prefers the std::initializer_list constructor whenever possible. Note that empty braces {} are special, and will call a default constructor if available. To force the non-std::initializer_list constructor, use parentheses instead of braces.</paragraph><code language="code">std::vector<int> v(100, 1);  // A vector containing 100 items: All 1s.
std::vector<int> v{100, 1};  // A vector containing 2 items: 100 and 1.
</code><paragraph>Also, the brace form prevents narrowing of integral types. This can prevent some types of programming errors.</paragraph><code language="code">int pi(3.14);  // OK -- pi == 3.
int pi{3.14};  // Compile error: narrowing conversion.
</code><heading level="3">Preprocessor Directives</heading><paragraph>The hash mark that starts a preprocessor directive should always be at the beginning of the line.</paragraph><paragraph>Even when preprocessor directives are within the body of indented code, the directives should start at the beginning of the line.</paragraph><code language="javascript">// Good - directives at beginning of line
  if (lopsided_score) {
#if DISASTER_PENDING      // Correct -- Starts at beginning of line
    DropEverything();
# if NOTIFY               // OK but not required -- Spaces after #
    NotifyClient();
# endif
#endif
    BackToNormal();
  }
</code><code language="javascript">// Bad - indented directives
  if (lopsided_score) {
    #if DISASTER_PENDING  // Wrong!  The "#if" should be at beginning of line
    DropEverything();
    #endif                // Wrong!  Do not indent "#endif"
    BackToNormal();
  }
</code><heading level="3">Class Format</heading><paragraph>Sections in public, protected, and private order, each indented one space.</paragraph><paragraph>The basic format for a class definition (lacking the comments, see Class Comments for a discussion of what comments are needed) is:</paragraph><code language="javascript">class MyClass : public OtherClass {
 public:      // Note the 1 space indent!
  MyClass();  // Regular 2 space indent.
  explicit MyClass(int var);
  ~MyClass() {}

  void SomeFunction();
  void SomeFunctionThatDoesNothing() {
  }

  void set_some_var(int var) { some_var_ = var; }
  int some_var() const { return some_var_; }

 private:
  bool SomeInternalFunction();

  int some_var_;
  int some_other_var_;
};
</code><paragraph>Things to note:</paragraph><list type="ul"><item>Any base class name should be on the same line as the subclass name, subject to the 80-column limit.</item><item>The public:, protected:, and private: keywords should be indented one space.</item><item>Except for the first instance, these keywords should be preceded by a blank line. This rule is optional in small classes.</item><item>Do not leave a blank line after these keywords.</item><item>The public section should be first, followed by the protected and finally the private section.</item><item>See Declaration Order for rules on ordering declarations within each of these sections.</item></list><heading level="3">Constructor Initializer Lists</heading><paragraph>Constructor initializer lists can be all on one line or with subsequent lines indented four spaces.</paragraph><paragraph>The acceptable formats for initializer lists are:</paragraph><code language="javascript">// When everything fits on one line:
MyClass::MyClass(int var) : some_var_(var) {
  DoSomething();
}

// If the signature and initializer list are not all on one line,
// you must wrap before the colon and indent 4 spaces:
MyClass::MyClass(int var)
    : some_var_(var), some_other_var_(var + 1) {
  DoSomething();
}

// When the list spans multiple lines, put each member on its own line
// and align them:
MyClass::MyClass(int var)
    : some_var_(var),             // 4 space indent
      some_other_var_(var + 1) {  // lined up
  DoSomething();
}

// As with any other code block, the close curly can be on the same
// line as the open curly, if it fits.
MyClass::MyClass(int var)
    : some_var_(var) {}
</code><heading level="3">Namespace Formatting</heading><paragraph>The contents of namespaces are not indented.</paragraph><paragraph>Namespaces do not add an extra level of indentation. For example, use:</paragraph><code language="javascript">namespace {

void foo() {  // Correct.  No extra indentation within namespace.
  ...
}

}  // namespace
</code><paragraph>Do not indent within a namespace:</paragraph><code language="javascript">namespace {

  // Wrong!  Indented when it should not be.
  void foo() {
    ...
  }

}  // namespace
</code><heading level="3">Horizontal Whitespace</heading><paragraph>Use of horizontal whitespace depends on location. Never put trailing whitespace at the end of a line.</paragraph><heading level="4">General</heading><code language="javascript">int i = 0;  // Two spaces before end-of-line comments.

void f(bool b) {  // Open braces should always have a space before them.
  ...
int i = 0;  // Semicolons usually have no space before them.
// Spaces inside braces for braced-init-list are optional.  If you use them,
// put them on both sides!
int x[] = { 0 };
int x[] = {0};

// Spaces around the colon in inheritance and initializer lists.
class Foo : public Bar {
 public:
  // For inline function implementations, put spaces between the braces
  // and the implementation itself.
  Foo(int b) : Bar(), baz_(b) {}  // No spaces inside empty braces.
  void Reset() { baz_ = 0; }  // Spaces separating braces from implementation.
  ...
</code><paragraph>Adding trailing whitespace can cause extra work for others editing the same file when they merge, as can removing existing trailing whitespace. So, don't introduce trailing whitespace. Remove it if you're already changing that line, or do it in a separate clean-up operation (preferably when no one else is working on the file).</paragraph><heading level="4">Loops and Conditionals</heading><code language="javascript">if (b) {          // Space after the keyword in conditions and loops.
} else {          // Spaces around else.
}
while (test) {}   // There is usually no space inside parentheses.
switch (i) {
for (int i = 0; i < 5; ++i) {
// Loops and conditions may have spaces inside parentheses, but this
// is rare.  Be consistent.
switch ( i ) {
if ( test ) {
for ( int i = 0; i < 5; ++i ) {
// For loops always have a space after the semicolon.  They may have a space
// before the semicolon, but this is rare.
for ( ; i < 5 ; ++i) {
  ...

// Range-based for loops always have a space before and after the colon.
for (auto x : counts) {
  ...
}
switch (i) {
  case 1:         // No space before colon in a switch case.
    ...
  case 2: break;  // Use a space after a colon if there's code after it.
</code><heading level="4">Operators</heading><code language="code">// Assignment operators always have spaces around them.
x = 0;

// Other binary operators usually have spaces around them, but it's
// OK to remove spaces around factors.  Parentheses should have no
// internal padding.
v = w * x + y / z;
v = w*x + y/z;
v = w * (x + z);

// No spaces separating unary operators and their arguments.
x = -5;
++x;
if (x && !y)
  ...
</code><heading level="4">Templates and Casts</heading><code language="code">// No spaces inside the angle brackets (< and >), before
// <, or between >( in a cast
std::vector<std::string> x;
y = static_cast<char*>(x);

// Spaces between type and pointer are OK, but be consistent.
std::vector<char *> x;
</code><heading level="3">Vertical Whitespace</heading><paragraph>Use vertical whitespace sparingly; unnecessary blank lines make it harder to see overall code structure. Use blank lines only where they aid the reader in understanding the structure.</paragraph><paragraph>Do not add blank lines where indentation already provides clear delineation, such as at the start or end of a code block. Do use blank lines to separate code into closely related chunks, analogous to paragraph breaks in prose. Within a statement or declaration, usually only insert line breaks to stay within the line length limit, or to attach a comment to only part of the contents.</paragraph><heading level="2">Exceptions to the Rules</heading><paragraph>The coding conventions described above are mandatory. However, like all good rules, these sometimes have exceptions, which we discuss here.</paragraph><heading level="3">Existing Non-conformant Code</heading><paragraph>You may diverge from the rules when dealing with code that does not conform to this style guide.</paragraph><paragraph>If you find yourself modifying code that was written to specifications other than those presented by this guide, you may have to diverge from these rules in order to stay consistent with the local conventions in that code. If you are in doubt about how to do this, ask the original author or the person currently responsible for the code. Remember that consistency includes local consistency, too.</paragraph><heading level="3">Windows Code</heading><paragraph>Windows programmers have developed their own set of coding conventions, mainly derived from the conventions in Windows headers and other Microsoft code. We want to make it easy for anyone to understand your code, so we have a single set of guidelines for everyone writing C++ on any platform.</paragraph><paragraph>It is worth reiterating a few of the guidelines that you might forget if you are used to the prevalent Windows style:</paragraph><list type="ul"><item>Do not use Hungarian notation (for example, naming an integer iNum). Use the Google naming conventions, including the .cc extension for source files.</item><item>Windows defines many of its own synonyms for primitive types, such as DWORD, HANDLE, etc. It is perfectly acceptable, and encouraged, that you use these types when calling Windows API functions. Even so, keep as close as you can to the underlying C++ types. For example, use const TCHAR * instead of LPCTSTR.</item><item>When compiling with Microsoft Visual C++, set the compiler to warning level 3 or higher, and treat all warnings as errors.</item><item>Do not use #pragma once; instead use the standard Google include guards. The path in the include guards should be relative to the top of your project tree.</item><item>In fact, do not use any nonstandard extensions, like #pragma and __declspec, unless you absolutely must. Using __declspec(dllimport) and __declspec(dllexport) is allowed; however, you must use them through macros such as DLLIMPORT and DLLEXPORT, so that someone can easily disable the extensions if they share the code.</item></list><paragraph>However, there are just a few rules that we occasionally need to break on Windows:</paragraph><list type="ul"><item>Normally we strongly discourage the use of multiple implementation inheritance; however, it is required when using COM and some ATL/WTL classes. You may use multiple implementation inheritance to implement COM or ATL/WTL classes and interfaces.</item><item>Although you should not use exceptions in your own code, they are used extensively in the ATL and some STLs, including the one that comes with Visual C++. When using the ATL, you should define _ATL_NO_EXCEPTIONS to disable exceptions. You should investigate whether you can also disable exceptions in your STL, but if not, it is OK to turn on exceptions in the compiler. (Note that this is only to get the STL to compile. You should still not write exception handling code yourself.)</item><item>The usual way of working with precompiled headers is to include a header file at the top of each source file, typically with a name like StdAfx.h or precompile.h. To make your code easier to share with other projects, avoid including this file explicitly (except in precompile.cc), and use the /FI compiler option to include the file automatically.</item><item>Resource headers, which are usually named resource.h and contain only macros, do not need to conform to these style guidelines.</item></list></content>
</page>
<page url="https://google.github.io/styleguide/htmlcssguide.html">
<title>Google HTML/CSS Style Guide</title>
<content><heading level="1">Google HTML/CSS Style Guide</heading><heading level="2">Background</heading><paragraph>This document defines formatting and style rules for HTML and CSS. It aims at improving collaboration, code quality, and enabling supporting infrastructure. It applies to raw, working files that use HTML and CSS, including Sass and GSS files. Tools are free to obfuscate, minify, and compile as long as the general code quality is maintained.</paragraph><heading level="2">General</heading><heading level="3">General Style Rules</heading><heading level="4">Protocol</heading><paragraph>Use HTTPS for embedded resources where possible.</paragraph><paragraph>Always use HTTPS (https:) for images and other media files, style sheets, and scripts, unless the respective files are not available over HTTPS.</paragraph><code language="html"><!-- Not recommended: omits the protocol -->
<script src="//ajax.googleapis.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

<!-- Not recommended: uses HTTP -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>
</code><code language="html"><!-- Recommended -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>
</code><code language="code">/* Not recommended: omits the protocol */
@import '//fonts.googleapis.com/css?family=Open+Sans';

/* Not recommended: uses HTTP */
@import 'http://fonts.googleapis.com/css?family=Open+Sans';
</code><code language="code">/* Recommended */
@import 'https://fonts.googleapis.com/css?family=Open+Sans';
</code><heading level="3">General Formatting Rules</heading><heading level="4">Indentation</heading><paragraph>Indent by 2 spaces at a time.</paragraph><paragraph>Don't use tabs or mix tabs and spaces for indentation.</paragraph><code language="code"><ul>
  <li>Fantastic
  <li>Great
</ul>
</code><code language="javascript">.example {
  color: blue;
}
</code><heading level="4">Capitalization</heading><paragraph>Use only lowercase.</paragraph><paragraph>All code has to be lowercase: This applies to HTML element names, attributes, attribute values (unless text/CDATA), CSS selectors, properties, and property values (with the exception of strings).</paragraph><code language="code"><!-- Not recommended -->
<A HREF="/">Home</A>
</code><code language="code"><!-- Recommended -->
<img src="google.png" alt="Google">
</code><code language="code">/* Not recommended */
color: #E5E5E5;
</code><code language="code">/* Recommended */
color: #e5e5e5;
</code><heading level="4">Trailing Whitespace</heading><paragraph>Remove trailing white spaces.</paragraph><paragraph>Trailing white spaces are unnecessary and can complicate diffs.</paragraph><code language="code"><!-- Not recommended -->
<p>What?_
</code><code language="code"><!-- Recommended -->
<p>Yes please.
</code><heading level="4">Encoding</heading><paragraph>Use UTF-8 (no BOM).</paragraph><paragraph>Make sure your editor uses UTF-8 as character encoding, without a byte order mark.</paragraph><paragraph>Specify the encoding in HTML templates and documents via <meta charset="utf-8">. Do not specify the encoding of style sheets as these assume UTF-8.</paragraph><paragraph>(More on encodings and when and how to specify them can be found in Handling character encodings in HTML and CSS.)</paragraph><paragraph>Explain code as needed, where possible.</paragraph><paragraph>Use comments to explain code: What does it cover, what purpose does it serve, why is respective solution used or preferred?</paragraph><paragraph>(This item is optional as it is not deemed a realistic expectation to always demand fully documented code. Mileage may vary heavily for HTML and CSS code and depends on the project's complexity.)</paragraph><heading level="4">Action Items</heading><paragraph>Mark todos and action items with TODO.</paragraph><paragraph>Highlight todos by using the keyword TODO only, not other common formats like @@.</paragraph><paragraph>Append action items after a colon as in TODO: action item.</paragraph><code language="code">{# TODO: Revisit centering. #}
<center>Test</center>
</code><code language="code"><!-- TODO: Remove optional tags. -->
<ul>
  <li>Apples</li>
  <li>Oranges</li>
</ul>
</code><heading level="2">HTML</heading><heading level="3">HTML Style Rules</heading><heading level="4">Document Type</heading><paragraph>Use <!doctype html>.</paragraph><paragraph>Always put your HTML in no-quirks mode by including <!doctype html> at the beginning of the document.</paragraph><paragraph>A document without a doctype is rendered in "quirks mode", and one with a different doctype may be rendered in "limited-quirks mode". These modes don't follow the widely-understood, widely-documented behavior for various core HTML and CSS constructs, and are likely to cause subtle failures and incompatibilities especially when re-using code that expects no-quirks mode.</paragraph><heading level="4">HTML Validity</heading><paragraph>Use valid HTML where possible.</paragraph><paragraph>Use valid HTML code unless that is not possible due to otherwise unattainable performance goals regarding file size.</paragraph><paragraph>Use tools such as the W3C HTML validator to test.</paragraph><paragraph>Using valid HTML is a measurable baseline quality attribute that contributes to learning about technical requirements and constraints, and that ensures proper HTML usage.</paragraph><code language="code"><!-- Not recommended -->
<title>Test</title>
<article>This is only a test.
</code><code language="code"><!-- Recommended -->
<!doctype html>
<meta charset="utf-8">
<title>Test</title>
<article>This is only a test.</article>
</code><heading level="4">Semantics</heading><paragraph>Use HTML according to its purpose.</paragraph><paragraph>Use elements (sometimes incorrectly called "tags") for what they have been created for. For example, use heading elements for headings, p elements for paragraphs, a elements for anchors, etc.</paragraph><paragraph>Using HTML according to its purpose is important for accessibility, reuse, and code efficiency reasons.</paragraph><code language="html"><!-- Not recommended -->
<div onclick="goToRecommendations();">All recommendations</div>
</code><code language="code"><!-- Recommended -->
<a href="recommendations/">All recommendations</a>
</code><paragraph>Provide alternative contents for multimedia.</paragraph><paragraph>For multimedia, such as images, videos, animated objects via canvas, make sure to offer alternative access. For images that means use of meaningful alternative text (alt) and for video and audio transcripts and captions, if available.</paragraph><paragraph>Providing alternative contents is important for accessibility reasons: A blind user has few cues to tell what an image is about without @alt, and other users may have no way of understanding what video or audio contents are about either.</paragraph><paragraph>(For images whose alt attributes would introduce redundancy, and for images whose purpose is purely decorative which you cannot immediately use CSS for, use no alternative text, as in alt="".)</paragraph><code language="code"><!-- Not recommended -->
<img src="spreadsheet.png">
</code><code language="code"><!-- Recommended -->
<img src="spreadsheet.png" alt="Spreadsheet screenshot.">
</code><heading level="4">Separation of Concerns</heading><paragraph>Separate structure from presentation from behavior.</paragraph><paragraph>Strictly keep structure (markup), presentation (styling), and behavior (scripting) apart, and try to keep the interaction between the three to an absolute minimum.</paragraph><paragraph>That is, make sure documents and templates contain only HTML and HTML that is solely serving structural purposes. Move everything presentational into style sheets, and everything behavioral into scripts.</paragraph><paragraph>In addition, keep the contact area as small as possible by linking as few style sheets and scripts as possible from documents and templates.</paragraph><paragraph>Separating structure from presentation from behavior is important for maintenance reasons. It is always more expensive to change HTML documents and templates than it is to update style sheets and scripts.</paragraph><code language="code"><!-- Not recommended -->
<!doctype html>
<title>HTML sucks</title>
<link rel="stylesheet" href="base.css" media="screen">
<link rel="stylesheet" href="grid.css" media="screen">
<link rel="stylesheet" href="print.css" media="print">
<h1 style="font-size: 1em;">HTML sucks</h1>
<p>I’ve read about this on a few sites but now I’m sure:
  <u>HTML is stupid!!1</u>
<center>I can’t believe there’s no way to control the styling of
  my website without doing everything all over again!</center>
</code><code language="code"><!-- Recommended -->
<!doctype html>
<title>My first CSS-only redesign</title>
<link rel="stylesheet" href="default.css">
<h1>My first CSS-only redesign</h1>
<p>I’ve read about this on a few sites but today I’m actually
  doing it: separating concerns and avoiding anything in the HTML of
  my website that is presentational.
<p>It’s awesome!
</code><heading level="4">Entity References</heading><paragraph>Do not use entity references.</paragraph><paragraph>There is no need to use entity references like &mdash;, &rdquo;, or &#x263a;, assuming the same encoding (UTF-8) is used for files and editors as well as among teams.</paragraph><paragraph>The only exceptions apply to characters with special meaning in HTML (like < and &) as well as control or "invisible" characters (like no-break spaces).</paragraph><code language="code"><!-- Not recommended -->
The currency symbol for the Euro is &ldquo;&eur;&rdquo;.
</code><code language="code"><!-- Recommended -->
The currency symbol for the Euro is “€”.
</code><paragraph>Omit optional tags (optional).</paragraph><paragraph>For file size optimization and scannability purposes, consider omitting optional tags. The HTML5 specification defines what tags can be omitted.</paragraph><paragraph>(This approach may require a grace period to be established as a wider guideline as it's significantly different from what web developers are typically taught. For consistency and simplicity reasons it's best served omitting all optional tags, not just a selection.)</paragraph><code language="html"><!-- Not recommended -->
<!doctype html>
<html>
  <head>
    <title>Spending money, spending bytes</title>
  </head>
  <body>
    <p>Sic.</p>
  </body>
</html>
</code><code language="code"><!-- Recommended -->
<!doctype html>
<title>Saving money, saving bytes</title>
<p>Qed.
</code><heading level="4">type Attributes</heading><paragraph>Omit type attributes for style sheets and scripts.</paragraph><paragraph>Do not use type attributes for style sheets (unless not using CSS) and scripts (unless not using JavaScript).</paragraph><paragraph>Specifying type attributes in these contexts is not necessary as HTML5 implies text/css and text/javascript as defaults. This can be safely done even for older browsers.</paragraph><code language="code"><!-- Not recommended -->
<link rel="stylesheet" href="https://www.google.com/css/maia.css"
    type="text/css">
</code><code language="code"><!-- Recommended -->
<link rel="stylesheet" href="https://www.google.com/css/maia.css">
</code><code language="html"><!-- Not recommended -->
<script src="https://www.google.com/js/gweb/analytics/autotrack.js"
    type="text/javascript"></script>
</code><code language="html"><!-- Recommended -->
<script src="https://www.google.com/js/gweb/analytics/autotrack.js"></script>
</code><heading level="4">id Attributes</heading><paragraph>Avoid unnecessary id attributes.</paragraph><paragraph>Prefer class attributes for styling and data attributes for scripting.</paragraph><paragraph>Where id attributes are strictly required, always include a hyphen in the value to ensure it does not match the JavaScript identifier syntax, e.g. use user-profile rather than just profile or userProfile.</paragraph><paragraph>When an element has an id attribute, browsers will make that available as a named property on the global window prototype, which may cause unexpected behavior. While id attribute values containing a hyphen are still available as property names, these cannot be referenced as global JavaScript variables.</paragraph><code language="html"><!-- Not recommended: `window.userProfile` will resolve to reference the <div> node -->
<div id="userProfile"></div>
</code><code language="html"><!-- Recommended: `id` attribute is required and its value includes a hyphen -->
<div aria-describedby="user-profile">
  …
  <div id="user-profile"></div>
  …
</div>
</code><heading level="3">HTML Formatting Rules</heading><heading level="4">General Formatting</heading><paragraph>Use a new line for every block, list, or table element, and indent every such child element.</paragraph><paragraph>Independent of the styling of an element (as CSS allows elements to assume a different role per display property), put every block, list, or table element on a new line.</paragraph><paragraph>Also, indent them if they are child elements of a block, list, or table element.</paragraph><paragraph>(If you run into issues around whitespace between list items it's acceptable to put all li elements in one line. A linter is encouraged to throw a warning instead of an error.)</paragraph><code language="code"><blockquote>
  <p><em>Space</em>, the final frontier.</p>
</blockquote>
</code><code language="code"><ul>
  <li>Moe
  <li>Larry
  <li>Curly
</ul>
</code><code language="code"><table>
  <thead>
    <tr>
      <th scope="col">Income
      <th scope="col">Taxes
  <tbody>
    <tr>
      <td>$ 5.00
      <td>$ 4.50
</table>
</code><heading level="4">HTML Line-Wrapping</heading><paragraph>Break long lines (optional).</paragraph><paragraph>While there is no column limit recommendation for HTML, you may consider wrapping long lines if it significantly improves readability.</paragraph><paragraph>When line-wrapping, each continuation line should be indented to distinguish wrapped attributes from child elements. Lines should be wrapped consistently within a project, ideally enforced by automated code formatting tools.</paragraph><code language="code"><button
  mat-icon-button
  color="primary"
  class="menu-button"
  (click)="openMenu()"
>
  <mat-icon>menu</mat-icon>
</button>
</code><code language="code"><button mat-icon-button color="primary" class="menu-button"
    (click)="openMenu()">
  <mat-icon>menu</mat-icon>
</button>
</code><code language="code"><button
    mat-icon-button
    color="primary"
    class="menu-button"
    (click)="openMenu()">
  <mat-icon>menu</mat-icon>
</button>
</code><code language="code"><button mat-icon-button
        color="primary"
        class="menu-button"
        (click)="openMenu()">
  <mat-icon>menu</mat-icon>
</button>
</code><heading level="4">HTML Quotation Marks</heading><paragraph>When quoting attributes values, use double quotation marks.</paragraph><paragraph>Use double ("") rather than single quotation marks ('') around attribute values.</paragraph><code language="code"><!-- Not recommended -->
<a class='maia-button maia-button-secondary'>Sign in</a>
</code><code language="code"><!-- Recommended -->
<a class="maia-button maia-button-secondary">Sign in</a>
</code><heading level="2">CSS</heading><heading level="3">CSS Style Rules</heading><heading level="4">CSS Validity</heading><paragraph>Use valid CSS where possible.</paragraph><paragraph>Unless dealing with CSS validator bugs or requiring proprietary syntax, use valid CSS code.</paragraph><paragraph>Use tools such as the W3C CSS validator to test.</paragraph><paragraph>Using valid CSS is a measurable baseline quality attribute that allows to spot CSS code that may not have any effect and can be removed, and that ensures proper CSS usage.</paragraph><heading level="4">Class Naming</heading><paragraph>Use meaningful or generic class names.</paragraph><paragraph>Instead of presentational or cryptic names, always use class names that reflect the purpose of the element in question, or that are otherwise generic.</paragraph><paragraph>Names that are specific and reflect the purpose of the element should be preferred as these are most understandable and the least likely to change.</paragraph><paragraph>Generic names are simply a fallback for elements that have no particular or no meaning different from their siblings. They are typically needed as "helpers."</paragraph><paragraph>Using functional or generic names reduces the probability of unnecessary document or template changes.</paragraph><code language="code">/* Not recommended: meaningless */
.yee-1901 {}

/* Not recommended: presentational */
.button-green {}
.clear {}
</code><code language="code">/* Recommended: specific */
.gallery {}
.login {}
.video {}

/* Recommended: generic */
.aux {}
.alt {}
</code><heading level="4">Class Name Style</heading><paragraph>Use class names that are as short as possible but as long as necessary.</paragraph><paragraph>Try to convey what a class is about while being as brief as possible.</paragraph><paragraph>Using class names this way contributes to acceptable levels of understandability and code efficiency.</paragraph><code language="code">/* Not recommended */
.navigation {}
.atr {}
</code><code language="code">/* Recommended */
.nav {}
.author {}
</code><heading level="4">Class Name Delimiters</heading><paragraph>Separate words in class names by a hyphen.</paragraph><paragraph>Do not concatenate words and abbreviations in selectors by any characters (including none at all) other than hyphens, in order to improve understanding and scannability.</paragraph><code language="code">/* Not recommended: does not separate the words “demo” and “image” */
.demoimage {}

/* Not recommended: uses underscore instead of hyphen */
.error_status {}
</code><code language="code">/* Recommended */
.video-id {}
.ads-sample {}
</code><heading level="4">Prefixes</heading><paragraph>Prefix selectors with an application-specific prefix (optional).</paragraph><paragraph>In large projects as well as for code that gets embedded in other projects or on external sites use prefixes (as namespaces) for class names. Use short, unique identifiers followed by a dash.</paragraph><paragraph>Using namespaces helps preventing naming conflicts and can make maintenance easier, for example in search and replace operations.</paragraph><code language="code">.adw-help {} /* AdWords */
.maia-note {} /* Maia */
</code><heading level="4">Type Selectors</heading><paragraph>Avoid qualifying class names with type selectors.</paragraph><paragraph>Unless necessary (for example with helper classes), do not use element names in conjunction with classes.</paragraph><paragraph>Avoiding unnecessary ancestor selectors is useful for performance reasons.</paragraph><code language="code">/* Not recommended */
ul.example {}
div.error {}
</code><code language="code">/* Recommended */
.example {}
.error {}
</code><heading level="4">ID Selectors</heading><paragraph>Avoid ID selectors.</paragraph><paragraph>ID attributes are expected to be unique across an entire page, which is difficult to guarantee when a page contains many components worked on by many different engineers. Class selectors should be preferred in all situations.</paragraph><code language="code">/* Not recommended */
#example {}
</code><code language="code">/* Recommended */
.example {}
</code><heading level="4">Shorthand Properties</heading><paragraph>Use shorthand properties where possible.</paragraph><paragraph>CSS offers a variety of shorthand properties (like font) that should be used whenever possible, even in cases where only one value is explicitly set.</paragraph><paragraph>Using shorthand properties is useful for code efficiency and understandability.</paragraph><code language="code">/* Not recommended */
border-top-style: none;
font-family: palatino, georgia, serif;
font-size: 100%;
line-height: 1.6;
padding-bottom: 2em;
padding-left: 1em;
padding-right: 1em;
padding-top: 0;
</code><code language="code">/* Recommended */
border-top: 0;
font: 100%/1.6 palatino, georgia, serif;
padding: 0 1em 2em;
</code><heading level="4">0 and Units</heading><paragraph>Omit unit specification after "0" values, unless required.</paragraph><paragraph>Do not use units after 0 values unless they are required.</paragraph><code language="code">flex: 0px; /* This flex-basis component requires a unit. */
flex: 1 1 0px; /* Not ambiguous without the unit, but needed in IE11. */
margin: 0;
padding: 0;
</code><heading level="4">Leading 0s</heading><paragraph>Always include leading "0"s in values.</paragraph><paragraph>Put 0s in front of values or lengths between -1 and 1.</paragraph><code language="code">font-size: 0.8em;
</code><heading level="4">Hexadecimal Notation</heading><paragraph>Use 3 character hexadecimal notation where possible.</paragraph><paragraph>For color values that permit it, 3 character hexadecimal notation is shorter and more succinct.</paragraph><code language="code">/* Not recommended */
color: #eebbcc;
</code><code language="code">/* Recommended */
color: #ebc;
</code><heading level="4">Important Declarations</heading><paragraph>Avoid using !important declarations.</paragraph><paragraph>These declarations break the natural cascade of CSS and make it difficult to reason about and compose styles. Use selector specificity to override properties instead.</paragraph><code language="javascript">/* Not recommended */
.example {
  font-weight: bold !important;
}
</code><code language="javascript">/* Recommended */
.example {
  font-weight: bold;
}
</code><heading level="4">Hacks</heading><paragraph>Avoid user agent detection as well as CSS "hacks"—try a different approach first.</paragraph><paragraph>It's tempting to address styling differences over user agent detection or special CSS filters, workarounds, and hacks. Both approaches should be considered last resort in order to achieve and maintain an efficient and manageable code base. Put another way, giving detection and hacks a free pass will hurt projects in the long run as projects tend to take the way of least resistance. That is, allowing and making it easy to use detection and hacks means using detection and hacks more frequently—and more frequently is too frequently.</paragraph><heading level="3">CSS Formatting Rules</heading><heading level="4">Declaration Order</heading><paragraph>Alphabetize declarations (optional).</paragraph><paragraph>Sort declarations consistently within a project. In the absence of tooling to automate and enforce a consistent sort order, consider putting declarations in alphabetical order in order to achieve consistent code in a way that is easy to learn, remember, and manually maintain.</paragraph><paragraph>Ignore vendor-specific prefixes for sorting purposes. However, multiple vendor-specific prefixes for a certain CSS property should be kept sorted (e.g. -moz prefix comes before -webkit).</paragraph><code language="code">background: fuchsia;
border: 1px solid;
-moz-border-radius: 4px;
-webkit-border-radius: 4px;
border-radius: 4px;
color: black;
text-align: center;
text-indent: 2em;
</code><heading level="4">Block Content Indentation</heading><paragraph>Indent all block content.</paragraph><paragraph>Indent all block content, that is rules within rules as well as declarations, so to reflect hierarchy and improve understanding.</paragraph><code language="javascript">@media screen, projection {

  html {
    background: #fff;
    color: #444;
  }

}
</code><heading level="4">Declaration Stops</heading><paragraph>Use a semicolon after every declaration.</paragraph><paragraph>End every declaration with a semicolon for consistency and extensibility reasons.</paragraph><code language="javascript">/* Not recommended */
.test {
  display: block;
  height: 100px
}
</code><code language="javascript">/* Recommended */
.test {
  display: block;
  height: 100px;
}
</code><heading level="4">Property Name Stops</heading><paragraph>Use a space after a property name's colon.</paragraph><paragraph>Always use a single space between property and value (but no space between property and colon) for consistency reasons.</paragraph><code language="javascript">/* Not recommended */
h3 {
  font-weight:bold;
}
</code><code language="javascript">/* Recommended */
h3 {
  font-weight: bold;
}
</code><heading level="4">Declaration Block Separation</heading><paragraph>Use a space between the last selector and the declaration block.</paragraph><paragraph>Always use a single space between the last selector and the opening brace that begins the declaration block.</paragraph><paragraph>The opening brace should be on the same line as the last selector in a given rule.</paragraph><code language="javascript">/* Not recommended: missing space */
.video{
  margin-top: 1em;
}

/* Not recommended: unnecessary line break */
.video
{
  margin-top: 1em;
}
</code><code language="javascript">/* Recommended */
.video {
  margin-top: 1em;
}
</code><heading level="4">Selector and Declaration Separation</heading><paragraph>Separate selectors and declarations by new lines.</paragraph><paragraph>Always start a new line for each selector and declaration.</paragraph><code language="javascript">/* Not recommended */
a:focus, a:active {
  position: relative; top: 1px;
}
</code><code language="javascript">/* Recommended */
h1,
h2,
h3 {
  font-weight: normal;
  line-height: 1.2;
}
</code><heading level="4">Rule Separation</heading><paragraph>Separate rules by new lines.</paragraph><paragraph>Always put a blank line (two line breaks) between rules.</paragraph><code language="javascript">html {
  background: #fff;
}

body {
  margin: auto;
  width: 50%;
}
</code><heading level="4">CSS Quotation Marks</heading><paragraph>Use single ('') rather than double ("") quotation marks for attribute selectors and property values.</paragraph><paragraph>Do not use quotation marks in URI values (url()).</paragraph><paragraph>Exception: If you do need to use the @charset rule, use double quotation marks—single quotation marks are not permitted.</paragraph><code language="javascript">/* Not recommended */
@import url("https://www.google.com/css/maia.css");

html {
  font-family: "open sans", arial, sans-serif;
}
</code><code language="javascript">/* Recommended */
@import url(https://www.google.com/css/maia.css);

html {
  font-family: 'open sans', arial, sans-serif;
}
</code><paragraph>Group sections by a section comment (optional).</paragraph><paragraph>If possible, group style sheet sections together by using comments. Separate sections with new lines.</paragraph><code language="code">/* Header */

.adw-header {}

/* Footer */

.adw-footer {}

/* Gallery */

.adw-gallery {}
</code><heading level="2">Parting Words</heading><paragraph>Be consistent.</paragraph><paragraph>If you're editing code, take a few minutes to look at the code around you and determine its style. If they use spaces around all their arithmetic operators, you should too. If their comments have little boxes of hash marks around them, make your comments have little boxes of hash marks around them too.</paragraph><paragraph>The point of having style guidelines is to have a common vocabulary of coding so people can concentrate on what you're saying rather than on how you're saying it. We present global style rules here so people know the vocabulary, but local style is also important. If code you add to a file looks drastically different from the existing code around it, it throws readers out of their rhythm when they go to read it. Avoid this.</paragraph></content>
</page>
<page url="https://google.github.io/styleguide/csharp-style.html">
<title>C# at Google Style Guide | styleguide</title>
<content><heading level="1">C# at Google Style Guide</heading><paragraph>This style guide is for C# code developed internally at Google, and is the default style for C# code at Google. It makes stylistic choices that conform to other languages at Google, such as Google C++ style and Google Java style.</paragraph><heading level="2">Formatting guidelines</heading><heading level="3">Naming rules</heading><paragraph>Naming rules follow Microsoft's C# naming guidelines. Where Microsoft's naming guidelines are unspecified (e.g. private and local variables), rules are taken from the CoreFX C# coding guidelines</paragraph><paragraph>Rule summary:</paragraph><heading level="4">Code</heading><list type="ul"><item>Names of classes, methods, enumerations, public fields, public properties, namespaces: PascalCase.</item><item>Names of local variables, parameters: camelCase.</item><item>Names of private, protected, internal and protected internal fields and properties: _camelCase.</item><item>Naming convention is unaffected by modifiers such as const, static, readonly, etc.</item><item>For casing, a "word" is anything written without internal spaces, including acronyms. For example, MyRpc instead of MyRPC.</item><item>Names of interfaces start with I, e.g. IInterface.</item></list><heading level="4">Files</heading><list type="ul"><item>Filenames and directory names are PascalCase, e.g. MyFile.cs.</item><item>Where possible the file name should be the same as the name of the main class in the file, e.g. MyClass.cs.</item><item>In general, prefer one core class per file.</item></list><heading level="3">Organization</heading><list type="ul"><item>Modifiers occur in the following order: public protected internal private new abstract virtual override sealed static readonly extern unsafe volatile async.</item><item>Namespace using declarations go at the top, before any namespaces. using import order is alphabetical, apart from System imports which always go first.</item><item>Class member ordering: Group class members in the following order: Nested classes, enums, delegates and events. Static, const and readonly fields. Fields and properties. Constructors and finalizers. Methods. Within each group, elements should be in the following order: Public. Internal. Protected internal. Protected. Private. Where possible, group interface implementations together.</item></list><list type="ul"><item>Group class members in the following order: Nested classes, enums, delegates and events. Static, const and readonly fields. Fields and properties. Constructors and finalizers. Methods.</item><item>Within each group, elements should be in the following order: Public. Internal. Protected internal. Protected. Private.</item><item>Where possible, group interface implementations together.</item></list><list type="ul"><item>Nested classes, enums, delegates and events.</item><item>Static, const and readonly fields.</item><item>Fields and properties.</item><item>Constructors and finalizers.</item><item>Methods.</item></list><list type="ul"><item>Public.</item><item>Internal.</item><item>Protected internal.</item><item>Protected.</item><item>Private.</item></list><heading level="3">Whitespace rules</heading><paragraph>Developed from Google Java style.</paragraph><list type="ul"><item>A maximum of one statement per line.</item><item>A maximum of one assignment per statement.</item><item>Indentation of 2 spaces, no tabs.</item><item>Column limit: 100.</item><item>No line break before opening brace.</item><item>No line break between closing brace and else.</item><item>Braces used even when optional.</item><item>Space after if/for/while etc., and after commas.</item><item>No space after an opening parenthesis or before a closing parenthesis.</item><item>No space between a unary operator and its operand. One space between the operator and each operand of all other operators.</item><item>Line wrapping developed from Google C++ style guidelines, with minor modifications for compatibility with Microsoft's C# formatting tools: In general, line continuations are indented 4 spaces. Line breaks with braces (e.g. list initializers, lambdas, object initializers, etc) do not count as continuations. For function definitions and calls, if the arguments do not all fit on one line they should be broken up onto multiple lines, with each subsequent line aligned with the first argument. If there is not enough room for this, arguments may instead be placed on subsequent lines with a four space indent. The code example below illustrates this.</item></list><list type="ul"><item>In general, line continuations are indented 4 spaces.</item><item>Line breaks with braces (e.g. list initializers, lambdas, object initializers, etc) do not count as continuations.</item><item>For function definitions and calls, if the arguments do not all fit on one line they should be broken up onto multiple lines, with each subsequent line aligned with the first argument. If there is not enough room for this, arguments may instead be placed on subsequent lines with a four space indent. The code example below illustrates this.</item></list><heading level="3">Example</heading><code language="javascript">using System;                                       // `using` goes at the top, outside the
                                                    // namespace.

namespace MyNamespace {                             // Namespaces are PascalCase.
                                                    // Indent after namespace.
  public interface IMyInterface {                   // Interfaces start with 'I'
    public int Calculate(float value, float exp);   // Methods are PascalCase
                                                    // ...and space after comma.
  }

  public enum MyEnum {                              // Enumerations are PascalCase.
    Yes,                                            // Enumerators are PascalCase.
    No,
  }

  public class MyClass {                            // Classes are PascalCase.
    public int Foo = 0;                             // Public member variables are
                                                    // PascalCase.
    public bool NoCounting = false;                 // Field initializers are encouraged.
    private class Results {
      public int NumNegativeResults = 0;
      public int NumPositiveResults = 0;
    }
    private Results _results;                       // Private member variables are
                                                    // _camelCase.
    public static int NumTimesCalled = 0;
    private const int _bar = 100;                   // const does not affect naming
                                                    // convention.
    private int[] _someTable = {                    // Container initializers use a 2
      2, 3, 4,                                      // space indent.
    }

    public MyClass() {
      _results = new Results {
        NumNegativeResults = 1,                     // Object initializers use a 2 space
        NumPositiveResults = 1,                     // indent.
      };
    }

    public int CalculateValue(int mulNumber) {      // No line break before opening brace.
      var resultValue = Foo * mulNumber;            // Local variables are camelCase.
      NumTimesCalled++;
      Foo += _bar;

      if (!NoCounting) {                            // No space after unary operator and
                                                    // space after 'if'.
        if (resultValue < 0) {                      // Braces used even when optional and
                                                    // spaces around comparison operator.
          _results.NumNegativeResults++;
        } else if (resultValue > 0) {               // No newline between brace and else.
          _results.NumPositiveResults++;
        }
      }

      return resultValue;
    }

    public void ExpressionBodies() {
      // For simple lambdas, fit on one line if possible, no brackets or braces required.
      Func<int, int> increment = x => x + 1;

      // Closing brace aligns with first character on line that includes the opening brace.
      Func<int, int, long> difference1 = (x, y) => {
        long diff = (long)x - y;
        return diff >= 0 ? diff : -diff;
      };

      // If defining after a continuation line break, indent the whole body.
      Func<int, int, long> difference2 =
          (x, y) => {
            long diff = (long)x - y;
            return diff >= 0 ? diff : -diff;
          };

      // Inline lambda arguments also follow these rules. Prefer a leading newline before
      // groups of arguments if they include lambdas.
      CallWithDelegate(
          (x, y) => {
            long diff = (long)x - y;
            return diff >= 0 ? diff : -diff;
          });
    }

    void DoNothing() {}                             // Empty blocks may be concise.

    // If possible, wrap arguments by aligning newlines with the first argument.
    void AVeryLongFunctionNameThatCausesLineWrappingProblems(int longArgumentName,
                                                             int p1, int p2) {}

    // If aligning argument lines with the first argument doesn't fit, or is difficult to
    // read, wrap all arguments on new lines with a 4 space indent.
    void AnotherLongFunctionNameThatCausesLineWrappingProblems(
        int longArgumentName, int longArgumentName2, int longArgumentName3) {}

    void CallingLongFunctionName() {
      int veryLongArgumentName = 1234;
      int shortArg = 1;
      // If possible, wrap arguments by aligning newlines with the first argument.
      AnotherLongFunctionNameThatCausesLineWrappingProblems(shortArg, shortArg,
                                                            veryLongArgumentName);
      // If aligning argument lines with the first argument doesn't fit, or is difficult to
      // read, wrap all arguments on new lines with a 4 space indent.
      AnotherLongFunctionNameThatCausesLineWrappingProblems(
          veryLongArgumentName, veryLongArgumentName, veryLongArgumentName);
    }
  }
}
</code><heading level="2">C# coding guidelines</heading><heading level="3">Constants</heading><list type="ul"><item>Variables and fields that can be made const should always be made const.</item><item>If const isn't possible, readonly can be a suitable alternative.</item><item>Prefer named constants to magic numbers.</item></list><heading level="3">IEnumerable vs IList vs IReadOnlyList</heading><list type="ul"><item>For inputs use the most restrictive collection type possible, for example IReadOnlyCollection / IReadOnlyList / IEnumerable as inputs to methods when the inputs should be immutable.</item><item>For outputs, if passing ownership of the returned container to the owner, prefer IList over IEnumerable. If not transferring ownership, prefer the most restrictive option.</item></list><heading level="3">Generators vs containers</heading><list type="ul"><item>Use your best judgement, bearing in mind: Generator code is often less readable than filling in a container. Generator code can be more performant if the results are going to be processed lazily, e.g. when not all the results are needed. Generator code that is directly turned into a container via ToList() will be less performant than filling in a container directly. Generator code that is called multiple times will be considerably slower than iterating over a container multiple times.</item></list><list type="ul"><item>Generator code is often less readable than filling in a container.</item><item>Generator code can be more performant if the results are going to be processed lazily, e.g. when not all the results are needed.</item><item>Generator code that is directly turned into a container via ToList() will be less performant than filling in a container directly.</item><item>Generator code that is called multiple times will be considerably slower than iterating over a container multiple times.</item></list><heading level="3">Property styles</heading><list type="ul"><item>For single line read-only properties, prefer expression body properties (=>) when possible.</item><item>For everything else, use the older { get; set; } syntax.</item></list><heading level="3">Expression body syntax</heading><paragraph>For example:</paragraph><code language="javascript">int SomeProperty => _someProperty
</code><list type="ul"><item>Judiciously use expression body syntax in lambdas and properties.</item><item>Don't use on method definitions. This will be reviewed when C# 7 is live, which uses this syntax heavily.</item><item>As with methods and other scoped blocks of code, align the closing with the first character of the line that includes the opening brace. See sample code for examples.</item></list><heading level="3">Structs and classes:</heading><list type="ul"><item>Structs are very different from classes: Structs are always passed and returned by value. Assigning a value to a member of a returned struct doesn't modify the original - e.g. transform.position.x = 10 doesn't set the transform's position.x to 10; position here is a property that returns a Vector3 by value, so this just sets the x parameter of a copy of the original.</item><item>Almost always use a class.</item><item>Consider struct when the type can be treated like other value types - for example, if instances of the type are small and commonly short-lived or are commonly embedded in other objects. Good examples include Vector3, Quaternion and Bounds.</item><item>Note that this guidance may vary from team to team where, for example, performance issues might force the use of structs.</item></list><paragraph>Structs are very different from classes:</paragraph><list type="ul"><item>Structs are always passed and returned by value.</item><item>Assigning a value to a member of a returned struct doesn't modify the original - e.g. transform.position.x = 10 doesn't set the transform's position.x to 10; position here is a property that returns a Vector3 by value, so this just sets the x parameter of a copy of the original.</item></list><paragraph>Almost always use a class.</paragraph><paragraph>Consider struct when the type can be treated like other value types - for example, if instances of the type are small and commonly short-lived or are commonly embedded in other objects. Good examples include Vector3, Quaternion and Bounds.</paragraph><paragraph>Note that this guidance may vary from team to team where, for example, performance issues might force the use of structs.</paragraph><heading level="3">Lambdas vs named methods</heading><list type="ul"><item>If a lambda is non-trivial (e.g. more than a couple of statements, excluding declarations), or is reused in multiple places, it should probably be a named method.</item></list><heading level="3">Field initializers</heading><list type="ul"><item>Field initializers are generally encouraged.</item></list><heading level="3">Extension methods</heading><list type="ul"><item>Only use an extension method when the source of the original class is not available, or else when changing the source is not feasible.</item><item>Only use an extension method if the functionality being added is a 'core' general feature that would be appropriate to add to the source of the original class. Note - if we have the source to the class being extended, and the maintainer of the original class does not want to add the function, prefer not using an extension method.</item><item>Only put extension methods into core libraries that are available everywhere - extensions that are only available in some code will become a readability issue.</item><item>Be aware that using extension methods always obfuscates the code, so err on the side of not adding them.</item></list><list type="ul"><item>Note - if we have the source to the class being extended, and the maintainer of the original class does not want to add the function, prefer not using an extension method.</item></list><heading level="3">ref and out</heading><list type="ul"><item>Use out for returns that are not also inputs.</item><item>Place out parameters after all other parameters in the method definition.</item><item>ref should be used rarely, when mutating an input is necessary.</item><item>Do not use ref as an optimisation for passing structs.</item><item>Do not use ref to pass a modifiable container into a method. ref is only required when the supplied container needs be replaced with an entirely different container instance.</item></list><heading level="3">LINQ</heading><list type="ul"><item>In general, prefer single line LINQ calls and imperative code, rather than long chains of LINQ. Mixing imperative code and heavily chained LINQ is often hard to read.</item><item>Prefer member extension methods over SQL-style LINQ keywords - e.g. prefer myList.Where(x) to myList where x.</item><item>Avoid Container.ForEach(...) for anything longer than a single statement.</item></list><heading level="3">Array vs List</heading><list type="ul"><item>In general, prefer List<> over arrays for public variables, properties, and return types (keeping in mind the guidance on IList / IEnumerable / IReadOnlyList above).</item><item>Prefer List<> when the size of the container can change.</item><item>Prefer arrays when the size of the container is fixed and known at construction time.</item><item>Prefer array for multidimensional arrays.</item><item>Note: array and List<> both represent linear, contiguous containers. Similar to C++ arrays vs std::vector, arrays are of fixed capacity, whereas List<> can be added to. In some cases arrays are more performant, but in general List<> is more flexible.</item></list><list type="ul"><item>array and List<> both represent linear, contiguous containers.</item><item>Similar to C++ arrays vs std::vector, arrays are of fixed capacity, whereas List<> can be added to.</item><item>In some cases arrays are more performant, but in general List<> is more flexible.</item></list><heading level="3">Folders and file locations</heading><list type="ul"><item>Be consistent with the project.</item><item>Prefer a flat structure where possible.</item></list><heading level="3">Use of tuple as a return type</heading><list type="ul"><item>In general, prefer a named class type over Tuple<>, particularly when returning complex types.</item></list><heading level="3">String interpolation vs String.Format() vs String.Concat vs operator+</heading><list type="ul"><item>In general, use whatever is easiest to read, particularly for logging and assert messages.</item><item>Be aware that chained operator+ concatenations will be slower and cause significant memory churn.</item><item>If performance is a concern, StringBuilder will be faster for multiple string concatenations.</item></list><heading level="3">using</heading><list type="ul"><item>Generally, don't alias long typenames with using. Often this is a sign that a Tuple<> needs to be turned into a class. e.g. using RecordList = List<Tuple<int, float>> should probably be a named class instead.</item><item>Be aware that using statements are only file scoped and so of limited use. Type aliases will not be available for external users.</item></list><list type="ul"><item>e.g. using RecordList = List<Tuple<int, float>> should probably be a named class instead.</item></list><heading level="3">Object Initializer syntax</heading><paragraph>For example:</paragraph><code language="javascript">var x = new SomeClass {
  Property1 = value1,
  Property2 = value2,
};
</code><list type="ul"><item>Object Initializer Syntax is fine for 'plain old data' types.</item><item>Avoid using this syntax for classes or structs with constructors.</item><item>If splitting across multiple lines, indent one block level.</item></list><heading level="3">Namespace naming</heading><list type="ul"><item>In general, namespaces should be no more than 2 levels deep.</item><item>Don't force file/folder layout to match namespaces.</item><item>For shared library/module code, use namespaces. For leaf 'application' code, such as unity_app, namespaces are not necessary.</item><item>New top-level namespace names must be globally unique and recognizable.</item></list><heading level="3">Default values/null returns for structs</heading><list type="ul"><item>Prefer returning a 'success' boolean value and a struct out value.</item><item>Where performance isn't a concern and the resulting code significantly more readable (e.g. chained null conditional operators vs deeply nested if statements) nullable structs are acceptable.</item><item>Notes: Nullable structs are convenient, but reinforce the general 'null is failure' pattern Google prefers to avoid. We will investigate a StatusOr equivalent in the future, if there is enough demand.</item></list><paragraph>Notes:</paragraph><list type="ul"><item>Nullable structs are convenient, but reinforce the general 'null is failure' pattern Google prefers to avoid. We will investigate a StatusOr equivalent in the future, if there is enough demand.</item></list><heading level="3">Removing from containers while iterating</heading><paragraph>C# (like many other languages) does not provide an obvious mechanism for removing items from containers while iterating. There are a couple of options:</paragraph><list type="ul"><item>If all that is required is to remove items that satisfy some condition, someList.RemoveAll(somePredicate) is recommended.</item><item>If other work needs to be done in the iteration, RemoveAll may not be sufficient. A common alternative pattern is to create a new container outside of the loop, insert items to keep in the new container, and swap the original container with the new one at the end of iteration.</item></list><heading level="3">Calling delegates</heading><list type="ul"><item>When calling a delegate, use Invoke() and use the null conditional operator - e.g. SomeDelegate?.Invoke(). This clearly marks the call at the callsite as 'a delegate that is being called'. The null check is concise and robust against threading race conditions.</item></list><heading level="3">The var keyword</heading><list type="ul"><item>Use of var is encouraged if it aids readability by avoiding type names that are noisy, obvious, or unimportant.</item><item>Encouraged: When the type is obvious - e.g. var apple = new Apple();, or var request = Factory.Create<HttpRequest>(); For transient variables that are only passed directly to other methods - e.g. var item = GetItem(); ProcessItem(item);</item><item>Discouraged: When working with basic types - e.g. var success = true; When working with compiler-resolved built-in numeric types - e.g. var number = 12 * ReturnsFloat(); When users would clearly benefit from knowing the type - e.g. var listOfItems = GetList();</item></list><paragraph>Encouraged:</paragraph><list type="ul"><item>When the type is obvious - e.g. var apple = new Apple();, or var request = Factory.Create<HttpRequest>();</item><item>For transient variables that are only passed directly to other methods - e.g. var item = GetItem(); ProcessItem(item);</item></list><paragraph>Discouraged:</paragraph><list type="ul"><item>When working with basic types - e.g. var success = true;</item><item>When working with compiler-resolved built-in numeric types - e.g. var number = 12 * ReturnsFloat();</item><item>When users would clearly benefit from knowing the type - e.g. var listOfItems = GetList();</item></list><heading level="3">Attributes</heading><list type="ul"><item>Attributes should appear on the line above the field, property, or method they are associated with, separated from the member by a newline.</item><item>Multiple attributes should be separated by newlines. This allows for easier adding and removing of attributes, and ensures each attribute is easy to search for.</item></list><heading level="3">Argument Naming</heading><paragraph>Derived from the Google C++ style guide.</paragraph><paragraph>When the meaning of a function argument is nonobvious, consider one of the following remedies:</paragraph><list type="ul"><item>If the argument is a literal constant, and the same constant is used in multiple function calls in a way that tacitly assumes they're the same, use a named constant to make that constraint explicit, and to guarantee that it holds.</item><item>Consider changing the function signature to replace a bool argument with an enum argument. This will make the argument values self-describing.</item><item>Replace large or complex nested expressions with named variables.</item><item>Consider using Named Arguments to clarify argument meanings at the call site.</item><item>For functions that have several configuration options, consider defining a single class or struct to hold all the options and pass an instance of that. This approach has several advantages. Options are referenced by name at the call site, which clarifies their meaning. It also reduces function argument count, which makes function calls easier to read and write. As an added benefit, call sites don't need to be changed when another option is added.</item></list><paragraph>Consider the following example:</paragraph><code language="code">// Bad - what are these arguments?
DecimalNumber product = CalculateProduct(values, 7, false, null);
</code><paragraph>versus:</paragraph><code language="code">// Good
ProductOptions options = new ProductOptions();
options.PrecisionDecimals = 7;
options.UseCache = CacheUsage.DontUseCache;
DecimalNumber product = CalculateProduct(values, options, completionDelegate: null);
</code></content>
</page>
<page url="https://google.github.io/styleguide/jsguide.html">
<title>Google JavaScript Style Guide</title>
<content><heading level="1">Google JavaScript Style Guide</heading><paragraph>Please note: This guide is no longer being updated. Google recommends migrating to TypeScript, and following the TypeScript guide.</paragraph><heading level="2">1 Introduction</heading><paragraph>This document serves as the complete definition of Google's coding standards for source code in the JavaScript programming language. A JavaScript source file is described as being in Google Style if and only if it adheres to the rules herein.</paragraph><paragraph>Like other programming style guides, the issues covered span not only aesthetic issues of formatting, but other types of conventions or coding standards as well. However, this document focuses primarily on the hard-and-fast rules that we follow universally, and avoids giving advice that isn't clearly enforceable (whether by human or tool).</paragraph><heading level="3">1.1 Terminology notes</heading><paragraph>In this document, unless otherwise clarified:</paragraph><list type="ol"><item>The term comment always refers to implementation comments. We do not use the phrase documentation comments, instead using the common term "JSDoc" for both human-readable text and machine-readable annotations within /** … */.</item><item>This Style Guide uses RFC 2119 terminology when using the phrases must, must not, should, should not, and may. The terms prefer and avoid correspond to should and should not, respectively. Imperative and declarative statements are prescriptive and correspond to must.</item></list><paragraph>The term comment always refers to implementation comments. We do not use the phrase documentation comments, instead using the common term "JSDoc" for both human-readable text and machine-readable annotations within /** … */.</paragraph><paragraph>This Style Guide uses RFC 2119 terminology when using the phrases must, must not, should, should not, and may. The terms prefer and avoid correspond to should and should not, respectively. Imperative and declarative statements are prescriptive and correspond to must.</paragraph><paragraph>Other terminology notes will appear occasionally throughout the document.</paragraph><heading level="3">1.2 Guide notes</heading><paragraph>Example code in this document is non-normative. That is, while the examples are in Google Style, they may not illustrate the only stylish way to represent the code. Optional formatting choices made in examples must not be enforced as rules.</paragraph><heading level="2">2 Source file basics</heading><heading level="3">2.1 File name</heading><paragraph>File names must be all lowercase and may include underscores (_) or dashes (-), but no additional punctuation. Follow the convention that your project uses. Filenames' extension must be .js.</paragraph><heading level="3">2.2 File encoding: UTF-8</heading><paragraph>Source files are encoded in UTF-8.</paragraph><heading level="3">2.3 Special characters</heading><heading level="4">2.3.1 Whitespace characters</heading><paragraph>Aside from the line terminator sequence, the ASCII horizontal space character (0x20) is the only whitespace character that appears anywhere in a source file. This implies that</paragraph><list type="ol"><item>All other whitespace characters in string literals are escaped, and</item><item>Tab characters are not used for indentation.</item></list><paragraph>All other whitespace characters in string literals are escaped, and</paragraph><paragraph>Tab characters are not used for indentation.</paragraph><heading level="4">2.3.2 Special escape sequences</heading><paragraph>For any character that has a special escape sequence (\', \", \\, \b, \f, \n, \r, \t, \v), that sequence is used rather than the corresponding numeric escape (e.g \x0a, \u000a, or \u{a}). Legacy octal escapes are never used.</paragraph><heading level="4">2.3.3 Non-ASCII characters</heading><paragraph>For the remaining non-ASCII characters, either the actual Unicode character (e.g. ∞) or the equivalent hex or Unicode escape (e.g. \u221e) is used, depending only on which makes the code easier to read and understand.</paragraph><paragraph>Tip: In the Unicode escape case, and occasionally even when actual Unicode characters are used, an explanatory comment can be very helpful.</paragraph><code language="javascript">/* Best: perfectly clear even without a comment. */
const units = 'μs';

/* Allowed: but unnecessary as μ is a printable character. */
const units = '\u03bcs'; // 'μs'

/* Good: use escapes for non-printable characters with a comment for clarity. */
return '\ufeff' + content;  // Prepend a byte order mark.
</code><code language="javascript">/* Poor: the reader has no idea what character this is. */
const units = '\u03bcs';
</code><paragraph>Tip: Never make your code less readable simply out of fear that some programs might not handle non-ASCII characters properly. If that happens, those programs are broken and they must be fixed.</paragraph><heading level="2">3 Source file structure</heading><paragraph>All new source files should either be a goog.module file (a file containing a goog.module call) or an ECMAScript (ES) module (uses import and export statements).</paragraph><paragraph>Files consist of the following, in order:</paragraph><list type="ol"><item>License or copyright information, if present</item><item>@fileoverview JSDoc, if present</item><item>goog.module statement, if a goog.module file</item><item>ES import statements, if an ES module</item><item>goog.require and goog.requireType statements</item><item>The file's implementation</item></list><paragraph>Exactly one blank line separates each section that is present, except the file's implementation, which may be preceded by 1 or 2 blank lines.</paragraph><heading level="3">3.1 License or copyright information, if present</heading><paragraph>If license or copyright information belongs in a file, it belongs here.</paragraph><heading level="3">3.2 @fileoverview JSDoc, if present</heading><paragraph>See ?? for formatting rules.</paragraph><heading level="3">3.3 goog.module statement</heading><paragraph>All goog.module files must declare exactly one goog.module name on a single line: lines containing a goog.module declaration must not be wrapped, and are therefore an exception to the 80-column limit.</paragraph><paragraph>The entire argument to goog.module is what defines a namespace. It is the package name (an identifier that reflects the fragment of the directory structure where the code lives) plus, optionally, the main class/enum/interface that it defines concatenated to the end in lowerCamelCase.</paragraph><paragraph>Example:</paragraph><code language="code">goog.module('search.urlHistory.urlHistoryService');
</code><heading level="4">3.3.1 Hierarchy</heading><paragraph>Module namespaces may never be named as a direct child of another module's namespace.</paragraph><paragraph>Disallowed:</paragraph><code language="code">goog.module('foo.bar');   // 'foo.bar.qux' would be fine, though
goog.module('foo.bar.baz');
</code><paragraph>The directory hierarchy reflects the namespace hierarchy, so that deeper-nested children are subdirectories of higher-level parent directories. Note that this implies that owners of "parent" namespace groups are necessarily aware of all child namespaces, since they exist in the same directory.</paragraph><heading level="4">3.3.2 goog.module.declareLegacyNamespace</heading><paragraph>The single goog.module statement may optionally be followed by a call to goog.module.declareLegacyNamespace();. Avoid goog.module.declareLegacyNamespace() when possible.</paragraph><paragraph>Example:</paragraph><code language="code">goog.module('my.test.helpers');
goog.module.declareLegacyNamespace();
goog.setTestOnly();
</code><paragraph>goog.module.declareLegacyNamespace exists to ease the transition from traditional object hierarchy-based namespaces but comes with some naming restrictions. As the child module name must be created after the parent namespace, this name must not be a child or parent of any other goog.module (for example, goog.module('parent'); and goog.module('parent.child'); cannot both exist safely, nor can goog.module('parent'); and goog.module('parent.child.grandchild');).</paragraph><heading level="4">3.3.3 goog.module Exports</heading><paragraph>Classes, enums, functions, constants, and other symbols are exported using the exports object. Exported symbols may be defined directly on the exports object, or else declared locally and exported separately. Symbols are only exported if they are meant to be used outside the module. Non-exported module-local symbols are not declared @private. There is no prescribed ordering for exported and module-local symbols.</paragraph><paragraph>Examples:</paragraph><code language="javascript">const /** !Array<number> */ exportedArray = [1, 2, 3];

const /** !Array<number> */ moduleLocalArray = [4, 5, 6];

/** @return {number} */
function moduleLocalFunction() {
  return moduleLocalArray.length;
}

/** @return {number} */
function exportedFunction() {
  return moduleLocalFunction() * 2;
}

exports = {exportedArray, exportedFunction};
</code><code language="code">/** @const {number} */
exports.CONSTANT_ONE = 1;

/** @const {string} */
exports.CONSTANT_TWO = 'Another constant';
</code><paragraph>Do not annotate the exports object as @const as it is already treated as a constant by the compiler.</paragraph><code language="code">/** @const */
exports = {exportedFunction};
</code><paragraph>Do not use default exports as they don't translate easily to ES module semantics.</paragraph><code language="code">exports = FancyClass;
</code><heading level="3">3.4 ES modules</heading><paragraph>ES modules are files that use the import and export keywords.</paragraph><heading level="4">3.4.1 Imports</heading><paragraph>Import statements must not be line wrapped and are therefore an exception to the 80-column limit.</paragraph><heading level="5">3.4.1.1 Import paths</heading><paragraph>ES module files must use the import statement to import other ES module files. Do not goog.require another ES module.</paragraph><code language="javascript">import './sideeffects.js';

import * as goog from '../closure/goog/goog.js';
import * as parent from '../parent.js';

import {name} from './sibling.js';
</code><heading level="6">3.4.1.1.1 File extensions in import paths</heading><paragraph>The .js file extension is not optional in import paths and must always be included.</paragraph><code language="javascript">import '../directory/file';
</code><code language="javascript">import '../directory/file.js';
</code><heading level="5">3.4.1.2 Importing the same file multiple times</heading><paragraph>Do not import the same file multiple times. This can make it hard to determine the aggregate imports of a file.</paragraph><code language="javascript">// Imports have the same path, but since it doesn't align it can be hard to see.
import {short} from './long/path/to/a/file.js';
import {aLongNameThatBreaksAlignment} from './long/path/to/a/file.js';
</code><heading level="5">3.4.1.3 Naming imports</heading><heading level="6">3.4.1.3.1 Naming module imports</heading><paragraph>Module import names (import * as name) are lowerCamelCase names that are derived from the imported file name.</paragraph><code language="javascript">import * as fileOne from '../file-one.js';
import * as fileTwo from '../file_two.js';
import * as fileThree from '../filethree.js';
</code><code language="javascript">import * as libString from './lib/string.js';
import * as math from './math/math.js';
import * as vectorMath from './vector/math.js';
</code><paragraph>Some libraries might commonly use a namespace import prefix that violates this naming scheme, but overbearingly common open source use makes the violating style more readable. The only library that currently falls under this exception is threejs, using the THREE prefix.</paragraph><heading level="6">3.4.1.3.2 Naming default imports</heading><paragraph>Default import names are derived from the imported file name and follow the rules in ??.</paragraph><code language="javascript">import MyClass from '../my-class.js';
import myFunction from '../my_function.js';
import SOME_CONSTANT from '../someconstant.js';
</code><paragraph>Note: In general this should not happen as default exports are banned by this style guide, see ??. Default imports are only used to import modules that do not conform to this style guide.</paragraph><heading level="6">3.4.1.3.3 Naming named imports</heading><paragraph>In general symbols imported via the named import (import {name}) should keep the same name. Avoid aliasing imports (import {SomeThing as SomeOtherThing}). Prefer fixing name collisions by using a module import (import *) or renaming the exports themselves.</paragraph><code language="javascript">import * as bigAnimals from './biganimals.js';
import * as domesticatedAnimals from './domesticatedanimals.js';

new bigAnimals.Cat();
new domesticatedAnimals.Cat();
</code><paragraph>If renaming a named import is needed then use components of the imported module's file name or path in the resulting alias.</paragraph><code language="javascript">import {Cat as BigCat} from './biganimals.js';
import {Cat as DomesticatedCat} from './domesticatedanimals.js';

new BigCat();
new DomesticatedCat();
</code><heading level="4">3.4.2 Exports</heading><paragraph>Symbols are only exported if they are meant to be used outside the module. Non-exported module-local symbols are not declared @private. There is no prescribed ordering for exported and module-local symbols.</paragraph><heading level="5">3.4.2.1 Named vs default exports</heading><paragraph>Use named exports in all code. You can apply the export keyword to a declaration, or use the export {name}; syntax.</paragraph><paragraph>Do not use default exports. Importing modules must give a name to these values, which can lead to inconsistencies in naming across modules.</paragraph><code language="javascript">// Do not use default exports:
export default class Foo { ... } // BAD!
</code><code language="javascript">// Use named exports:
export class Foo { ... }
</code><code language="javascript">// Alternate style named exports:
class Foo { ... }

export {Foo};
</code><heading level="5">3.4.2.2 Mutability of exports</heading><paragraph>Exported variables must not be mutated outside of module initialization.</paragraph><paragraph>There are alternatives if mutation is needed, including exporting a constant reference to an object that has mutable fields or exporting accessor functions for mutable data.</paragraph><code language="javascript">// Bad: both foo and mutateFoo are exported and mutated.
export let /** number */ foo = 0;

/**
 * Mutates foo.
 */
export function mutateFoo() {
  ++foo;
}

/**
 * @param {function(number): number} newMutateFoo
 */
export function setMutateFoo(newMutateFoo) {
  // Exported classes and functions can be mutated!
  mutateFoo = () => {
    foo = newMutateFoo(foo);
  };
}
</code><code language="javascript">// Good: Rather than export the mutable variables foo and mutateFoo directly,
// instead make them module scoped and export a getter for foo and a wrapper for
// mutateFooFunc.
let /** number */ foo = 0;
let /** function(number): number */ mutateFooFunc = (foo) => foo + 1;

/** @return {number} */
export function getFoo() {
  return foo;
}

export function mutateFoo() {
  foo = mutateFooFunc(foo);
}

/** @param {function(number): number} mutateFoo */
export function setMutateFoo(mutateFoo) {
  mutateFooFunc = mutateFoo;
}
</code><heading level="5">3.4.2.3 export from</heading><paragraph>export from statements must not be line wrapped and are therefore an exception to the 80-column limit. This applies to both export from flavors.</paragraph><code language="javascript">export {specificName} from './other.js';
export * from './another.js';
</code><heading level="4">3.4.3 Circular Dependencies in ES modules</heading><paragraph>Do not create cycles between ES modules, even though the ECMAScript specification allows this. Note that it is possible to create cycles with both the import and export statements.</paragraph><code language="javascript">// a.js
import './b.js';
</code><code language="javascript">// b.js
import './a.js';

// `export from` can cause circular dependencies too!
export {x} from './c.js';
</code><code language="javascript">// c.js
import './b.js';

export let x;
</code><heading level="4">3.4.4 Interoperating with Closure</heading><heading level="5">3.4.4.1 Referencing goog</heading><paragraph>To reference the Closure goog namespace, import Closure's goog.js.</paragraph><code language="javascript">import * as goog from '../closure/goog/goog.js';

const {compute} = goog.require('a.name');

export const CONSTANT = compute();
</code><paragraph>goog.js exports only a subset of properties from the global goog that can be used in ES modules.</paragraph><heading level="5">3.4.4.2 goog.require in ES modules</heading><paragraph>goog.require in ES modules works as it does in goog.module files. You can require any Closure namespace symbol (i.e., symbols created by goog.provide or goog.module) and goog.require will return the value.</paragraph><code language="javascript">import * as goog from '../closure/goog/goog.js';
import * as anEsModule from './anEsModule.js';

const GoogPromise = goog.require('goog.Promise');
const myNamespace = goog.require('my.namespace');
</code><heading level="5">3.4.4.3 Declaring Closure Module IDs in ES modules</heading><paragraph>goog.declareModuleId can be used within ES modules to declare a goog.module-like module ID. This means that this module ID can be goog.required, goog.module.getd etc. as if it were a goog.module that did not call goog.module.declareLegacyNamespace. It does not create the module ID as a globally available JavaScript symbol.</paragraph><paragraph>A goog.require (or goog.module.get) for a module ID from goog.declareModuleId will always return the module object (as if it was import *'d). As a result, the argument to goog.declareModuleId should always end with a lowerCamelCaseName.</paragraph><paragraph>Note: It is an error to call goog.module.declareLegacyNamespace in an ES module, it can only be called from goog.module files. There is no direct way to associate a legacy namespace with an ES module.</paragraph><paragraph>goog.declareModuleId should only be used to upgrade Closure files to ES modules in place, where named exports are used.</paragraph><code language="javascript">import * as goog from '../closure/goog.js';

goog.declareModuleId('my.esm');

export class Class {};
</code><heading level="3">3.5 goog.setTestOnly</heading><paragraph>In a goog.module file the goog.module statement and, if present, goog.module.declareLegacyNamespace() statement may optionally be followed by a call to goog.setTestOnly().</paragraph><paragraph>In an ES module the import statements may optionally be followed by a call to goog.setTestOnly().</paragraph><heading level="3">3.6 goog.require and goog.requireType statements</heading><paragraph>Imports are done with goog.require and goog.requireType statements. The names imported by a goog.require statement may be used both in code and in type annotations, while those imported by a goog.requireType may be used in type annotations only.</paragraph><paragraph>The goog.require and goog.requireType statements form a contiguous block with no empty lines. This block follows the goog.module declaration separated by a single empty line. The entire argument to goog.require or goog.requireType is a namespace defined by a goog.module in a separate file. goog.require and goog.requireType statements may not appear anywhere else in the file.</paragraph><paragraph>Each goog.require or goog.requireType is assigned to a single constant alias, or else destructured into several constant aliases. These aliases are the only acceptable way to refer to dependencies in type annotations or code. Fully qualified namespaces must not be used anywhere, except as an argument to goog.require or goog.requireType.</paragraph><paragraph>Exception: Types, variables, and functions declared in externs files have to use their fully qualified name in type annotations and code.</paragraph><paragraph>When goog.require is assigned to a single constant alias, it must match the final dot-separated component of the imported module's namespace.</paragraph><paragraph>Exception: In certain cases, additional components of the namespace can be used to form a longer alias. The resulting alias must retain the original identifier's casing such that it still correctly identifies its type. Longer aliases may be used to disambiguate otherwise identical aliases, or if it significantly improves readability. In addition, a longer alias must be used to prevent masking native types such as Element, Event, Error, Map, and Promise (for a more complete list, see Standard Built-in Objects and Web APIs at MDN).</paragraph><paragraph>When renaming destructured aliases, a space must follow the colon as required in</paragraph><paragraph>.</paragraph><paragraph>A file should not contain both a goog.require and a goog.requireType statement for the same namespace. If the imported name is used both in code and in type annotations, it should be imported by a single goog.require statement.</paragraph><paragraph>If a module is imported only for its side effects, the call must be a goog.require (not a goog.requireType) and assignment may be omitted. A comment is required to explain why this is needed and suppress a compiler warning.</paragraph><paragraph>The lines are sorted according to the following rules: All requires with a name on the left hand side come first, sorted alphabetically by those names. Then destructuring requires, again sorted by the names on the left hand side. Finally, any require calls that are standalone (generally these are for modules imported just for their side effects).</paragraph><paragraph>Tip: There's no need to memorize this order and enforce it manually. You can rely on your IDE to report requires that are not sorted correctly.</paragraph><paragraph>If a long alias or module name would cause a line to exceed the 80-column limit, it must not be wrapped: require lines are an exception to the 80-column limit.</paragraph><paragraph>Example:</paragraph><code language="javascript">// Standard alias style.
const asserts = goog.require('goog.asserts');
// Namespace-based alias used to disambiguate.
const testingAsserts = goog.require('goog.testing.asserts');
// Standard destructuring into aliases.
const {MyClass} = goog.require('some.package');
const {MyType} = goog.requireType('other.package');
const {clear, clone} = goog.require('goog.array');
const {Rgb} = goog.require('goog.color');
// Namespace-based destructuring into aliases used to disambiguate.
const {MyClass: NsMyClass} = goog.require('other.ns');
const {SomeType: FooSomeType} = goog.requireType('foo.types');
const {clear: objectClear, clone: objectClone} = goog.require('goog.object');
// Namespace-based destructuring into aliases used to prevent masking native type.
const {Element: RendererElement} = goog.require('web.renderer');
// Out of sequence namespace-based aliases used to improve readability.
// Also, require lines longer than 80 columns must not be wrapped.
const {SomeDataStructure: SomeDataStructureModel} = goog.requireType('identical.package.identifiers.models');
const {SomeDataStructure: SomeDataStructureProto} = goog.require('proto.identical.package.identifiers');
// goog.require without an alias in order to trigger side effects.
/** @suppress {extraRequire} Initializes MyFramework. */
goog.require('my.framework.initialization');
</code><paragraph>Discouraged:</paragraph><code language="javascript">// Some legacy code uses a "default export" style to export a single class, enum,
// record type, etc. Do not use this pattern in new JS.
// When using a "default export", prefer destructuring into aliases.
const MyClass = goog.require('some.package.MyClass');
const MyType = goog.requireType('some.package.MyType');
</code><code language="javascript">// If necessary to disambiguate, prefer PackageClass over SomeClass as it is
// closer to the format of the module name.
const SomeClass = goog.require('some.package.Class');
</code><paragraph>Disallowed:</paragraph><code language="javascript">// Extra terms must come from the namespace.
const MyClassForBizzing = goog.require('some.package.MyClass');
// Alias must include the entire final namespace component.
const MyClass = goog.require('some.package.MyClassForBizzing');
// Alias must not mask native type (should be `const JspbMap` here).
const Map = goog.require('jspb.Map');
// Don't break goog.require lines over 80 columns.
const SomeDataStructure =
    goog.require('proto.identical.package.identifiers.SomeDataStructure');
// Alias must be based on the namespace.
const randomName = goog.require('something.else');
// Missing a space after the colon.
const {Foo:FooProto} = goog.require('some.package.proto.Foo');
// goog.requireType without an alias.
goog.requireType('some.package.with.a.Type');


/**
 * @param {!some.unimported.Dependency} param All external types used in JSDoc
 *     annotations must be goog.require'd, unless declared in externs.
 */
function someFunction(param) {
  // goog.require lines must be at the top level before any other code.
  const alias = goog.require('my.long.name.alias');
  // ...
}
</code><heading level="3">3.7 The file's implementation</heading><paragraph>The actual implementation follows after all dependency information is declared (separated by at least one blank line).</paragraph><paragraph>This may consist of any module-local declarations (constants, variables, classes, functions, etc), as well as any exported symbols.</paragraph><heading level="2">4 Formatting</heading><paragraph>Terminology Note: block-like construct refers to the body of a class, function, method, or brace-delimited block of code. Note that, by ?? and ??, any array or object literal may optionally be treated as if it were a block-like construct.</paragraph><paragraph>Tip: Use clang-format. The JavaScript community has invested effort to make sure clang-format does the right thing on JavaScript files. clang-format has integration with several popular editors.</paragraph><heading level="3">4.1 Braces</heading><heading level="4">4.1.1 Braces are used for all control structures</heading><paragraph>Braces are required for all control structures (i.e. if, else, for, do, while, as well as any others), even if the body contains only a single statement. The first statement of a non-empty block must begin on its own line.</paragraph><paragraph>Disallowed:</paragraph><code language="code">if (someVeryLongCondition())
  doSomething();

for (let i = 0; i < foo.length; i++) bar(foo[i]);
</code><paragraph>Exception: A simple if statement that can fit entirely on a single line with no wrapping (and that doesn't have an else) may be kept on a single line with no braces when it improves readability. This is the only case in which a control structure may omit braces and newlines.</paragraph><code language="code">if (shortCondition()) foo();
</code><heading level="4">4.1.2 Nonempty blocks: K&R style</heading><paragraph>Braces follow the Kernighan and Ritchie style (Egyptian brackets) for nonempty blocks and block-like constructs:</paragraph><list type="ul"><item>No line break before the opening brace.</item><item>Line break after the opening brace.</item><item>Line break before the closing brace.</item><item>Line break after the closing brace if that brace terminates a statement or the body of a function or class statement, or a class method. Specifically, there is no line break after the brace if it is followed by else, catch, while, or a comma, semicolon, or right-parenthesis.</item></list><paragraph>Example:</paragraph><code language="javascript">class InnerClass {
  constructor() {}

  /** @param {number} foo */
  method(foo) {
    if (condition(foo)) {
      try {
        // Note: this might fail.
        something();
      } catch (err) {
        recover();
      }
    }
  }
}
</code><heading level="4">4.1.3 Empty blocks: may be concise</heading><paragraph>An empty block or block-like construct may be closed immediately after it is opened, with no characters, space, or line break in between (i.e. {}), unless it is a part of a multi-block statement (one that directly contains multiple blocks: if/else or try/catch/finally).</paragraph><paragraph>Example:</paragraph><code language="javascript">function doNothing() {}
</code><paragraph>Disallowed:</paragraph><code language="javascript">if (condition) {
  // …
} else if (otherCondition) {} else {
  // …
}

try {
  // …
} catch (e) {}
</code><heading level="3">4.2 Block indentation: +2 spaces</heading><paragraph>Each time a new block or block-like construct is opened, the indent increases by two spaces. When the block ends, the indent returns to the previous indent level. The indent level applies to both code and comments throughout the block. (See the example in ??).</paragraph><heading level="4">4.2.1 Array literals: optionally block-like</heading><paragraph>Any array literal may optionally be formatted as if it were a "block-like construct." For example, the following are all valid (not an exhaustive list):</paragraph><code language="javascript">const a = [
  0,
  1,
  2,
];

const b =
    [0, 1, 2];

</code><code language="javascript">const c = [0, 1, 2];

someMethod(foo, [
  0, 1, 2,
], bar);
</code><paragraph>Other combinations are allowed, particularly when emphasizing semantic groupings between elements, but should not be used only to reduce the vertical size of larger arrays.</paragraph><heading level="4">4.2.2 Object literals: optionally block-like</heading><paragraph>Any object literal may optionally be formatted as if it were a "block-like construct." The same examples apply as ??. For example, the following are all valid (not an exhaustive list):</paragraph><code language="javascript">const a = {
  a: 0,
  b: 1,
};

const b =
    {a: 0, b: 1};
</code><code language="javascript">const c = {a: 0, b: 1};

someMethod(foo, {
  a: 0, b: 1,
}, bar);
</code><heading level="4">4.2.3 Class literals</heading><paragraph>Class literals (whether declarations or expressions) are indented as blocks. Do not add semicolons after methods, or after the closing brace of a class declaration (statements—such as assignments—that contain class expressions are still terminated with a semicolon). For inheritance, the extends keyword is sufficient unless the superclass is templatized. Subclasses of templatized types must explicitly specify the template type in an @extends JSDoc annotation, even if it is just passing along the same template name.</paragraph><paragraph>Example:</paragraph><code language="javascript">/** @template T */
class Foo {
  /** @param {T} x */
  constructor(x) {
    /** @type {T} */
    this.x = x;
  }
}

/** @extends {Foo<number>} */
class Bar extends Foo {
  constructor() {
    super(42);
  }
}

exports.Baz = class extends Bar {
  /** @return {number} */
  method() {
    return this.x;
  }
};
</code><code language="javascript">/** @extends {Bar} */ // <-- unnecessary @extends
exports.Baz = class extends Bar {
  /** @return {number} */
  method() {
    return this.x;
  }
};
</code><heading level="4">4.2.4 Function expressions</heading><paragraph>When declaring an anonymous function in the list of arguments for a function call, the body of the function is indented two spaces more than the preceding indentation depth.</paragraph><paragraph>Example:</paragraph><code language="javascript">prefix.something.reallyLongFunctionName('whatever', (a1, a2) => {
  // Indent the function body +2 relative to indentation depth
  // of the 'prefix' statement one line above.
  if (a1.equals(a2)) {
    someOtherLongFunctionName(a1);
  } else {
    andNowForSomethingCompletelyDifferent(a2.parrot);
  }
});

some.reallyLongFunctionCall(arg1, arg2, arg3)
    .thatsWrapped()
    .then((result) => {
      // Indent the function body +2 relative to the indentation depth
      // of the '.then()' call.
      if (result) {
        result.use();
      }
    });
</code><heading level="4">4.2.5 Switch statements</heading><paragraph>As with any other block, the contents of a switch block are indented +2.</paragraph><paragraph>After a switch label, a newline appears, and the indentation level is increased +2, exactly as if a block were being opened. An explicit block may be used if required by lexical scoping. The following switch label returns to the previous indentation level, as if a block had been closed.</paragraph><paragraph>A blank line is optional between a break and the following case.</paragraph><paragraph>Example:</paragraph><code language="javascript">switch (animal) {
  case Animal.BANDERSNATCH:
    handleBandersnatch();
    break;

  case Animal.JABBERWOCK:
    handleJabberwock();
    break;

  default:
    throw new Error('Unknown animal');
}
</code><heading level="3">4.3 Statements</heading><heading level="4">4.3.1 One statement per line</heading><paragraph>Each statement is followed by a line-break.</paragraph><heading level="4">4.3.2 Semicolons are required</heading><paragraph>Every statement must be terminated with a semicolon. Relying on automatic semicolon insertion is forbidden.</paragraph><heading level="3">4.4 Column limit: 80</heading><paragraph>JavaScript code has a column limit of 80 characters. Except as noted below, any line that would exceed this limit must be line-wrapped, as explained in ??.</paragraph><paragraph>Exceptions:</paragraph><list type="ol"><item>goog.module, goog.require and goog.requireType statements (see ?? and ??).</item><item>ES module import and export from statements (see ?? and ??).</item><item>Lines where obeying the column limit is not possible or would hinder discoverability. Examples include: A long URL which should be clickable in source. A shell command intended to be copied-and-pasted. A long string literal which may need to be copied or searched for wholly (e.g., a long file path).</item></list><list type="ul"><item>A long URL which should be clickable in source.</item><item>A shell command intended to be copied-and-pasted.</item><item>A long string literal which may need to be copied or searched for wholly (e.g., a long file path).</item></list><heading level="3">4.5 Line-wrapping</heading><paragraph>Terminology Note: Line wrapping is breaking a chunk of code into multiple lines to obey column limit, where the chunk could otherwise legally fit in a single line.</paragraph><paragraph>There is no comprehensive, deterministic formula showing exactly how to line-wrap in every situation. Very often there are several valid ways to line-wrap the same piece of code.</paragraph><paragraph>Note: While the typical reason for line-wrapping is to avoid overflowing the column limit, even code that would in fact fit within the column limit may be line-wrapped at the author's discretion.</paragraph><paragraph>Tip: Extracting a method or local variable may solve the problem without the need to line-wrap.</paragraph><heading level="4">4.5.1 Where to break</heading><paragraph>The prime directive of line-wrapping is: prefer to break at a higher syntactic level.</paragraph><paragraph>Preferred:</paragraph><code language="code">currentEstimate =
    calc(currentEstimate + x * currentEstimate) /
        2.0;
</code><paragraph>Discouraged:</paragraph><code language="code">currentEstimate = calc(currentEstimate + x *
    currentEstimate) / 2.0;
</code><paragraph>In the preceding example, the syntactic levels from highest to lowest are as follows: assignment, division, function call, parameters, number constant.</paragraph><paragraph>Operators are wrapped as follows:</paragraph><list type="ol"><item>When a line is broken at an operator the break comes after the symbol. (Note that this is not the same practice used in Google style for Java.) This does not apply to the dot (.), which is not actually an operator.</item><item>A method or constructor name stays attached to the open parenthesis (() that follows it.</item><item>A comma (,) stays attached to the token that precedes it.</item><item>A line break is never added between a return and the return value as this would change the meaning of the code.</item><item>JSDoc annotations with type names break after {. This is necessary as annotations with optional types (@const, @private, @param, etc) do not scan the next line.</item></list><list type="ol"><item>This does not apply to the dot (.), which is not actually an operator.</item></list><paragraph>Note: The primary goal for line wrapping is to have clear code, not necessarily code that fits in the smallest number of lines.</paragraph><heading level="4">4.5.2 Indent continuation lines at least +4 spaces</heading><paragraph>When line-wrapping, each line after the first (each continuation line) is indented at least +4 from the original line, unless it falls under the rules of block indentation.</paragraph><paragraph>When there are multiple continuation lines, indentation may be varied beyond +4 as appropriate. In general, continuation lines at a deeper syntactic level are indented by larger multiples of 4, and two lines use the same indentation level if and only if they begin with syntactically parallel elements.</paragraph><paragraph>?? addresses the discouraged practice of using a variable number of spaces to align certain tokens with previous lines.</paragraph><heading level="3">4.6 Whitespace</heading><heading level="4">4.6.1 Vertical whitespace</heading><paragraph>A single blank line appears:</paragraph><list type="ol"><item>Between consecutive methods in a class or object literal Exception: A blank line between two consecutive properties definitions in an object literal (with no other code between them) is optional. Such blank lines are used as needed to create logical groupings of fields.</item><item>Within method bodies, sparingly to create logical groupings of statements. Blank lines at the start or end of a function body are not allowed.</item><item>Optionally before the first or after the last method in a class or object literal (neither encouraged nor discouraged).</item><item>As required by other sections of this document (e.g. ??).</item></list><list type="ol"><item>Exception: A blank line between two consecutive properties definitions in an object literal (with no other code between them) is optional. Such blank lines are used as needed to create logical groupings of fields.</item></list><paragraph>Multiple consecutive blank lines are permitted, but never required (nor encouraged).</paragraph><heading level="4">4.6.2 Horizontal whitespace</heading><paragraph>Use of horizontal whitespace depends on location, and falls into three broad categories: leading (at the start of a line), trailing (at the end of a line), and internal. Leading whitespace (i.e., indentation) is addressed elsewhere. Trailing whitespace is forbidden.</paragraph><paragraph>Beyond where required by the language or other style rules, and apart from literals, comments, and JSDoc, a single internal ASCII space also appears in the following places only.</paragraph><list type="ol"><item>Separating any reserved word (such as if, for, or catch) except for function and super, from an open parenthesis (() that follows it on that line.</item><item>Separating any reserved word (such as else or catch) from a closing curly brace (}) that precedes it on that line.</item><item>Before any open curly brace ({), with two exceptions: Before an object literal that is the first argument of a function or the first element in an array literal (e.g. foo({a: [{c: d}]})). In a template expansion, as it is forbidden by the language (e.g. valid: `ab${1 + 2}cd`, invalid: `xy$ {3}z`).</item><item>On both sides of any binary or ternary operator.</item><item>After a comma (,) or semicolon (;). Note that spaces are never allowed before these characters.</item><item>After the colon (:) in an object literal.</item><item>On both sides of the double slash (//) that begins an end-of-line comment. Here, multiple spaces are allowed, but not required.</item><item>After an open-block comment character and on both sides of close characters (e.g. for short-form type declarations, casts, and parameter name comments: this.foo = /** @type {number} */ (bar); or function(/** string */ foo) {; or baz(/* buzz= */ true)).</item></list><list type="ol"><item>Before an object literal that is the first argument of a function or the first element in an array literal (e.g. foo({a: [{c: d}]})).</item><item>In a template expansion, as it is forbidden by the language (e.g. valid: `ab${1 + 2}cd`, invalid: `xy$ {3}z`).</item></list><heading level="4">4.6.3 Horizontal alignment: discouraged</heading><paragraph>Terminology Note: Horizontal alignment is the practice of adding a variable number of additional spaces in your code with the goal of making certain tokens appear directly below certain other tokens on previous lines.</paragraph><paragraph>This practice is permitted, but it is generally discouraged by Google Style. It is not even required to maintain horizontal alignment in places where it was already used.</paragraph><paragraph>Here is an example without alignment, followed by one with alignment. Both are allowed, but the latter is discouraged:</paragraph><code language="javascript">{
  tiny: 42, // this is great
  longer: 435, // this too
};

{
  tiny:   42,  // permitted, but future edits
  longer: 435, // may leave it unaligned
};
</code><paragraph>Tip: Alignment can aid readability, but it creates problems for future maintenance. Consider a future change that needs to touch just one line. This change may leave the formerly-pleasing formatting mangled, and that is allowed. More often it prompts the coder (perhaps you) to adjust whitespace on nearby lines as well, possibly triggering a cascading series of reformattings. That one-line change now has a blast radius. This can at worst result in pointless busywork, but at best it still corrupts version history information, slows down reviewers and exacerbates merge conflicts.</paragraph><heading level="4">4.6.4 Function arguments</heading><paragraph>Prefer to put all function arguments on the same line as the function name. If doing so would exceed the 80-column limit, the arguments must be line-wrapped in a readable way. To save space, you may wrap as close to 80 as possible, or put each argument on its own line to enhance readability. Indentation should be four spaces. Aligning to the parenthesis is allowed, but discouraged. Below are the most common patterns for argument wrapping:</paragraph><code language="javascript">// Arguments start on a new line, indented four spaces. Preferred when the
// arguments don't fit on the same line with the function name (or the keyword
// "function") but fit entirely on the second line. Works with very long
// function names, survives renaming without reindenting, low on space.
doSomething(
    descriptiveArgumentOne, descriptiveArgumentTwo, descriptiveArgumentThree) {
  // …
}

// If the argument list is longer, wrap at 80. Uses less vertical space,
// but violates the rectangle rule and is thus not recommended.
doSomething(veryDescriptiveArgumentNumberOne, veryDescriptiveArgumentTwo,
    tableModelEventHandlerProxy, artichokeDescriptorAdapterIterator) {
  // …
}

// Four-space, one argument per line.  Works with long function names,
// survives renaming, and emphasizes each argument.
doSomething(
    veryDescriptiveArgumentNumberOne,
    veryDescriptiveArgumentTwo,
    tableModelEventHandlerProxy,
    artichokeDescriptorAdapterIterator) {
  // …
}
</code><heading level="3">4.7 Grouping parentheses: recommended</heading><paragraph>Optional grouping parentheses are omitted only when the author and reviewer agree that there is no reasonable chance that the code will be misinterpreted without them, nor would they have made the code easier to read. It is not reasonable to assume that every reader has the entire operator precedence table memorized.</paragraph><paragraph>Do not use unnecessary parentheses around the entire expression following delete, typeof, void, return, throw, case, in, of, or yield.</paragraph><paragraph>Parentheses are required for type casts: /** @type {!Foo} */ (foo).</paragraph><paragraph>This section addresses implementation comments. JSDoc is addressed separately in ??.</paragraph><paragraph>Block comments are indented at the same level as the surrounding code. They may be in /* … */ or //-style. For multi-line /* … */ comments, subsequent lines must start with * aligned with the * on the previous line, to make comments obvious with no extra context.</paragraph><code language="code">/*
 * This is
 * okay.
 */

// And so
// is this.

/* This is fine, too. */
</code><paragraph>Comments are not enclosed in boxes drawn with asterisks or other characters.</paragraph><paragraph>Do not use JSDoc (/** … */) for implementation comments.</paragraph><paragraph>"Parameter name" comments should be used whenever the value and method name do not sufficiently convey the meaning, and refactoring the method to be clearer is infeasible . Their preferred format is before the value with =:</paragraph><code language="code">someFunction(obviousParam, /* shouldRender= */ true, /* name= */ 'hello');
</code><paragraph>For consistency with surrounding code you may put them after the value without =:</paragraph><code language="code">someFunction(obviousParam, true /* shouldRender */, 'hello' /* name */);
</code><heading level="2">5 Language features</heading><paragraph>JavaScript includes many dubious (and even dangerous) features. This section delineates which features may or may not be used, and any additional constraints on their use.</paragraph><paragraph>Language features which are not discussed in this style guide may be used with no recommendations of their usage.</paragraph><heading level="3">5.1 Local variable declarations</heading><heading level="4">5.1.1 Use const and let</heading><paragraph>Declare all local variables with either const or let. Use const by default, unless a variable needs to be reassigned. The var keyword must not be used.</paragraph><heading level="4">5.1.2 One variable per declaration</heading><paragraph>Every local variable declaration declares only one variable: declarations such as let a = 1, b = 2; are not used.</paragraph><heading level="4">5.1.3 Declared when needed, initialized as soon as possible</heading><paragraph>Local variables are not habitually declared at the start of their containing block or block-like construct. Instead, local variables are declared close to the point they are first used (within reason), to minimize their scope, and initialized as soon as possible.</paragraph><heading level="4">5.1.4 Declare types as needed</heading><paragraph>JSDoc type annotations may be added either on the line above the declaration, or else inline before the variable name if no other JSDoc is present.</paragraph><paragraph>Example:</paragraph><code language="javascript">const /** !Array<number> */ data = [];

/**
 * Some description.
 * @type {!Array<number>}
 */
const data = [];
</code><paragraph>Mixing inline and JSDoc styles is not allowed: the compiler will only process the first JsDoc and the inline annotations will be lost.</paragraph><code language="javascript">/** Some description. */
const /** !Array<number> */ data = [];
</code><paragraph>Tip: There are many cases where the compiler can infer a templatized type but not its parameters. This is particularly the case when the initializing literal or constructor call does not include any values of the template parameter type (e.g., empty arrays, objects, Maps, or Sets), or if the variable is modified in a closure. Local variable type annotations are particularly helpful in these cases since otherwise the compiler will infer the template parameter as unknown.</paragraph><heading level="3">5.2 Array literals</heading><heading level="4">5.2.1 Use trailing commas</heading><paragraph>Include a trailing comma whenever there is a line break between the final element and the closing bracket.</paragraph><paragraph>Example:</paragraph><code language="javascript">const values = [
  'first value',
  'second value',
];
</code><heading level="4">5.2.2 Do not use the variadic Array constructor</heading><paragraph>The constructor is error-prone if arguments are added or removed. Use a literal instead.</paragraph><paragraph>Disallowed:</paragraph><code language="javascript">const a1 = new Array(x1, x2, x3);
const a2 = new Array(x1, x2);
const a3 = new Array(x1);
const a4 = new Array();
</code><paragraph>This works as expected except for the third case: if x1 is a whole number then a3 is an array of size x1 where all elements are undefined. If x1 is any other number, then an exception will be thrown, and if it is anything else then it will be a single-element array.</paragraph><paragraph>Instead, write</paragraph><code language="javascript">const a1 = [x1, x2, x3];
const a2 = [x1, x2];
const a3 = [x1];
const a4 = [];
</code><paragraph>Explicitly allocating an array of a given length using new Array(length) is allowed when appropriate.</paragraph><heading level="4">5.2.3 Non-numeric properties</heading><paragraph>Do not define or use non-numeric properties on an array (other than length). Use a Map (or Object) instead.</paragraph><heading level="4">5.2.4 Destructuring</heading><paragraph>Array literals may be used on the left-hand side of an assignment to perform destructuring (such as when unpacking multiple values from a single array or iterable). A final rest element may be included (with no space between the ... and the variable name). Elements should be omitted if they are unused.</paragraph><code language="javascript">const [a, b, c, ...rest] = generateResults();
let [, b,, d] = someArray;
</code><paragraph>Destructuring may also be used for function parameters (note that a parameter name is required but ignored). Always specify [] as the default value if a destructured array parameter is optional, and provide default values on the left hand side:</paragraph><code language="javascript">/** @param {!Array<number>=} param1 */
function optionalDestructuring([a = 4, b = 2] = []) { … };
</code><paragraph>Disallowed:</paragraph><code language="javascript">function badDestructuring([a, b] = [4, 2]) { … };
</code><paragraph>Tip: For (un)packing multiple values into a function's parameter or return, prefer object destructuring to array destructuring when possible, as it allows naming the individual elements and specifying a different type for each.</paragraph><heading level="4">5.2.5 Spread operator</heading><paragraph>Array literals may include the spread operator (...) to flatten elements out of one or more other iterables. The spread operator should be used instead of more awkward constructs with Array.prototype. There is no space after the ....</paragraph><paragraph>Example:</paragraph><code language="code">[...foo]   // preferred over Array.prototype.slice.call(foo)
[...foo, ...bar]   // preferred over foo.concat(bar)
</code><heading level="3">5.3 Object literals</heading><heading level="4">5.3.1 Use trailing commas</heading><paragraph>Include a trailing comma whenever there is a line break between the final property and the closing brace.</paragraph><heading level="4">5.3.2 Do not use the Object constructor</heading><paragraph>While Object does not have the same problems as Array, it is still disallowed for consistency. Use an object literal ({} or {a: 0, b: 1, c: 2}) instead.</paragraph><heading level="4">5.3.3 Do not mix quoted and unquoted keys</heading><paragraph>Object literals may represent either structs (with unquoted keys and/or symbols) or dicts (with quoted and/or computed keys). Do not mix these key types in a single object literal.</paragraph><paragraph>Disallowed:</paragraph><code language="javascript">{
  width: 42, // struct-style unquoted key
  'maxWidth': 43, // dict-style quoted key
}
</code><paragraph>This also extends to passing the property name to functions, like hasOwnProperty. In particular, doing so will break in compiled code because the compiler cannot rename/obfuscate the string literal.</paragraph><paragraph>Disallowed:</paragraph><code language="javascript">/** @type {{width: number, maxWidth: (number|undefined)}} */
const o = {width: 42};
if (o.hasOwnProperty('maxWidth')) {
  ...
}
</code><paragraph>This is best implemented as:</paragraph><code language="javascript">/** @type {{width: number, maxWidth: (number|undefined)}} */
const o = {width: 42};
if (o.maxWidth != null) {
  ...
}
</code><heading level="4">5.3.4 Computed property names</heading><paragraph>Computed property names (e.g., {['key' + foo()]: 42}) are allowed, and are considered dict-style (quoted) keys (i.e., must not be mixed with non-quoted keys) unless the computed property is a symbol (e.g., [Symbol.iterator]). Enum values may also be used for computed keys, but should not be mixed with non-enum keys in the same literal.</paragraph><heading level="4">5.3.5 Method shorthand</heading><paragraph>Methods can be defined on object literals using the method shorthand ({method() {… }}) in place of a colon immediately followed by a function or arrow function literal.</paragraph><paragraph>Example:</paragraph><code language="javascript">return {
  stuff: 'candy',
  method() {
    return this.stuff;  // Returns 'candy'
  },
};
</code><paragraph>Note that this in a method shorthand or function refers to the object literal itself whereas this in an arrow function refers to the scope outside the object literal.</paragraph><paragraph>Example:</paragraph><code language="javascript">class {
  getObjectLiteral() {
    this.stuff = 'fruit';
    return {
      stuff: 'candy',
      method: () => this.stuff,  // Returns 'fruit'
    };
  }
}
</code><heading level="4">5.3.6 Shorthand properties</heading><paragraph>Shorthand properties are allowed on object literals.</paragraph><paragraph>Example:</paragraph><code language="javascript">const foo = 1;
const bar = 2;
const obj = {
  foo,
  bar,
  method() { return this.foo + this.bar; },
};
assertEquals(3, obj.method());
</code><heading level="4">5.3.7 Destructuring</heading><paragraph>Object destructuring patterns may be used on the left-hand side of an assignment to perform destructuring and unpack multiple values from a single object.</paragraph><paragraph>Destructured objects may also be used as function parameters, but should be kept as simple as possible: a single level of unquoted shorthand properties. Deeper levels of nesting and computed properties may not be used in parameter destructuring. Specify any default values in the left-hand-side of the destructured parameter ({str = 'some default'} = {}, rather than {str} = {str: 'some default'}), and if a destructured object is itself optional, it must default to {}. The JSDoc for the destructured parameter may be given any name (the name is unused but is required by the compiler).</paragraph><paragraph>Example:</paragraph><code language="javascript">/**
 * @param {string} ordinary
 * @param {{num: (number|undefined), str: (string|undefined)}=} param1
 *     num: The number of times to do something.
 *     str: A string to do stuff to.
 */
function destructured(ordinary, {num, str = 'some default'} = {}) {}
</code><paragraph>Disallowed:</paragraph><code language="javascript">/** @param {{x: {num: (number|undefined), str: (string|undefined)}}} param1 */
function nestedTooDeeply({x: {num, str}}) {};
/** @param {{num: (number|undefined), str: (string|undefined)}=} param1 */
function nonShorthandProperty({num: a, str: b} = {}) {};
/** @param {{a: number, b: number}} param1 */
function computedKey({a, b, [a + b]: c}) {};
/** @param {{a: number, b: string}=} param1 */
function nontrivialDefault({a, b} = {a: 2, b: 4}) {};
</code><paragraph>Destructuring may also be used for goog.require statements, and in this case must not be wrapped: the entire statement occupies one line, regardless of how long it is (see ??).</paragraph><heading level="4">5.3.8 Enums</heading><paragraph>Enumerations are defined by adding the @enum annotation to an object literal. Enums must be module-local or assigned directly on exports, not nested under a type or object.</paragraph><paragraph>Additional properties may not be added to an enum after it is defined. Enums must be constant. All enum values must be either a string literal or a number.</paragraph><code language="javascript">/**
 * Supported temperature scales.
 * @enum {string}
 */
const TemperatureScale = {
  CELSIUS: 'celsius',
  FAHRENHEIT: 'fahrenheit',
};

/**
 * An enum with two values.
 * @enum {number}
 */
const Value = {
  /** The value used shall have been the first. */
  FIRST_VALUE: 1,
  /** The second among two values. */
  SECOND_VALUE: 2,
};
</code><paragraph>For string enums, all values must be statically initialized and not computed using arithmetic operators, template literal substitution, function calls or even a variable reference.</paragraph><code language="javascript">const ABSOLUTE_ZERO = '-273°F';

/**
 * Not supported computed values in string enum.
 * @enum {string}
 */
const TemperatureInFahrenheit = {
  MIN_POSSIBLE: ABSOLUTE_ZERO,
  ZERO_FAHRENHEIT: 0 + '°F',
  ONE_FAHRENHEIT: `${Values.FIRST_VALUE}°F`,
  TWO_FAHRENHEIT: Values.SECOND_VALUE + '°F',
  SOME_FAHRENHEIT: getTemperatureInFahrenheit() + '°F',
};
</code><paragraph>Note: Although TypeScript supports a few more patterns for enum values (e.g A: 'a'+'b', etc), the restriction of only allowing string literals and numbers for enum values is to aid migration to TypeScript. For complex values consider using a const object without @enum.</paragraph><heading level="3">5.4 Classes</heading><heading level="4">5.4.1 Constructors</heading><paragraph>Constructors are optional. Subclass constructors must call super() before setting any fields or otherwise accessing this. Interfaces should declare non-method properties in the constructor.</paragraph><heading level="4">5.4.2 Fields</heading><paragraph>Define all of a concrete object's fields (i.e. all properties other than methods) in the constructor. Annotate fields that are never reassigned with @const (these need not be deeply immutable). Annotate non-public fields with the proper visibility annotation (@private, @protected, @package). @private fields' names may optionally end with an underscore. Fields must not be defined within a nested scope in the constructor nor on a concrete class's prototype.</paragraph><paragraph>Example:</paragraph><code language="javascript">class Foo {
  constructor() {
    /** @private @const {!Bar} */
    this.bar_ = computeBar();

    /** @protected @const {!Baz} */
    this.baz = computeBaz();
  }
}
</code><paragraph>Tip: Properties should never be added to or removed from an instance after the constructor is finished, since it significantly hinders VMs' ability to optimize. If necessary, fields that are initialized later should be explicitly set to undefined in the constructor to prevent later shape changes. Adding @struct to an object will check that undeclared properties are not added/accessed. Classes have this added by default.</paragraph><heading level="4">5.4.3 Computed properties</heading><paragraph>Computed properties may only be used in classes when the property is a symbol. Dict-style properties (that is, quoted or computed non-symbol keys, as defined in ??) are not allowed. A [Symbol.iterator] method should be defined for any classes that are logically iterable. Beyond this, Symbol should be used sparingly.</paragraph><paragraph>Tip: be careful of using any other built-in symbols (e.g., Symbol.isConcatSpreadable) as they are not polyfilled by the compiler and will therefore not work in older browsers.</paragraph><heading level="4">5.4.4 Static methods</heading><paragraph>Where it does not interfere with readability, prefer module-local functions over private static methods.</paragraph><paragraph>Code should not rely on dynamic dispatch of static methods, because it interferes with Closure Compiler optimizations. Static methods should only be called on the base class itself. Static methods should not be called on variables containing a dynamic instance that may be either the constructor or a subclass constructor (and must be defined with @nocollapse if this is done), and must not be called directly on a subclass that doesn't define the method itself. Do not access this in static methods.</paragraph><paragraph>Disallowed:</paragraph><code language="javascript">// Context for the examples below; by itself this code is allowed.
class Base {
  /** @nocollapse */ static foo() {}
}
class Sub extends Base {}

// discouraged: don't call static methods dynamically
function callFoo(cls) { cls.foo(); }

// Disallowed: don't call static methods on subclasses that don't define it themselves
Sub.foo();

// Disallowed: don't access this in static methods.
class Clazz {
  static foo() {
    return this.staticField;
  }
}
Class.staticField = 1;
</code><heading level="4">5.4.5 Old-style class declarations</heading><paragraph>While ES6 classes are preferred, there are cases where ES6 classes may not be feasible. For example:</paragraph><list type="ol"><item>If there exist or will exist subclasses, including frameworks that create subclasses, that cannot be immediately changed to use ES6 class syntax. If such a class were to use ES6 syntax, all downstream subclasses not using ES6 class syntax would need to be modified.</item><item>Frameworks that require a known this value before calling the superclass constructor, since constructors with ES6 super classes do not have access to the instance this value until the call to super returns.</item></list><paragraph>If there exist or will exist subclasses, including frameworks that create subclasses, that cannot be immediately changed to use ES6 class syntax. If such a class were to use ES6 syntax, all downstream subclasses not using ES6 class syntax would need to be modified.</paragraph><paragraph>Frameworks that require a known this value before calling the superclass constructor, since constructors with ES6 super classes do not have access to the instance this value until the call to super returns.</paragraph><paragraph>In all other ways the style guide still applies to this code: let, const, default parameters, rest, and arrow functions should all be used when appropriate.</paragraph><paragraph>goog.defineClass allows for a class-like definition similar to ES6 class syntax:</paragraph><code language="javascript">let C = goog.defineClass(S, {
  /**
   * @param {string} value
   */
  constructor(value) {
    S.call(this, 2);
    /** @const */
    this.prop = value;
  },

  /**
   * @param {string} param
   * @return {number}
   */
  method(param) {
    return 0;
  },
});
</code><paragraph>Alternatively, while goog.defineClass should be preferred for all new code, more traditional syntax is also allowed.</paragraph><code language="javascript">/**
  * @constructor @extends {S}
  * @param {string} value
  */
function C(value) {
  S.call(this, 2);
  /** @const */
  this.prop = value;
}
goog.inherits(C, S);

/**
 * @param {string} param
 * @return {number}
 */
C.prototype.method = function(param) {
  return 0;
};
</code><paragraph>Per-instance properties should be defined in the constructor after the call to the super class constructor, if there is a super class. Methods should be defined on the prototype of the constructor.</paragraph><paragraph>Defining constructor prototype hierarchies correctly is harder than it first appears! For that reason, it is best to use goog.inherits from the Closure Library .</paragraph><heading level="4">5.4.6 Do not manipulate prototypes directly</heading><paragraph>The class keyword allows clearer and more readable class definitions than defining prototype properties. Ordinary implementation code has no business manipulating these objects, though they are still useful for defining classes as defined in ??. Mixins and modifying the prototypes of builtin objects are explicitly forbidden.</paragraph><paragraph>Exception: Framework code (such as Polymer, or Angular) may need to use prototypes, and should not resort to even-worse workarounds to avoid doing so.</paragraph><heading level="4">5.4.7 Getters and Setters</heading><paragraph>Do not use JavaScript getter and setter properties. They are potentially surprising and difficult to reason about, and have limited support in the compiler. Provide ordinary methods instead.</paragraph><paragraph>Exception: there are situations where defining a getter or setter is unavoidable (e.g. data binding frameworks such as Angular and Polymer, or for compatibility with external APIs that cannot be adjusted). In these cases only, getters and setters may be used with caution, provided they are defined with the get and set shorthand method keywords or Object.defineProperties (not Object.defineProperty, which interferes with property renaming). Getters must not change observable state.</paragraph><paragraph>Disallowed:</paragraph><code language="javascript">class Foo {
  get next() { return this.nextId++; }
}
</code><heading level="4">5.4.8 Overriding toString</heading><paragraph>The toString method may be overridden, but must always succeed and never have visible side effects.</paragraph><paragraph>Tip: Beware, in particular, of calling other methods from toString, since exceptional conditions could lead to infinite loops.</paragraph><heading level="4">5.4.9 Interfaces</heading><paragraph>Interfaces may be declared with @interface or @record. Interfaces declared with @record can be explicitly (i.e. via @implements) or implicitly implemented by a class or object literal.</paragraph><paragraph>All methods on an interface must be non-static and method bodies must be empty blocks. Fields must be declared as uninitialized members in the class constructor.</paragraph><paragraph>Example:</paragraph><code language="javascript">/**
 * Something that can frobnicate.
 * @record
 */
class Frobnicator {
  constructor() {
    /** @type {number} The number of attempts before giving up. */
    this.attempts;
  }

  /**
   * Performs the frobnication according to the given strategy.
   * @param {!FrobnicationStrategy} strategy
   */
  frobnicate(strategy) {}
}

</code><heading level="4">5.4.10 Abstract Classes</heading><paragraph>Use abstract classes when appropriate. Abstract classes and methods must be annotated with @abstract. Do not use goog.abstractMethod. See abstract classes and methods.</paragraph><heading level="4">5.4.11 Do not create static container classes</heading><paragraph>Do not use container classes with only static methods or properties for the sake of namespacing.</paragraph><code language="javascript">// container.js
// Bad: Container is an exported class that has only static methods and fields.
class Container {
  /** @return {number} */
  static bar() {
    return 1;
  }
}

/** @const {number} */
Container.FOO = 1;

exports = {Container};
</code><paragraph>Instead, export individual constants and functions:</paragraph><code language="javascript">/** @return {number} */
exports.bar = () => {
  return 1;
}

/** @const {number} */
exports.FOO = 1;
</code><heading level="4">5.4.12 Do not define nested namespaces</heading><paragraph>Do not define a nested type (e.g. class, typedef, enum, interface) on another module-local name.</paragraph><code language="code">// foo.js
goog.module('my.namespace');

class Foo {...}

Foo.Bar = class {...};

/** @enum {number} */
Foo.Baz = {...};

/** @typedef {{value: number}} */
Foo.Qux;

/** @interface */
Foo.Quuz = class {...}

exports.Foo = Foo;
</code><paragraph>These values should be top-level exports. Choose clear names for these values (e.g. FooConverter for a Converter that could have been nested on Foo). However, when the module name is redundant with part of the class name, consider omitting the redundancy: foo.Foo and foo.Converter rather than foo.Foo and foo.FooConverter. Importers can add the prefix when necessary for clarity (e.g. import {Converter as FooConverter} from './foo';) but cannot easily remove the redundancy when importing the entire module as a namespace.</paragraph><code language="javascript">// foo.js
goog.module('my.namespace');

class Foo {...}

class FooBar {...}

/** @enum {string} */
let FooBaz = {...};

/** @typedef {{value: number}} */
let FooQux;

/** @interface */
class FooQuuz {...};

export = {
  Foo,
  FooBar,
  FooBaz,
  FooQux,
  FooQuuz,
};
</code><heading level="3">5.5 Functions</heading><heading level="4">5.5.1 Top-level functions</heading><paragraph>Top-level functions may be defined directly on the exports object, or else declared locally and optionally exported. See ?? for more on exports.</paragraph><paragraph>Examples:</paragraph><code language="javascript">/** @param {string} str */
exports.processString = (str) => {
  // Process the string.
};
</code><code language="javascript">/** @param {string} str */
const processString = (str) => {
  // Process the string.
};

exports = {processString};
</code><heading level="4">5.5.2 Nested functions and closures</heading><paragraph>Functions may contain nested function definitions. If it is useful to give the function a name, it should be assigned to a local const.</paragraph><heading level="4">5.5.3 Arrow functions</heading><paragraph>Arrow functions provide a concise function syntax and simplify scoping this for nested functions. Prefer arrow functions over the function keyword for nested functions (but see ??).</paragraph><paragraph>Prefer arrow functions over other this scoping approaches such as f.bind(this), goog.bind(f, this), and const self = this. Arrow functions are particularly useful for calling into callbacks as they permit explicitly specifying which parameters to pass to the callback whereas binding will blindly pass along all parameters.</paragraph><paragraph>The left-hand side of the arrow contains zero or more parameters. Parentheses around the parameters are optional if there is only a single non-destructured parameter. When parentheses are used, inline parameter types may be specified (see ??).</paragraph><paragraph>Tip: Always using parentheses even for single-parameter arrow functions can avoid situations where adding parameters, but forgetting to add parentheses, may result in parseable code which no longer works as intended.</paragraph><paragraph>The right-hand side of the arrow contains the body of the function. By default the body is a block statement (zero or more statements surrounded by curly braces). The body may also be an implicitly returned single expression if either: the program logic requires returning a value, or the void operator precedes a single function or method call (using void ensures undefined is returned, prevents leaking values, and communicates intent). The single expression form is preferred if it improves readability (e.g., for short or simple expressions).</paragraph><paragraph>Examples:</paragraph><code language="javascript">/**
 * Arrow functions can be documented just like normal functions.
 * @param {number} numParam A number to add.
 * @param {string} strParam Another number to add that happens to be a string.
 * @return {number} The sum of the two parameters.
 */
const moduleLocalFunc = (numParam, strParam) => numParam + Number(strParam);

// Uses the single expression syntax with `void` because the program logic does
// not require returning a value.
getValue((result) => void alert(`Got ${result}`));

class CallbackExample {
  constructor() {
    /** @private {number} */
    this.cachedValue_ = 0;

    // For inline callbacks, you can use inline typing for parameters.
    // Uses a block statement because the value of the single expression should
    // not be returned and the expression is not a single function call.
    getNullableValue((/** ?number */ result) => {
      this.cachedValue_ = result == null ? 0 : result;
    });
  }
}
</code><paragraph>Disallowed:</paragraph><code language="javascript">/**
 * A function with no params and no returned value.
 * This single expression body usage is illegal because the program logic does
 * not require returning a value and we're missing the `void` operator.
 */
const moduleLocalFunc = () => anotherFunction();
</code><heading level="4">5.5.4 Generators</heading><paragraph>Generators enable a number of useful abstractions and may be used as needed.</paragraph><paragraph>When defining generator functions, attach the * to the function keyword when present, and separate it with a space from the name of the function. When using delegating yields, attach the * to the yield keyword.</paragraph><paragraph>Example:</paragraph><code language="javascript">/** @return {!Iterator<number>} */
function* gen1() {
  yield 42;
}

/** @return {!Iterator<number>} */
const gen2 = function*() {
  yield* gen1();
}

class SomeClass {
  /** @return {!Iterator<number>} */
  * gen() {
    yield 42;
  }
}
</code><heading level="4">5.5.5 Parameter and return types</heading><paragraph>Function parameters and return types should usually be documented with JSDoc annotations. See ?? for more information.</paragraph><heading level="5">5.5.5.1 Default parameters</heading><paragraph>Optional parameters are permitted using the equals operator in the parameter list. Optional parameters must include spaces on both sides of the equals operator, be named exactly like required parameters (i.e., not prefixed with opt_), use the = suffix in their JSDoc type, come after required parameters, and not use initializers that produce observable side effects. All optional parameters for concrete functions must have default values, even if that value is undefined. In contrast to concrete functions, abstract and interface methods must omit default parameter values.</paragraph><paragraph>Example:</paragraph><code language="javascript">/**
 * @param {string} required This parameter is always needed.
 * @param {string=} optional This parameter can be omitted.
 * @param {!Node=} node Another optional parameter.
 */
function maybeDoSomething(required, optional = '', node = undefined) {}

/** @interface */
class MyInterface {
  /**
   * Interface and abstract methods must omit default parameter values.
   * @param {string=} optional
   */
  someMethod(optional) {}
}
</code><paragraph>Use default parameters sparingly. Prefer destructuring (as in ??) to create readable APIs when there are more than a small handful of optional parameters that do not have a natural order.</paragraph><paragraph>Note: Unlike Python's default parameters, it is okay to use initializers that return new mutable objects (such as {} or []) because the initializer is evaluated each time the default value is used, so a single object won't be shared across invocations.</paragraph><paragraph>Tip: While arbitrary expressions including function calls may be used as initializers, these should be kept as simple as possible. Avoid initializers that expose shared mutable state, as that can easily introduce unintended coupling between function calls.</paragraph><heading level="5">5.5.5.2 Rest parameters</heading><paragraph>Use a rest parameter instead of accessing arguments. Rest parameters are typed with a ... prefix in their JSDoc. The rest parameter must be the last parameter in the list. There is no space between the ... and the parameter name. Do not name the rest parameter var_args. Never name a local variable or parameter arguments, which confusingly shadows the built-in name.</paragraph><paragraph>Example:</paragraph><code language="javascript">/**
 * @param {!Array<string>} array This is an ordinary parameter.
 * @param {...number} numbers The remainder of arguments are all numbers.
 */
function variadic(array, ...numbers) {}
</code><heading level="4">5.5.6 Generics</heading><paragraph>Declare generic functions and methods when necessary with @template TYPE in the JSDoc above the function or method definition.</paragraph><heading level="4">5.5.7 Spread operator</heading><paragraph>Function calls may use the spread operator (...). Prefer the spread operator to Function.prototype.apply when an array or iterable is unpacked into multiple parameters of a variadic function. There is no space after the ....</paragraph><paragraph>Example:</paragraph><code language="javascript">function myFunction(...elements) {}
myFunction(...array, ...iterable, ...generator());
</code><heading level="3">5.6 String literals</heading><heading level="4">5.6.1 Use single quotes</heading><paragraph>Ordinary string literals are delimited with single quotes ('), rather than double quotes (").</paragraph><paragraph>Tip: if a string contains a single quote character, consider using a template string to avoid having to escape the quote.</paragraph><paragraph>Ordinary string literals may not span multiple lines.</paragraph><heading level="4">5.6.2 Template literals</heading><paragraph>Use template literals (delimited with `) over complex string concatenation, particularly if multiple string literals are involved. Template literals may span multiple lines.</paragraph><paragraph>If a template literal spans multiple lines, it does not need to follow the indentation of the enclosing block, though it may if the added whitespace does not matter.</paragraph><paragraph>Example:</paragraph><code language="javascript">function arithmetic(a, b) {
  return `Here is a table of arithmetic operations:
${a} + ${b} = ${a + b}
${a} - ${b} = ${a - b}
${a} * ${b} = ${a * b}
${a} / ${b} = ${a / b}`;
}
</code><heading level="4">5.6.3 No line continuations</heading><paragraph>Do not use line continuations (that is, ending a line inside a string literal with a backslash) in either ordinary or template string literals. Even though ES5 allows this, it can lead to tricky errors if any trailing whitespace comes after the slash, and is less obvious to readers.</paragraph><paragraph>Disallowed:</paragraph><code language="javascript">const longString = 'This is a very long string that far exceeds the 80 \
    column limit. It unfortunately contains long stretches of spaces due \
    to how the continued lines are indented.';
</code><paragraph>Instead, write</paragraph><code language="javascript">const longString = 'This is a very long string that far exceeds the 80 ' +
    'column limit. It does not contain long stretches of spaces since ' +
    'the concatenated strings are cleaner.';
</code><heading level="3">5.7 Number literals</heading><paragraph>Numbers may be specified in decimal, hex, octal, or binary. Use exactly 0x, 0o, and 0b prefixes, with lowercase letters, for hex, octal, and binary, respectively. Never include a leading zero unless it is immediately followed by x, o, or b.</paragraph><heading level="3">5.8 Control structures</heading><heading level="4">5.8.1 For loops</heading><paragraph>With ES6, the language now has three different kinds of for loops. All may be used, though for-of loops should be preferred when possible.</paragraph><paragraph>for-in loops may only be used on dict-style objects (see ??), and should not be used to iterate over an array. Object.prototype.hasOwnProperty should be used in for-in loops to exclude unwanted prototype properties. Prefer for-of and Object.keys over for-in when possible.</paragraph><heading level="4">5.8.2 Exceptions</heading><paragraph>Exceptions are an important part of the language and should be used whenever exceptional cases occur. Always throw Errors or subclasses of Error: never throw string literals or other objects. Always use new when constructing an Error.</paragraph><paragraph>This treatment extends to Promise rejection values as Promise.reject(obj) is equivalent to throw obj; in async functions.</paragraph><paragraph>Custom exceptions provide a great way to convey additional error information from functions. They should be defined and used wherever the native Error type is insufficient.</paragraph><paragraph>Prefer throwing exceptions over ad-hoc error-handling approaches (such as passing an error container reference type, or returning an object with an error property).</paragraph><heading level="5">5.8.2.1 Empty catch blocks</heading><paragraph>It is very rarely correct to do nothing in response to a caught exception. When it truly is appropriate to take no action whatsoever in a catch block, the reason this is justified is explained in a comment.</paragraph><code language="javascript">try {
  return handleNumericResponse(response);
} catch (ok) {
  // it's not numeric; that's fine, just continue
}
return handleTextResponse(response);
</code><paragraph>Disallowed:</paragraph><code language="javascript">  try {
    shouldFail();
    fail('expected an error');
  } catch (expected) {
  }
</code><paragraph>Tip: Unlike in some other languages, patterns like the above simply don't work since this will catch the error thrown by fail. Use assertThrows() instead.</paragraph><heading level="4">5.8.3 Switch statements</heading><paragraph>Terminology Note: Inside the braces of a switch block are one or more statement groups. Each statement group consists of one or more switch labels (either case FOO: or default:), followed by one or more statements.</paragraph><heading level="5">5.8.3.1 Fall-through: commented</heading><paragraph>Within a switch block, each statement group either terminates abruptly (with a break, return or thrown exception), or is marked with a comment to indicate that execution will or might continue into the next statement group. Any comment that communicates the idea of fall-through is sufficient (typically // fall through). This special comment is not required in the last statement group of the switch block.</paragraph><paragraph>Example:</paragraph><code language="javascript">switch (input) {
  case 1:
  case 2:
    prepareOneOrTwo();
  // fall through
  case 3:
    handleOneTwoOrThree();
    break;
  default:
    handleLargeNumber(input);
}
</code><heading level="5">5.8.3.2 The default case is present</heading><paragraph>Each switch statement includes a default statement group, even if it contains no code. The default statement group must be last.</paragraph><heading level="3">5.9 this</heading><paragraph>Only use this in class constructors and methods, in arrow functions defined within class constructors and methods, or in functions that have an explicit @this declared in the immediately-enclosing function's JSDoc.</paragraph><paragraph>Never use this to refer to the global object, the context of an eval, the target of an event, or unnecessarily call()ed or apply()ed functions.</paragraph><heading level="3">5.10 Equality Checks</heading><paragraph>Use identity operators (===/!==) except in the cases documented below.</paragraph><heading level="4">5.10.1 Exceptions Where Coercion is Desirable</heading><paragraph>Catching both null and undefined values:</paragraph><code language="javascript">if (someObjectOrPrimitive == null) {
  // Checking for null catches both null and undefined for objects and
  // primitives, but does not catch other falsy values like 0 or the empty
  // string.
}
</code><heading level="3">5.11 Disallowed features</heading><heading level="4">5.11.1 with</heading><paragraph>Do not use the with keyword. It makes your code harder to understand and has been banned in strict mode since ES5.</paragraph><heading level="4">5.11.2 Dynamic code evaluation</heading><paragraph>Do not use eval or the Function(...string) constructor (except for code loaders). These features are potentially dangerous and simply do not work in CSP environments.</paragraph><heading level="4">5.11.3 Automatic semicolon insertion</heading><paragraph>Always terminate statements with semicolons (except function and class declarations, as noted above).</paragraph><heading level="4">5.11.4 Non-standard features</heading><paragraph>Do not use non-standard features. This includes old features that have been removed (e.g., WeakMap.clear), new features that are not yet standardized (e.g., the current TC39 working draft, proposals at any stage, or proposed but not-yet-complete web standards), or proprietary features that are only implemented in some browsers. Use only features defined in the current ECMA-262 or WHATWG standards. (Note that projects writing against specific APIs, such as Chrome extensions or Node.js, can obviously use those APIs). Non-standard language "extensions" (such as those provided by some external transpilers) are forbidden.</paragraph><heading level="4">5.11.5 Wrapper objects for primitive types</heading><paragraph>Never use new on the primitive object wrappers (Boolean, Number, String, Symbol), nor include them in type annotations.</paragraph><paragraph>Disallowed:</paragraph><code language="javascript">const /** Boolean */ x = new Boolean(false);
if (x) alert(typeof x);  // alerts 'object' - WAT?
</code><paragraph>The wrappers may be called as functions for coercing (which is preferred over using + or concatenating the empty string) or creating symbols.</paragraph><paragraph>Example:</paragraph><code language="javascript">const /** boolean */ x = Boolean(0);
if (!x) alert(typeof x);  // alerts 'boolean', as expected
</code><heading level="4">5.11.6 Modifying builtin objects</heading><paragraph>Never modify builtin types, either by adding methods to their constructors or to their prototypes. Avoid depending on libraries that do this. Note that the JSCompiler's runtime library will provide standards-compliant polyfills where possible; nothing else may modify builtin objects.</paragraph><paragraph>Do not add symbols to the global object unless absolutely necessary (e.g. required by a third-party API).</paragraph><heading level="4">5.11.7 Omitting () when invoking a constructor</heading><paragraph>Never invoke a constructor in a new statement without using parentheses ().</paragraph><paragraph>Disallowed:</paragraph><code language="code">new Foo;
</code><paragraph>Use instead:</paragraph><code language="code">new Foo();
</code><paragraph>Omitting parentheses can lead to subtle mistakes. These two lines are not equivalent:</paragraph><code language="code">new Foo().Bar();
new Foo.Bar();
</code><heading level="2">6 Naming</heading><heading level="3">6.1 Rules common to all identifiers</heading><paragraph>Identifiers use only ASCII letters and digits, and, in a small number of cases noted below, underscores and very rarely (when required by frameworks like Angular) dollar signs.</paragraph><paragraph>Give as descriptive a name as possible, within reason. Do not worry about saving horizontal space as it is far more important to make your code immediately understandable by a new reader. Do not use abbreviations that are ambiguous or unfamiliar to readers outside your project, and do not abbreviate by deleting letters within a word.</paragraph><code language="code">errorCount          // No abbreviation.
dnsConnectionIndex  // Most people know what "DNS" stands for.
referrerUrl         // Ditto for "URL".
customerId          // "Id" is both ubiquitous and unlikely to be misunderstood.
</code><paragraph>Disallowed:</paragraph><code language="code">n                   // Meaningless.
nErr                // Ambiguous abbreviation.
nCompConns          // Ambiguous abbreviation.
wgcConnections      // Only your group knows what this stands for.
pcReader            // Lots of things can be abbreviated "pc".
cstmrId             // Deletes internal letters.
kSecondsPerDay      // Do not use Hungarian notation.
</code><paragraph>Exception: Variables that are in scope for 10 lines or fewer, including arguments that are not part of an exported API, may use short (e.g. single letter) variable names.</paragraph><heading level="3">6.2 Rules by identifier type</heading><heading level="4">6.2.1 Package names</heading><paragraph>Package names are all lowerCamelCase. For example, my.exampleCode.deepSpace, but not my.examplecode.deepspace or my.example_code.deep_space.</paragraph><paragraph>Exception: The package name may conform to TypeScript's path-based pattern. This is typically all lower case with underscores where present in filenames.</paragraph><heading level="4">6.2.2 Class names</heading><paragraph>Class, interface, record, and typedef names are written in UpperCamelCase. Unexported classes are simply locals: they are not marked @private.</paragraph><paragraph>Type names are typically nouns or noun phrases. For example, Request, ImmutableView, or VisibilityMode. Additionally, interface names may sometimes be adjectives or adjective phrases instead (for example, Readable).</paragraph><heading level="4">6.2.3 Method names</heading><paragraph>Method names are written in lowerCamelCase. Names for @private methods may optionally end with a trailing underscore.</paragraph><paragraph>Method names are typically verbs or verb phrases. For example, sendMessage or stop_. Getter and setter methods for properties are never required, but if they are used they should be named getFoo (or optionally isFoo or hasFoo for booleans), or setFoo(value) for setters.</paragraph><paragraph>Underscores may also appear in JsUnit test method names to separate logical components of the name. One typical pattern is test<MethodUnderTest>_<state>_<expectedOutcome>, for example testPop_emptyStack_throws. There is no One Correct Way to name test methods.</paragraph><heading level="4">6.2.4 Enum names</heading><paragraph>Enum names are written in UpperCamelCase, similar to classes, and should generally be singular nouns. Individual items within the enum are named in CONSTANT_CASE.</paragraph><heading level="4">6.2.5 Constant names</heading><paragraph>Constant names use CONSTANT_CASE: all uppercase letters, with words separated by underscores. There is no reason for a constant to be named with a trailing underscore, since private static properties can be replaced by (implicitly private) module locals.</paragraph><heading level="5">6.2.5.1 Definition of "constant"</heading><paragraph>Every constant is a @const static property or a module-local const declaration, but not all @const static properties and module-local consts are constants. Before choosing constant case, consider whether the field really feels like a deeply immutable constant. For example, if any of that instance's observable state can change, it is almost certainly not a constant. Merely intending to never mutate the object is generally not enough.</paragraph><paragraph>Examples:</paragraph><code language="javascript">// Constants
const NUMBER = 5;
/** @const */ exports.NAMES = goog.debug.freeze(['Ed', 'Ann']);
/** @enum */ exports.SomeEnum = { ENUM_CONSTANT: 'value' };

// Not constants
let letVariable = 'non-const';

class MyClass {
  constructor() { /** @const {string} */ this.nonStatic = 'non-static'; }
};
/** @type {string} */
MyClass.staticButMutable = 'not @const, can be reassigned';

const /** Set<string> */ mutableCollection = new Set();

const /** MyImmutableContainer<SomeMutableType> */ stillMutable =
    new MyImmutableContainer(mutableInner);

const {Foo} = goog.require('my.foo');  // mirrors imported name

const logger = log.getLogger('loggers.are.not.immutable');
</code><paragraph>Constants' names are typically nouns or noun phrases.</paragraph><heading level="5">6.2.5.2 Local aliases</heading><paragraph>Local aliases should be used whenever they improve readability over fully-qualified names. Follow the same rules as goog.requires (??), maintaining the last part of the aliased name. Aliases may also be used within functions. Aliases must be const.</paragraph><paragraph>Examples:</paragraph><code language="javascript">const staticHelper = importedNamespace.staticHelper;
const CONSTANT_NAME = ImportedClass.CONSTANT_NAME;
const {assert, assertInstanceof} = asserts;
</code><heading level="4">6.2.6 Non-constant field names</heading><paragraph>Non-constant field names (static or otherwise) are written in lowerCamelCase, with an optional trailing underscore for private fields.</paragraph><paragraph>These names are typically nouns or noun phrases. For example, computedValues or index_.</paragraph><heading level="4">6.2.7 Parameter names</heading><paragraph>Parameter names are written in lowerCamelCase. Note that this applies even if the parameter expects a constructor.</paragraph><paragraph>One-character parameter names should not be used in public methods.</paragraph><paragraph>Exception: When required by a third-party framework, parameter names may begin with a $. This exception does not apply to any other identifiers (e.g. local variables or properties).</paragraph><heading level="4">6.2.8 Local variable names</heading><paragraph>Local variable names are written in lowerCamelCase, except for module-local (top-level) constants, as described above. Constants in function scopes are still named in lowerCamelCase. Note that lowerCamelCase is used even if the variable holds a constructor.</paragraph><heading level="4">6.2.9 Template parameter names</heading><paragraph>Template parameter names should be concise, single-word or single-letter identifiers, and must be all-caps, such as TYPE or THIS.</paragraph><heading level="4">6.2.10 Module-local names</heading><paragraph>Module-local names that are not exported are implicitly private. They are not marked @private. This applies to classes, functions, variables, constants, enums, and other module-local identifiers.</paragraph><heading level="3">6.3 Camel case: defined</heading><paragraph>Sometimes there is more than one reasonable way to convert an English phrase into camel case, such as when acronyms or unusual constructs like IPv6 or iOS are present. To improve predictability, Google Style specifies the following (nearly) deterministic scheme.</paragraph><paragraph>Beginning with the prose form of the name:</paragraph><list type="ol"><item>Convert the phrase to plain ASCII and remove any apostrophes. For example, Müller's algorithm might become Muellers algorithm.</item><item>Divide this result into words, splitting on spaces and any remaining punctuation (typically hyphens). Recommended: if any word already has a conventional camel case appearance in common usage, split this into its constituent parts (e.g., AdWords becomes ad words). Note that a word such as iOS is not really in camel case per se; it defies any convention, so this recommendation does not apply.</item><item>Now lowercase everything (including acronyms), then uppercase only the first character of: … each word, to yield UpperCamelCase, or … each word except the first, to yield lowerCamelCase</item><item>Finally, join all the words into a single identifier.</item></list><list type="ol"><item>Recommended: if any word already has a conventional camel case appearance in common usage, split this into its constituent parts (e.g., AdWords becomes ad words). Note that a word such as iOS is not really in camel case per se; it defies any convention, so this recommendation does not apply.</item></list><list type="ol"><item>… each word, to yield UpperCamelCase, or</item><item>… each word except the first, to yield lowerCamelCase</item></list><paragraph>Note that the casing of the original words is almost entirely disregarded.</paragraph><paragraph>Examples of lowerCamelCase:</paragraph><table><thead><tr><th>Prose form</th><th>Correct</th><th>Incorrect</th></tr></thead><tbody><tr><td>XML HTTP request</td><td>xmlHttpRequest</td><td>XMLHTTPRequest</td></tr><tr><td>new customer ID</td><td>newCustomerId</td><td>newCustomerID</td></tr><tr><td>inner stopwatch</td><td>innerStopwatch</td><td>innerStopWatch</td></tr><tr><td>supports IPv6 on iOS?</td><td>supportsIpv6OnIos</td><td>supportsIPv6OnIOS</td></tr><tr><td>YouTube importer</td><td>youTubeImporter</td><td>youtubeImporter*</td></tr></tbody></table><paragraph>*Acceptable, but not recommended.</paragraph><paragraph>For examples of UpperCamelCase, uppercase the first letter of each correct lowerCamelCase example.</paragraph><paragraph>Note: Some words are ambiguously hyphenated in the English language: for example nonempty and non-empty are both correct, so the method names checkNonempty and checkNonEmpty are likewise both correct.</paragraph><heading level="2">7 JSDoc</heading><paragraph>JSDoc is used on all classes, fields, and methods.</paragraph><heading level="3">7.1 General form</heading><paragraph>The basic formatting of JSDoc blocks is as seen in this example:</paragraph><code language="javascript">/**
 * Multiple lines of JSDoc text are written here,
 * wrapped normally.
 * @param {number} arg A number to do something to.
 */
function doSomething(arg) { … }
</code><paragraph>or in this single-line example:</paragraph><code language="code">/** @const @private {!Foo} A short bit of JSDoc. */
this.foo_ = foo;
</code><paragraph>If a single-line comment overflows into multiple lines, it must use the multi-line style with /** and */ on their own lines.</paragraph><paragraph>Many tools extract metadata from JSDoc comments to perform code validation and optimization. As such, these comments must be well-formed.</paragraph><heading level="3">7.2 Markdown</heading><paragraph>JSDoc is written in Markdown, though it may include HTML when necessary.</paragraph><paragraph>Note that tools that automatically extract JSDoc (e.g. JsDossier) will often ignore plain text formatting, so if you did this:</paragraph><code language="code">/**
 * Computes weight based on three factors:
 *   items sent
 *   items received
 *   last timestamp
 */
</code><paragraph>it would come out like this:</paragraph><code language="code">Computes weight based on three factors: items sent items received last timestamp
</code><paragraph>Instead, write a Markdown list:</paragraph><code language="code">/**
 * Computes weight based on three factors:
 *
 *  - items sent
 *  - items received
 *  - last timestamp
 */
</code><paragraph>Google style allows a subset of JSDoc tags. See ?? for the complete list. Most tags must occupy their own line, with the tag at the beginning of the line.</paragraph><paragraph>Disallowed:</paragraph><code language="javascript">/**
 * The "param" tag must occupy its own line and may not be combined.
 * @param {number} left @param {number} right
 */
function add(left, right) { ... }
</code><paragraph>Simple tags that do not require any additional data (such as @private, @const, @final, @export) may be combined onto the same line, along with an optional type when appropriate.</paragraph><code language="javascript">/**
 * Place more complex annotations (like "implements" and "template")
 * on their own lines. Multiple simple tags (like "export" and "final")
 * may be combined in one line.
 * @export @final
 * @implements {Iterable<TYPE>}
 * @template TYPE
 */
class MyClass {
  /**
   * @param {!ObjType} obj Some object.
   * @param {number=} num An optional number.
   */
  constructor(obj, num = 42) {
    /** @private @const {!Array<!ObjType|number>} */
    this.data_ = [obj, num];
  }
}
</code><paragraph>There is no hard rule for when to combine tags, or in which order, but be consistent.</paragraph><paragraph>For general information about annotating types in JavaScript see Annotating JavaScript for the Closure Compiler and Types in the Closure Type System.</paragraph><heading level="3">7.4 Line wrapping</heading><paragraph>Line-wrapped block tags are indented four spaces. Wrapped description text may be lined up with the description on previous lines, but this horizontal alignment is discouraged.</paragraph><code language="javascript">/**
 * Illustrates line wrapping for long param/return descriptions.
 * @param {string} foo This is a param with a description too long to fit in
 *     one line.
 * @return {number} This returns something that has a description too long to
 *     fit in one line.
 */
exports.method = function(foo) {
  return 5;
};
</code><paragraph>Do not indent when wrapping a @desc or @fileoverview description.</paragraph><paragraph>A file may have a top-level file overview. A copyright notice, author information, and default visibility level are optional. File overviews are generally recommended whenever a file consists of more than a single class definition. The top level comment is designed to orient readers unfamiliar with the code to what is in this file. If present, it may provide a description of the file's contents and any dependencies or compatibility information. Wrapped lines are not indented.</paragraph><paragraph>Example:</paragraph><code language="code">/**
 * @fileoverview Description of file, its uses and information
 * about its dependencies.
 * @package
 */
</code><paragraph>Classes, interfaces and records must be documented with a description and any template parameters, implemented interfaces, visibility, or other appropriate tags. The class description should provide the reader with enough information to know how and when to use the class, as well as any additional considerations necessary to correctly use the class. Textual descriptions may be omitted on the constructor. When defining a class @constructor and @extends annotations are not used with the class keyword unless it extends a generic class. When defining an @interface or a @record, the @extends annotation is used when defining a subclass and the extends keyword is never used.</paragraph><code language="javascript">/**
 * A fancier event target that does cool things.
 * @implements {Iterable<string>}
 */
class MyFancyTarget extends EventTarget {
  /**
   * @param {string} arg1 An argument that makes this more interesting.
   * @param {!Array<number>} arg2 List of numbers to be processed.
   */
  constructor(arg1, arg2) {
    // ...
  }
};

/**
 * Records are also helpful.
 * @extends {Iterator<TYPE>}
 * @record
 * @template TYPE
 */
class Listable {
  /** @return {TYPE} The next item in line to be returned. */
  next() {}
}
</code><paragraph>All enums and typedefs must be documented with appropriate JSDoc tags (@typedef or @enum) on the preceding line. Public enums and typedefs must also have a description. Individual enum items may be documented with a JSDoc comment on the preceding line.</paragraph><code language="javascript">/**
 * A useful type union, which is reused often.
 * @typedef {!FruitType|!FruitTypeEnum}
 */
let CoolUnionType;
 
/**
 * Types of fruits.
 * @enum {string}
 */
const FruitTypeEnum = {
  /** This kind is very sour. */
  SOUR: 'sour',
  /** The less-sour kind. */
  SWEET: 'sweet',
};
</code><paragraph>Typedefs are useful for defining short record types, or aliases for unions, complex functions, or generic types. Typedefs should be avoided for record types with many fields, since they do not allow documenting individual fields, nor using templates or recursive references. For large record types, prefer @record.</paragraph><paragraph>In methods and named functions, parameter and return types must be documented, even in the case of same-signature @overrides. The this type should be documented when necessary. Return type may be omitted if the function has no non-empty return statements.</paragraph><paragraph>Method, parameter, and return descriptions (but not types) may be omitted if they are obvious from the rest of the method's JSDoc or from its signature.</paragraph><paragraph>Method descriptions begin with a verb phrase that describes what the method does. This phrase is not an imperative sentence, but instead is written in the third person, as if there is an implied This method ... before it.</paragraph><paragraph>If a method overrides a superclass method, it must include an @override annotation. For overridden methods, all @param and @return annotations must be specified explicitly even if no type from the superclass method is refined. This is to align with TypeScript.</paragraph><code language="javascript">/** A class that does something. */
class SomeClass extends SomeBaseClass {
  /**
   * Operates on an instance of MyClass and returns something.
   * @param {!MyClass} obj An object that for some reason needs detailed
   *     explanation that spans multiple lines.
   * @param {!OtherClass} obviousOtherClass
   * @return {boolean} Whether something occurred.
   */
  someMethod(obj, obviousOtherClass) { ... }

  /**
   * @param {string} param
   * @return {string}
   * @override
   */
  overriddenMethod(param) { ... }
}

/**
 * Demonstrates how top-level functions follow the same rules.  This one
 * makes an array.
 * @param {TYPE} arg
 * @return {!Array<TYPE>}
 * @template TYPE
 */
function makeArray(arg) { ... }
</code><paragraph>If you only need to document the param and return types of a function, you may optionally use inline JSDocs in the function's signature. These inline JSDocs specify the return and param types without tags.</paragraph><code language="javascript">function /** string */ foo(/** number */ arg) {...}
</code><paragraph>If you need descriptions or tags, use a single JSDoc comment above the method. For example, methods which return values need a @return tag.</paragraph><code language="javascript">class MyClass {
  /**
   * @param {number} arg
   * @return {string}
   */
  bar(arg) {...}
}
</code><code language="javascript">// Illegal inline JSDocs.

class MyClass {
  /** @return {string} */ foo() {...}
}

/** No function description allowed inline here. */ function bar() {...}

function /** Function description is also illegal here. */ baz() {...}
</code><paragraph>In anonymous functions annotations are generally optional. If the automatic type inference is insufficient or explicit annotation improves readability, then annotate param and return types like this:</paragraph><code language="javascript">promise.then(
    /** @return {string} */
    (/** !Array<string> */ items) => {
      doSomethingWith(items);
      return items[0];
    });
</code><paragraph>For function type expressions, see ??.</paragraph><paragraph>Property types must be documented. The description may be omitted for private properties, if name and type provide enough documentation for understanding the code.</paragraph><paragraph>Publicly exported constants are commented the same way as properties.</paragraph><code language="javascript">/** My class. */
class MyClass {
  /** @param {string=} someString */
  constructor(someString = 'default string') {
    /** @private @const {string} */
    this.someString_ = someString;

    /** @private @const {!OtherType} */
    this.someOtherThing_ = functionThatReturnsAThing();

    /**
     * Maximum number of things per pane.
     * @type {number}
     */
    this.someProperty = 4;
  }
}

/**
 * The number of times we'll try before giving up.
 * @const {number}
 */
MyClass.RETRY_COUNT = 33;
</code><heading level="3">7.10 Type annotations</heading><paragraph>Type annotations are found on @param, @return, @this, and @type tags, and optionally on @const, @export, and any visibility tags. Type annotations attached to JSDoc tags must always be enclosed in braces.</paragraph><heading level="4">7.10.1 Nullability</heading><paragraph>The type system defines modifiers ! and ? for non-null and nullable, respectively. These modifiers must precede the type.</paragraph><paragraph>Nullability modifiers have different requirements for different types, which fall into two broad categories:</paragraph><list type="ol"><item>Type annotations for primitives (string, number, boolean, symbol, undefined, null) and literals ({function(...): ...} and {{foo: string...}}) are always non-nullable by default. Use the ? modifier to make it nullable, but omit the redundant !.</item><item>Reference types (generally, anything in UpperCamelCase, including some.namespace.ReferenceType) refer to a class, enum, record, or typedef defined elsewhere. Since these types may or may not be nullable, it is impossible to tell from the name alone whether it is nullable or not. Always use explicit ? and ! modifiers for these types to prevent ambiguity at use sites.</item></list><paragraph>Bad:</paragraph><code language="javascript">const /** MyObject */ myObject = null; // Non-primitive types must be annotated.
const /** !number */ someNum = 5; // Primitives are non-nullable by default.
const /** number? */ someNullableNum = null; // ? should precede the type.
const /** !{foo: string, bar: number} */ record = ...; // Already non-nullable.
const /** MyTypeDef */ def = ...; // Not sure if MyTypeDef is nullable.

// Not sure if object (nullable), enum (non-nullable, unless otherwise
// specified), or typedef (depends on definition).
const /** SomeCamelCaseName */ n = ...;
</code><paragraph>Good:</paragraph><code language="javascript">const /** ?MyObject */ myObject = null;
const /** number */ someNum = 5;
const /** ?number */ someNullableNum = null;
const /** {foo: string, bar: number} */ record = ...;
const /** !MyTypeDef */ def = ...;
const /** ?SomeCamelCaseName */ n = ...;
</code><heading level="4">7.10.2 Type Casts</heading><paragraph>In cases where the compiler doesn't accurately infer the type of an expression, and the assertion functions in goog.asserts cannot remedy it, it is possible to tighten the type by adding a type annotation comment and enclosing the expression in parentheses. Note that the parentheses are required.</paragraph><code language="code">/** @type {number} */ (x)
</code><heading level="4">7.10.3 Template Parameter Types</heading><paragraph>Always specify template parameters. This way compiler can do a better job and it makes it easier for readers to understand what code does.</paragraph><paragraph>Bad:</paragraph><code language="javascript">const /** !Object */ users = {};
const /** !Array */ books = [];
const /** !Promise */ response = ...;
</code><paragraph>Good:</paragraph><code language="javascript">const /** !Object<string, !User> */ users = {};
const /** !Array<string> */ books = [];
const /** !Promise<!Response> */ response = ...;

const /** !Promise<undefined> */ thisPromiseReturnsNothingButParameterIsStillUseful = ...;
const /** !Object<string, *> */ mapOfEverything = {};
</code><paragraph>Cases when template parameters should not be used:</paragraph><list type="ul"><item>Object is used for type hierarchy and not as map-like structure.</item></list><heading level="4">7.10.4 Function type expressions</heading><paragraph>Terminology Note: function type expression refers to a type annotation for function types with the keyword function in the annotation (see examples below).</paragraph><paragraph>Where the function definition is given, do not use a function type expression. Specify parameter and return types with @param and @return, or with inline annotations (see ??). This includes anonymous functions and functions defined and assigned to a const (where the function jsdoc appears above the whole assignment expression).</paragraph><paragraph>Function type expressions are needed, for example, inside @typedef, @param or @return. Use it also for variables or properties of function type, if they are not immediately initialized with the function definition.</paragraph><code language="code">  /** @private {function(string): string} */
  this.idGenerator_ = googFunctions.identity;
</code><paragraph>When using a function type expression, always specify the return type explicitly. Otherwise the default return type is unknown (?), which leads to strange and unexpected behavior, and is rarely what is actually desired.</paragraph><paragraph>Bad - type error, but no warning given:</paragraph><code language="javascript">/** @param {function()} generateNumber */
function foo(generateNumber) {
  const /** number */ x = generateNumber();  // No compile-time type error here.
}

foo(() => 'clearly not a number');
</code><paragraph>Good:</paragraph><code language="javascript">/**
 * @param {function(): *} inputFunction1 Can return any type.
 * @param {function(): undefined} inputFunction2 Definitely doesn't return
 *      anything.
 * NOTE: the return type of `foo` itself is safely implied to be {undefined}.
 */
function foo(inputFunction1, inputFunction2) {...}
</code><heading level="4">7.10.5 Whitespace</heading><paragraph>Within a type annotation, a single space or line break is required after each comma or colon. Additional line breaks may be inserted to improve readability or avoid exceeding the column limit. These breaks should be chosen and indented following the applicable guidelines (e.g. ?? and ??). No other whitespace is allowed in type annotations.</paragraph><paragraph>Good:</paragraph><code language="code">/** @type {function(string): number} */

/** @type {{foo: number, bar: number}} */

/** @type {number|string} */

/** @type {!Object<string, string>} */

/** @type {function(this: Object<string, string>, number): string} */

/**
 * @type {function(
 *     !SuperDuperReallyReallyLongTypedefThatForcesTheLineBreak,
 *     !OtherVeryLongTypedef): string}
 */

/**
 * @type {!SuperDuperReallyReallyLongTypedefThatForcesTheLineBreak|
 *     !OtherVeryLongTypedef}
 */
</code><paragraph>Bad:</paragraph><code language="code">// Only put a space after the colon
/** @type {function(string) : number} */

// Put spaces after colons and commas
/** @type {{foo:number,bar:number}} */

// No space in union types
/** @type {number | string} */
</code><heading level="3">7.11 Visibility annotations</heading><paragraph>Visibility annotations (@private, @package, @protected) may be specified in a @fileoverview block, or on any exported symbol or property. Do not specify visibility for local variables, whether within a function or at the top level of a module. @private names may optionally end with an underscore.</paragraph><heading level="2">8 Policies</heading><heading level="3">8.1 Issues unspecified by Google Style: Be Consistent!</heading><paragraph>For any style question that isn't settled definitively by this specification, prefer to do what the other code in the same file is already doing. If that doesn't resolve the question, consider emulating the other files in the same package.</paragraph><heading level="3">8.2 Compiler warnings</heading><heading level="4">8.2.1 Use a standard warning set</heading><paragraph>As far as possible projects should use --warning_level=VERBOSE.</paragraph><heading level="4">8.2.2 How to handle a warning</heading><paragraph>Before doing anything, make sure you understand exactly what the warning is telling you. If you're not positive why a warning is appearing, ask for help .</paragraph><paragraph>Once you understand the warning, attempt the following solutions in order:</paragraph><list type="ol"><item>First, fix it or work around it. Make a strong attempt to actually address the warning, or find another way to accomplish the task that avoids the situation entirely.</item><item>Otherwise, determine if it's a false alarm. If you are convinced that the warning is invalid and that the code is actually safe and correct, add a comment to convince the reader of this fact and apply the @suppress annotation.</item><item>Otherwise, leave a TODO comment. This is a last resort. If you do this, do not suppress the warning. The warning should be visible until it can be taken care of properly.</item></list><heading level="4">8.2.3 Suppress a warning at the narrowest reasonable scope</heading><paragraph>Warnings are suppressed at the narrowest reasonable scope, usually that of a single local variable or very small method. Often a variable or method is extracted for that reason alone.</paragraph><paragraph>Example</paragraph><code language="javascript">/** @suppress {uselessCode} Unrecognized 'use asm' declaration */
function fn() {
  'use asm';
  return 0;
}
</code><paragraph>Even a large number of suppressions in a class is still better than blinding the entire class to this type of warning.</paragraph><heading level="3">8.3 Deprecation</heading><paragraph>Mark deprecated methods, classes or interfaces with @deprecated annotations. A deprecation comment must include simple, clear directions for people to fix their call sites.</paragraph><heading level="3">8.4 Code not in Google Style</heading><paragraph>You will occasionally encounter files in your codebase that are not in proper Google Style. These may have come from an acquisition, or may have been written before Google Style took a position on some issue, or may be in non-Google Style for any other reason.</paragraph><heading level="4">8.4.1 Reformatting existing code</heading><paragraph>When updating the style of existing code, follow these guidelines.</paragraph><list type="ol"><item>It is not required to change all existing code to meet current style guidelines. Reformatting existing code is a trade-off between code churn and consistency. Style rules evolve over time and these kinds of tweaks to maintain compliance would create unnecessary churn. However, if significant changes are being made to a file it is expected that the file will be in Google Style.</item><item>Be careful not to allow opportunistic style fixes to muddle the focus of a CL. If you find yourself making a lot of style changes that aren't critical to the central focus of a CL, promote those changes to a separate CL.</item></list><heading level="4">8.4.2 Newly added code: use Google Style</heading><paragraph>Brand new files use Google Style, regardless of the style choices of other files in the same package.</paragraph><paragraph>When adding new code to a file that is not in Google Style, reformatting the existing code first is recommended, subject to the advice in ??.</paragraph><paragraph>If this reformatting is not done, then new code should be as consistent as possible with existing code in the same file, but must not violate the style guide.</paragraph><heading level="3">8.5 Local style rules</heading><paragraph>Teams and projects may adopt additional style rules beyond those in this document, but must accept that cleanup changes may not abide by these additional rules, and must not block such cleanup changes due to violating any additional rules. Beware of excessive rules which serve no purpose. The style guide does not seek to define style in every possible scenario and neither should you.</paragraph><heading level="3">8.6 Generated code: mostly exempt</heading><paragraph>Source code generated by the build process is not required to be in Google Style. However, any generated identifiers that will be referenced from hand-written source code must follow the naming requirements. As a special exception, such identifiers are allowed to contain underscores, which may help to avoid conflicts with hand-written identifiers.</paragraph><heading level="2">9 Appendices</heading><heading level="3">9.1 JSDoc tag reference</heading><paragraph>JSDoc serves multiple purposes in JavaScript. In addition to being used to generate documentation it is also used to control tooling. The best known are the Closure Compiler type annotations.</paragraph><heading level="4">9.1.1 Type annotations and other Closure Compiler annotations</heading><paragraph>Documentation for JSDoc used by the Closure Compiler is described in Annotating JavaScript for the Closure Compiler and Types in the Closure Type System.</paragraph><heading level="4">9.1.2 Documentation annotations</heading><paragraph>In addition to the JSDoc described in Annotating JavaScript for the Closure Compiler the following tags are common and well supported by various documentation generation tools (such as JsDossier) for purely documentation purposes.</paragraph><heading level="5">9.1.2.1 @author or @owner - Not recommended.</heading><paragraph>Not recommended.</paragraph><paragraph>Syntax: @author username@google.com (First Last)</paragraph><code language="code">/**
 * @fileoverview Utilities for handling textareas.
 * @author kuth@google.com (Uthur Pendragon)
 */
</code><paragraph>Documents the author of a file or the owner of a test, generally only used in the @fileoverview comment. The @owner tag is used by the unit test dashboard to determine who owns the test results.</paragraph><heading level="5">9.1.2.2 @bug</heading><paragraph>Syntax: @bug bugnumber</paragraph><code language="javascript">/** @bug 1234567 */
function testSomething() {
  // …
}

/**
 * @bug 1234568
 * @bug 1234569
 */
function testTwoBugs() {
  // …
}
</code><paragraph>Indicates what bugs the given test function regression tests.</paragraph><paragraph>Multiple bugs should each have their own @bug line, to make searching for regression tests as easy as possible.</paragraph><heading level="5">9.1.2.3 @code - Deprecated. Do not use.</heading><paragraph>Deprecated. Do not use. Use Markdown backticks instead.</paragraph><paragraph>Syntax: {@code ...}</paragraph><paragraph>Historically, `BatchItem` was written as {@code BatchItem}.</paragraph><code language="javascript">/** Processes pending `BatchItem` instances. */
function processBatchItems() {}
</code><paragraph>Indicates that a term in a JSDoc description is code so it may be correctly formatted in generated documentation.</paragraph><heading level="5">9.1.2.4 @desc</heading><paragraph>Syntax: @desc Message description</paragraph><code language="code">/** @desc Notifying a user that their account has been created. */
exports.MSG_ACCOUNT_CREATED = goog.getMsg(
    'Your account has been successfully created.');
</code><heading level="5">9.1.2.5 @link</heading><paragraph>Syntax: {@link ...}</paragraph><paragraph>This tag is used to generate cross-reference links within generated documentation.</paragraph><code language="javascript">/** Processes pending {@link BatchItem} instances. */
function processBatchItems() {}
</code><paragraph>Historical note: @link tags have also been used to create external links in generated documentation. For external links, always use Markdown's link syntax instead:</paragraph><code language="code">/**
 * This class implements a useful subset of the
 * [native Event interface](https://dom.spec.whatwg.org/#event).
 */
class ApplicationEvent {}
</code><heading level="5">9.1.2.6 @see</heading><paragraph>Syntax: @see Link</paragraph><code language="code">/**
 * Adds a single item, recklessly.
 * @see #addSafely
 * @see goog.Collect
 * @see goog.RecklessAdder#add
 */
</code><paragraph>Reference a lookup to another class function or method.</paragraph><heading level="5">9.1.2.7 @supported</heading><paragraph>Syntax: @supported Description</paragraph><code language="code">/**
 * @fileoverview Event Manager
 * Provides an abstracted interface to the browsers' event systems.
 * @supported IE10+, Chrome, Safari
 */
</code><paragraph>Used in a fileoverview to indicate what browsers are supported by the file.</paragraph><paragraph>You may also see other types of JSDoc annotations in third-party code. These annotations appear in the JSDoc Toolkit Tag Reference but are not considered part of valid Google style.</paragraph><heading level="4">9.1.3 Framework specific annotations</heading><paragraph>The following annotations are specific to a particular framework.</paragraph><heading level="5">9.1.3.1 @ngInject for Angular 1</heading><heading level="4">9.1.4 Notes about standard Closure Compiler annotations</heading><paragraph>The following tags used to be standard but are now deprecated.</paragraph><heading level="5">9.1.4.1 @expose - Deprecated. Do not use.</heading><paragraph>Deprecated. Do not use. Use @export and/or @nocollapse instead.</paragraph><heading level="5">9.1.4.2 @inheritDoc - Deprecated. Do not use.</heading><paragraph>Deprecated. Do not use. Use @override instead.</paragraph><heading level="3">9.2 Commonly misunderstood style rules</heading><paragraph>Here is a collection of lesser-known or commonly misunderstood facts about Google Style for JavaScript. (The following are true statements; this is not a list of myths.)</paragraph><list type="ul"><item>Neither a copyright statement nor @author credit is required in a source file. (Neither is explicitly recommended, either.)</item><item>There is no hard and fast rule governing how to order the members of a class (??).</item><item>Empty blocks can usually be represented concisely as {}, as detailed in (??).</item><item>The prime directive of line-wrapping is: prefer to break at a higher syntactic level (??).</item><item>Non-ASCII characters are allowed in string literals, comments and JSDoc, and in fact are recommended when they make the code easier to read than the equivalent Unicode escape would (??).</item></list><paragraph>The following tools exist to support various aspects of Google Style.</paragraph><paragraph>This program performs type checking and other checks, optimizations and other transformations (such as lowering code to ECMAScript 5).</paragraph><heading level="4">9.3.2 clang-format</heading><paragraph>This program reformats JavaScript source code into Google Style, and also follows a number of non-required but frequently readability-enhancing formatting practices. The output produced by clang-format is compliant with the style guide.</paragraph><paragraph>clang-format is not required. Authors are allowed to change its output, and reviewers are allowed to ask for such changes; disputes are worked out in the usual way. However, subtrees may choose to opt in to such enforcement locally.</paragraph><heading level="4">9.3.3 Closure compiler linter</heading><paragraph>This program checks for a variety of missteps and anti-patterns.</paragraph><heading level="4">9.3.4 Conformance framework</heading><paragraph>The JS Conformance Framework is a tool that is part of the Closure Compiler that provides developers a simple means to specify a set of additional checks to be run against their code base above the standard checks. Conformance checks can, for example, forbid access to a certain property, or calls to a certain function, or missing type information (unknowns).</paragraph><paragraph>These rules are commonly used to enforce critical restrictions (such as defining globals, which could break the codebase) and security patterns (such as using eval or assigning to innerHTML), or more loosely to improve code quality.</paragraph><paragraph>For additional information see the official documentation for the JS Conformance Framework.</paragraph><heading level="3">9.4 Exceptions for legacy platforms</heading><heading level="4">9.4.1 Overview</heading><paragraph>This section describes exceptions and additional rules to be followed when modern ECMAScript syntax is not available to the code authors. Exceptions to the recommended style are required when modern ECMAScript syntax is not possible and are outlined here:</paragraph><list type="ul"><item>Use of var declarations is allowed</item><item>Use of arguments is allowed</item><item>Optional parameters without default values are allowed</item></list><heading level="4">9.4.2 Use var</heading><heading level="5">9.4.2.1 var declarations are NOT block-scoped</heading><paragraph>var declarations are scoped to the beginning of the nearest enclosing function, script or module, which can cause unexpected behavior, especially with function closures that reference var declarations inside of loops. The following code gives an example:</paragraph><code language="javascript">for (var i = 0; i < 3; ++i) {
  var iteration = i;
  setTimeout(function() { console.log(iteration); }, i*1000);
}

// logs 2, 2, 2 -- NOT 0, 1, 2
// because `iteration` is function-scoped, not local to the loop.

</code><heading level="5">9.4.2.2 Declare variables as close as possible to first use</heading><paragraph>Even though var declarations are scoped to the beginning of the enclosing function, var declarations should be as close as possible to their first use, for readability purposes. However, do not put a var declaration inside a block if that variable is referenced outside the block. For example:</paragraph><code language="javascript">function sillyFunction() {
  var count = 0;
  for (var x in y) {
    // "count" could be declared here, but don't do that.
    count++;
  }
  console.log(count + ' items in y');
}
</code><heading level="5">9.4.2.3 Use @const for constants variables</heading><paragraph>For global declarations where the const keyword would be used, if it were available, annotate the var declaration with @const instead (this is optional for local variables).</paragraph><heading level="4">9.4.3 Do not use block scoped functions declarations</heading><paragraph>Do not do this:</paragraph><code language="javascript">if (x) {
  function foo() {}
}
</code><paragraph>While most JavaScript VMs implemented before ECMAScript 6 support function declarations within blocks it was not standardized. Implementations were inconsistent with each other and with the now-standard ECMAScript behavior for block scoped function declaration. The ECMAScript 5 standard and prior only allow for function declarations in the root statement list of a script or function and explicitly ban them in block scopes in strict mode.</paragraph><paragraph>To get consistent behavior, instead use a var initialized with a function expression to define a function within a block:</paragraph><code language="javascript">if (x) {
  var foo = function() {};
}
</code><heading level="4">9.4.4 Dependency management with goog.provide/goog.require</heading><heading level="5">9.4.4.1 Summary</heading><paragraph>WARNING: goog.provide dependency management is deprecated. All new files, even in projects using goog.provide for older files, should use goog.module. The following rules are for pre-existing goog.provide files only.</paragraph><list type="ul"><item>Place all goog.provides first, goog.requires second. Separate provides from requires with an empty line.</item><item>Sort the entries alphabetically (uppercase first).</item><item>Don't wrap goog.provide and goog.require statements. Exceed 80 columns if necessary.</item><item>Only provide top-level symbols.</item></list><paragraph>goog.provide statements should be grouped together and placed first. All goog.require statements should follow. The two lists should be separated with an empty line.</paragraph><paragraph>Similar to import statements in other languages, goog.provide and goog.require statements should be written in a single line, even if they exceed the 80 column line length limit.</paragraph><paragraph>The lines should be sorted alphabetically, with uppercase letters coming first:</paragraph><code language="code">goog.provide('namespace.MyClass');
goog.provide('namespace.helperFoo');

goog.require('an.extremelyLongNamespace.thatSomeoneThought.wouldBeNice.andNowItIsLonger.Than80Columns');
goog.require('goog.dom');
goog.require('goog.dom.TagName');
goog.require('goog.dom.classes');
goog.require('goog.dominoes');

</code><paragraph>All members defined on a class should be in the same file. Only top-level classes should be provided in a file that contains multiple members defined on the same class (e.g. enums, inner classes, etc).</paragraph><paragraph>Do this:</paragraph><code language="code">goog.provide('namespace.MyClass');
</code><paragraph>Not this:</paragraph><code language="code">goog.provide('namespace.MyClass');
goog.provide('namespace.MyClass.CONSTANT');
goog.provide('namespace.MyClass.Enum');
goog.provide('namespace.MyClass.InnerClass');
goog.provide('namespace.MyClass.TypeDef');
goog.provide('namespace.MyClass.staticMethod');
</code><paragraph>Members on namespaces may also be provided:</paragraph><code language="code">goog.provide('foo.bar');
goog.provide('foo.bar.CONSTANT');
goog.provide('foo.bar.method');
</code><heading level="5">9.4.4.2 Aliasing with goog.scope</heading><paragraph>WARNING: goog.scope is deprecated. New files should not use goog.scope even in projects with existing goog.scope usage.</paragraph><paragraph>goog.scope may be used to shorten references to namespaced symbols in code using goog.provide/goog.require dependency management.</paragraph><paragraph>Only one goog.scope invocation may be added per file. Always place it in the global scope.</paragraph><paragraph>The opening goog.scope(function() { invocation must be preceded by exactly one blank line and follow any goog.provide statements, goog.require statements, or top-level comments. The invocation must be closed on the last line in the file. Append // goog.scope to the closing statement of the scope. Separate the comment from the semicolon by two spaces.</paragraph><paragraph>Similar to C++ namespaces, do not indent under goog.scope declarations. Instead, continue from the 0 column.</paragraph><paragraph>Only make aliases for names that will not be re-assigned to another object (e.g., most constructors, enums, and namespaces). Do not do this (see below for how to alias a constructor):</paragraph><code language="javascript">goog.scope(function() {
var Button = goog.ui.Button;

Button = function() { ... };
...
</code><paragraph>Names must be the same as the last property of the global that they are aliasing.</paragraph><code language="javascript">goog.provide('my.module.SomeType');

goog.require('goog.dom');
goog.require('goog.ui.Button');

goog.scope(function() {
var Button = goog.ui.Button;
var dom = goog.dom;

// Alias new types after the constructor declaration.
my.module.SomeType = function() { ... };
var SomeType = my.module.SomeType;

// Declare methods on the prototype as usual:
SomeType.prototype.findButton = function() {
  // Button as aliased above.
  this.button = new Button(dom.getElement('my-button'));
};
...
});  // goog.scope
</code><heading level="5">9.4.4.3 goog.forwardDeclare</heading><paragraph>Prefer to use goog.requireType instead of goog.forwardDeclare to break circular dependencies between files in the same library. Unlike goog.require, a goog.requireType statement is allowed to import a namespace before it is defined.</paragraph><paragraph>goog.forwardDeclare statements must follow the same style rules as goog.require and goog.requireType. The entire block of goog.forwardDeclare, goog.require and goog.requireType statements is sorted alphabetically.</paragraph><paragraph>goog.forwardDeclare is used in legacy code to break circular references spanning across library boundaries. This pattern however is poorly supported by build tools and should not be used. Code should be organized to avoid circular dependencies across libraries (by splitting/merging libraries).</paragraph><heading level="5">9.4.4.4 goog.module.get(name)</heading><paragraph>If a goog.provide file depends on a goog.module file, the goog.provide file can not normally refer to the module's exports via a global name. Instead, in addition to goog.require()ing the module, the goog.provide file must fetch the module's export object by calling goog.module.get('module.name').</paragraph><paragraph>Note: Only calling goog.module.get('module.name') does not create a build-time dependency of your code on the module. The goog.require is needed for the build dependency.</paragraph><heading level="5">9.4.4.5 goog.module.declareLegacyNamespace()</heading><paragraph>WARNING: goog.module.declareLegacyNamespace is only for transitional use.</paragraph><paragraph>goog.module.declareLegacyNamespace is only for use while migrating a JavaScript file and its consumers from goog.provide to goog.module . Update consumers of your goog.module to use goog.module themselves. Remove calls to goog.module.declareLegacyNamespace whenever possible.</paragraph><paragraph>If you can't update consumers of a legacy namespace from goog.provide to goog.module soon, please wrap the contents of your file in a call to goog.scope, use goog.module.get to import the legacy namespace--and then delete the call to goog.module.declareLegacyNamespace in your goog.module.</paragraph><paragraph>Calling goog.module.declareLegacyNamespace() inside a goog.module(name) will declare the module's namespace as a global name just like a goog.provide() call does. This allows a non goog.module namespace to access the module's exports without calling goog.module.get(name).</paragraph></content>
</page>
<page url="https://google.github.io/styleguide/javaguide.html">
<title>Google Java Style Guide</title>
<content><heading level="2">1 Introduction</heading><paragraph>This document serves as the complete definition of Google's coding standards for source code in the Java™ Programming Language. A Java source file is described as being in Google Style if and only if it adheres to the rules herein.</paragraph><paragraph>Like other programming style guides, the issues covered span not only aesthetic issues of formatting, but other types of conventions or coding standards as well. However, this document focuses primarily on the hard-and-fast rules that we follow universally, and avoids giving advice that isn't clearly enforceable (whether by human or tool).</paragraph><heading level="3">1.1 Terminology notes</heading><paragraph>In this document, unless otherwise clarified:</paragraph><list type="ol"><item>The term class is used inclusively to mean a normal class, record class, enum class, interface or annotation type (@interface).</item><item>The term member (of a class) is used inclusively to mean a nested class, field, method, or constructor; that is, all top-level contents of a class except initializers.</item><item>The term comment always refers to implementation comments. We do not use the phrase "documentation comments", and instead use the common term "Javadoc."</item></list><paragraph>Other "terminology notes" will appear occasionally throughout the document.</paragraph><heading level="3">1.2 Guide notes</heading><paragraph>Example code in this document is non-normative. That is, while the examples are in Google Style, they may not illustrate the only stylish way to represent the code. Optional formatting choices made in examples should not be enforced as rules.</paragraph><heading level="2">2 Source file basics</heading><heading level="3">2.1 File name</heading><paragraph>For a source file containing classes, the file name consists of the case-sensitive name of the top-level class (of which there is exactly one), plus the .java extension.</paragraph><heading level="3">2.2 File encoding: UTF-8</heading><paragraph>Source files are encoded in UTF-8.</paragraph><heading level="3">2.3 Special characters</heading><heading level="4">2.3.1 Whitespace characters</heading><paragraph>Aside from the line terminator sequence, the ASCII horizontal space character (0x20) is the only whitespace character that appears anywhere in a source file. This implies that:</paragraph><list type="ol"><item>All other whitespace characters are escaped in char and string literals and in text blocks.</item><item>Tab characters are not used for indentation.</item></list><heading level="4">2.3.2 Special escape sequences</heading><paragraph>For any character that has a special escape sequence (\b, \t, \n, \f, \r, \s, \", \' and \\), that sequence is used rather than the corresponding octal (e.g. \012) or Unicode (e.g. \u000a) escape.</paragraph><heading level="4">2.3.3 Non-ASCII characters</heading><paragraph>For the remaining non-ASCII characters, either the actual Unicode character (e.g. ∞) or the equivalent Unicode escape (e.g. \u221e) is used. The choice depends only on which makes the code easier to read and understand, although Unicode escapes outside string literals and comments are strongly discouraged.</paragraph><paragraph>Tip: In the Unicode escape case, and occasionally even when actual Unicode characters are used, an explanatory comment can be very helpful.</paragraph><paragraph>Examples:</paragraph><table><thead><tr><th>Example</th><th>Discussion</th></tr></thead><tbody><tr><td>String unitAbbrev = "μs";</td><td>Best: perfectly clear even without a comment.</td></tr><tr><td>String unitAbbrev = "\u03bcs"; // "μs"</td><td>Allowed, but there's no reason to do this.</td></tr><tr><td>String unitAbbrev = "\u03bcs"; // Greek letter mu, "s"</td><td>Allowed, but awkward and prone to mistakes.</td></tr><tr><td>String unitAbbrev = "\u03bcs";</td><td>Poor: the reader has no idea what this is.</td></tr><tr><td>return '\ufeff' + content; // byte order mark</td><td>Good: use escapes for non-printable characters, and comment if necessary.</td></tr></tbody></table><paragraph>Tip: Never make your code less readable simply out of fear that some programs might not handle non-ASCII characters properly. If that should happen, those programs are broken and they must be fixed.</paragraph><heading level="2">3 Source file structure</heading><paragraph>An ordinary source file consists of these sections, in order:</paragraph><list type="ol"><item>License or copyright information, if present</item><item>Package declaration</item><item>Imports</item><item>Exactly one top-level class declaration</item></list><paragraph>Exactly one blank line separates each section that is present.</paragraph><paragraph>A package-info.java file is the same, but without the class declaration.</paragraph><paragraph>A module-info.java file does not contain a package declaration and replaces the class declaration with a module declaration, but otherwise follows the same structure.</paragraph><heading level="3">3.1 License or copyright information, if present</heading><paragraph>If license or copyright information belongs in a file, it belongs here.</paragraph><heading level="3">3.2 Package declaration</heading><paragraph>The package declaration is not line-wrapped. The column limit (Section 4.4, Column limit: 100) does not apply to package declarations.</paragraph><heading level="3">3.3 Imports</heading><heading level="4">3.3.1 No wildcard imports</heading><paragraph>Wildcard ("on-demand") imports, static or otherwise, are not used.</paragraph><heading level="4">3.3.2 No line-wrapping</heading><paragraph>Imports are not line-wrapped. The column limit (Section 4.4, Column limit: 100) does not apply to imports.</paragraph><heading level="4">3.3.3 Ordering and spacing</heading><paragraph>Imports are ordered as follows:</paragraph><list type="ol"><item>All static imports in a single group.</item><item>All non-static imports in a single group.</item></list><paragraph>If there are both static and non-static imports, a single blank line separates the two groups. There are no other blank lines between imports.</paragraph><paragraph>Within each group the imported names appear in ASCII sort order. (Note: this is not the same as the import lines being in ASCII sort order, since '.' sorts before ';'.)</paragraph><heading level="4">3.3.4 No static import for classes</heading><paragraph>Static import is not used for static nested classes. They are imported with normal imports.</paragraph><heading level="3">3.4 Class declaration</heading><heading level="4">3.4.1 Exactly one top-level class declaration</heading><paragraph>Each top-level class resides in a source file of its own.</paragraph><heading level="4">3.4.2 Ordering of class contents</heading><paragraph>The order you choose for the members and initializers of your class can have a great effect on learnability. However, there's no single correct recipe for how to do it; different classes may order their contents in different ways.</paragraph><paragraph>What is important is that each class uses some logical order, which its maintainer could explain if asked. For example, new methods are not just habitually added to the end of the class, as that would yield "chronological by date added" ordering, which is not a logical ordering.</paragraph><heading level="5">3.4.2.1 Overloads: never split</heading><paragraph>Methods of a class that share the same name appear in a single contiguous group with no other members in between. The same applies to multiple constructors. This rule applies even when modifiers such as static or private differ between the methods or constructors.</paragraph><heading level="3">3.5 Module declaration</heading><heading level="4">3.5.1 Ordering and spacing of module directives</heading><paragraph>Module directives are ordered as follows:</paragraph><list type="ol"><item>All requires directives in a single block.</item><item>All exports directives in a single block.</item><item>All opens directives in a single block.</item><item>All uses directives in a single block.</item><item>All provides directives in a single block.</item></list><paragraph>A single blank line separates each block that is present.</paragraph><heading level="2">4 Formatting</heading><paragraph>Terminology Note: block-like construct refers to the body of a class, method, constructor, or switch. Note that, by Section 4.8.3.1 on array initializers, any array initializer may optionally be treated as if it were a block-like construct.</paragraph><heading level="3">4.1 Braces</heading><heading level="4">4.1.1 Use of optional braces</heading><paragraph>Braces are used with if, else, for, do and while statements, even when the body is empty or contains only a single statement.</paragraph><paragraph>Other optional braces, such as those in a lambda expression, remain optional.</paragraph><heading level="4">4.1.2 Nonempty blocks: K & R style</heading><paragraph>Braces follow the Kernighan and Ritchie style for nonempty blocks and block-like constructs:</paragraph><list type="ul"><item>No line break before the opening brace, except as detailed below.</item><item>Line break after the opening brace.</item><item>Line break before the closing brace.</item><item>Line break after the closing brace, only if that brace terminates a statement or terminates the body of a method, constructor, or named class. For example, there is no line break after the brace if it is followed by else or a comma.</item></list><paragraph>Exception: In places where these rules allow a single statement ending with a semicolon (;), a block of statements can appear, and the opening brace of this block is preceded by a line break. Blocks like these are typically introduced to limit the scope of local variables.</paragraph><paragraph>Examples:</paragraph><code language="javascript">return () -> {
  while (condition()) {
    method();
  }
};

return new MyClass() {
  @Override public void method() {
    if (condition()) {
      try {
        something();
      } catch (ProblemException e) {
        recover();
      }
    } else if (otherCondition()) {
      somethingElse();
    } else {
      lastThing();
    }
    {
      int x = foo();
      frob(x);
    }
  }
};
</code><paragraph>A few exceptions for enum classes are given in Section 4.8.1, Enum classes.</paragraph><heading level="4">4.1.3 Empty blocks: may be concise</heading><paragraph>An empty block or block-like construct may be in K & R style (as described in Section 4.1.2). Alternatively, it may be closed immediately after it is opened, with no characters or line break in between ({}), unless it is part of a multi-block statement (one that directly contains multiple blocks: if/else or try/catch/finally).</paragraph><paragraph>Examples:</paragraph><code language="javascript">  // This is acceptable
  void doNothing() {}

  // This is equally acceptable
  void doNothingElse() {
  }
</code><code language="javascript">  // This is not acceptable: No concise empty blocks in a multi-block statement
  try {
    doSomething();
  } catch (Exception e) {}
</code><heading level="3">4.2 Block indentation: +2 spaces</heading><paragraph>Each time a new block or block-like construct is opened, the indent increases by two spaces. When the block ends, the indent returns to the previous indent level. The indent level applies to both code and comments throughout the block. (See the example in Section 4.1.2, Nonempty blocks: K & R Style.)</paragraph><heading level="3">4.3 One statement per line</heading><paragraph>Each statement is followed by a line break.</paragraph><heading level="3">4.4 Column limit: 100</heading><paragraph>Java code has a column limit of 100 characters. A "character" means any Unicode code point. Except as noted below, any line that would exceed this limit must be line-wrapped, as explained in Section 4.5, Line-wrapping.</paragraph><paragraph>Each Unicode code point counts as one character, even if its display width is greater or less. For example, if using fullwidth characters, you may choose to wrap the line earlier than where this rule strictly requires.</paragraph><paragraph>Exceptions:</paragraph><list type="ol"><item>Lines where obeying the column limit is not possible (for example, a long URL in Javadoc, or a long JSNI method reference).</item><item>package declarations and imports (see Sections 3.2 Package declarations and 3.3 Imports).</item><item>Contents of text blocks.</item><item>Command lines in a comment that may be copied-and-pasted into a shell.</item><item>Very long identifiers, on the rare occasions they are called for, are allowed to exceed the column limit. In that case, the valid wrapping for the surrounding code is as produced by google-java-format.</item></list><heading level="3">4.5 Line-wrapping</heading><paragraph>Terminology Note: When code that might otherwise occupy a single line is divided into multiple lines, this activity is called line-wrapping.</paragraph><paragraph>There is no comprehensive, deterministic formula showing exactly how to line-wrap in every situation. Very often there are several valid ways to line-wrap the same piece of code.</paragraph><paragraph>Note: While the typical reason for line-wrapping is to avoid overflowing the column limit, even code that would in fact fit within the column limit may be line-wrapped at the author's discretion.</paragraph><paragraph>Tip: Extracting a method or local variable may solve the problem without the need to line-wrap.</paragraph><heading level="4">4.5.1 Where to break</heading><paragraph>The prime directive of line-wrapping is: prefer to break at a higher syntactic level. Also:</paragraph><list type="ol"><item>When a line is broken at a non-assignment operator the break comes before the symbol. (Note that this is not the same practice used in Google style for other languages, such as C++ and JavaScript.) This also applies to the following "operator-like" symbols: the dot separator (.) the two colons of a method reference (::) an ampersand in a type bound (<T extends Foo & Bar>) a pipe in a catch block (catch (FooException | BarException e)).</item><item>When a line is broken at an assignment operator the break typically comes after the symbol, but either way is acceptable. This also applies to the colon in an enhanced for ("foreach") statement.</item><item>A method, constructor, or record-class name stays attached to the open parenthesis (() that follows it.</item><item>A comma (,) stays attached to the token that precedes it.</item><item>A line is never broken adjacent to the arrow in a lambda or a switch rule, except that a break may come immediately after the arrow if the text following it consists of a single unbraced expression. Examples: MyLambda<String, Long, Object> lambda = (String label, Long value, Object obj) -> { ... }; Predicate<String> predicate = str -> longExpressionInvolving(str); switch (x) { case ColorPoint(Color color, Point(int x, int y)) -> handleColorPoint(color, x, y); ... }</item></list><list type="ul"><item>This also applies to the following "operator-like" symbols: the dot separator (.) the two colons of a method reference (::) an ampersand in a type bound (<T extends Foo & Bar>) a pipe in a catch block (catch (FooException | BarException e)).</item></list><list type="ul"><item>the dot separator (.)</item><item>the two colons of a method reference (::)</item><item>an ampersand in a type bound (<T extends Foo & Bar>)</item><item>a pipe in a catch block (catch (FooException | BarException e)).</item></list><list type="ul"><item>This also applies to the colon in an enhanced for ("foreach") statement.</item></list><code language="javascript">MyLambda<String, Long, Object> lambda =
    (String label, Long value, Object obj) -> {
      ...
    };

Predicate<String> predicate = str ->
    longExpressionInvolving(str);

switch (x) {
  case ColorPoint(Color color, Point(int x, int y)) ->
      handleColorPoint(color, x, y);
  ...
}
</code><paragraph>Note: The primary goal for line wrapping is to have clear code, not necessarily code that fits in the smallest number of lines.</paragraph><heading level="4">4.5.2 Indent continuation lines at least +4 spaces</heading><paragraph>When line-wrapping, each line after the first (each continuation line) is indented at least +4 from the original line.</paragraph><paragraph>When there are multiple continuation lines, indentation may be varied beyond +4 as desired. In general, two continuation lines use the same indentation level if and only if they begin with syntactically parallel elements.</paragraph><paragraph>Section 4.6.3 on Horizontal alignment addresses the discouraged practice of using a variable number of spaces to align certain tokens with previous lines.</paragraph><heading level="3">4.6 Whitespace</heading><heading level="4">4.6.1 Vertical whitespace (blank lines)</heading><paragraph>A single blank line always appears:</paragraph><list type="ol"><item>Between consecutive members or initializers of a class: fields, constructors, methods, nested classes, static initializers, and instance initializers. Exception: A blank line between two consecutive fields (having no other code between them) is optional. Such blank lines are used as needed to create logical groupings of fields. Exception: Blank lines between enum constants are covered in Section 4.8.1.</item><item>As required by other sections of this document (such as Section 3, Source file structure, and Section 3.3, Imports).</item></list><list type="ul"><item>Exception: A blank line between two consecutive fields (having no other code between them) is optional. Such blank lines are used as needed to create logical groupings of fields.</item><item>Exception: Blank lines between enum constants are covered in Section 4.8.1.</item></list><paragraph>A single blank line may also appear anywhere it improves readability, for example between statements to organize the code into logical subsections. A blank line before the first member or initializer, or after the last member or initializer of the class, is neither encouraged nor discouraged.</paragraph><paragraph>Multiple consecutive blank lines are permitted, but never required (or encouraged).</paragraph><heading level="4">4.6.2 Horizontal whitespace</heading><paragraph>Beyond where required by the language or other style rules, and apart from within literals, comments and Javadoc, a single ASCII space also appears in the following places only.</paragraph><list type="ol"><item>Separating any keyword, such as if, for or catch, from an open parenthesis (() that follows it on that line</item><item>Separating any keyword, such as else or catch, from a closing curly brace (}) that precedes it on that line</item><item>Before any open curly brace ({), with two exceptions: @SomeAnnotation({a, b}) (no space is used) String[][] x = {{"foo"}}; (no space is required between {{, by item 10 below)</item><item>On both sides of any binary or ternary operator. This also applies to the following "operator-like" symbols: the ampersand that separates multiple type bounds: <T extends Foo & Bar> the pipe for a catch block that handles multiple exceptions: catch (FooException | BarException e) the colon (:) in an enhanced for ("foreach") statement the arrow in a lambda expression: (String str) -> str.length() or switch rule: case "FOO" -> bar(); but not the two colons (::) of a method reference, which is written like Object::toString the dot separator (.), which is written like object.toString()</item><item>After ,:; or the closing parenthesis ()) of a cast</item><item>Between any content and a double slash (//) which begins a comment. Multiple spaces are allowed.</item><item>Between a double slash (//) which begins a comment and the comment's text. Multiple spaces are allowed.</item><item>Between the type and identifier of a declaration: List<String> list</item><item>Optional just inside both braces of an array initializer new int[] {5, 6} and new int[] { 5, 6 } are both valid</item><item>Between a type annotation and [] or ....</item></list><list type="ul"><item>@SomeAnnotation({a, b}) (no space is used)</item><item>String[][] x = {{"foo"}}; (no space is required between {{, by item 10 below)</item></list><list type="ul"><item>the ampersand that separates multiple type bounds: <T extends Foo & Bar></item><item>the pipe for a catch block that handles multiple exceptions: catch (FooException | BarException e)</item><item>the colon (:) in an enhanced for ("foreach") statement</item><item>the arrow in a lambda expression: (String str) -> str.length() or switch rule: case "FOO" -> bar();</item></list><list type="ul"><item>the two colons (::) of a method reference, which is written like Object::toString</item><item>the dot separator (.), which is written like object.toString()</item></list><list type="ul"><item>new int[] {5, 6} and new int[] { 5, 6 } are both valid</item></list><paragraph>This rule is never interpreted as requiring or forbidding additional space at the start or end of a line; it addresses only interior space.</paragraph><heading level="4">4.6.3 Horizontal alignment: never required</heading><paragraph>Terminology Note: Horizontal alignment is the practice of adding a variable number of additional spaces in your code with the goal of making certain tokens appear directly below certain other tokens on previous lines.</paragraph><paragraph>This practice is permitted, but is never required by Google Style. It is not even required to maintain horizontal alignment in places where it was already used.</paragraph><paragraph>Here is an example without alignment, then using alignment:</paragraph><code language="code">private int x; // this is fine
private Color color; // this too

private int   x;      // permitted, but future edits
private Color color;  // may leave it unaligned
</code><paragraph>Tip: Alignment can aid readability, but attempting to preserve alignment for its own sake creates future problems. For example, consider a change that touches only one line. If that change disrupts the previous alignment, it's important **not** to introduce additional changes on nearby lines simply to realign them. Introducing formatting changes on otherwise unaffected lines corrupts version history, slows down reviewers, and exacerbates merge conflicts. These practical concerns take priority over alignment.</paragraph><heading level="3">4.7 Grouping parentheses: recommended</heading><paragraph>Optional grouping parentheses are omitted only when author and reviewer agree that there is no reasonable chance the code will be misinterpreted without them, nor would they have made the code easier to read. It is not reasonable to assume that every reader has the entire Java operator precedence table memorized.</paragraph><heading level="3">4.8 Specific constructs</heading><heading level="4">4.8.1 Enum classes</heading><paragraph>After the comma that follows an enum constant, a line break is optional. Additional blank lines (usually just one) are also allowed. This is one possibility:</paragraph><code language="javascript">private enum Answer {
  YES {
    @Override public String toString() {
      return "yes";
    }
  },

  NO,
  MAYBE
}
</code><paragraph>An enum class with no methods and no documentation on its constants may optionally be formatted as if it were an array initializer (see Section 4.8.3.1 on array initializers).</paragraph><code language="code">private enum Suit { CLUBS, HEARTS, SPADES, DIAMONDS }
</code><paragraph>Since enum classes are classes, all other rules for formatting classes apply.</paragraph><heading level="4">4.8.2 Variable declarations</heading><heading level="5">4.8.2.1 One variable per declaration</heading><paragraph>Every variable declaration (field or local) declares only one variable: declarations such as int a, b; are not used.</paragraph><paragraph>Exception: Multiple variable declarations are acceptable in the header of a for loop.</paragraph><heading level="5">4.8.2.2 Declared when needed</heading><paragraph>Local variables are not habitually declared at the start of their containing block or block-like construct. Instead, local variables are declared close to the point they are first used (within reason), to minimize their scope. Local variable declarations typically have initializers, or are initialized immediately after declaration.</paragraph><heading level="4">4.8.3 Arrays</heading><heading level="5">4.8.3.1 Array initializers: can be "block-like"</heading><paragraph>Any array initializer may optionally be formatted as if it were a "block-like construct." For example, the following are all valid (not an exhaustive list):</paragraph><code language="javascript">new int[] {           new int[] {
  0, 1, 2, 3            0,
}                       1,
                        2,
new int[] {             3,
  0, 1,               }
  2, 3
}                     new int[]
                          {0, 1, 2, 3}
</code><heading level="5">4.8.3.2 No C-style array declarations</heading><paragraph>The square brackets form a part of the type, not the variable: String[] args, not String args[].</paragraph><heading level="4">4.8.4 Switch statements and expressions</heading><paragraph>For historical reasons, the Java language has two distinct syntaxes for switch, which we can call old-style and new-style. New-style switches use an arrow (->) after the switch labels, while old-style switches use a colon (:).</paragraph><paragraph>Terminology Note: Inside the braces of a switch block are either one or more switch rules (new-style); or one or more statement groups (old-style). A switch rule consists of a switch label (case ... or default) followed by -> and an expression, block, or throw. A statement group consists of one or more switch labels each followed by a colon, then one or more statements, or, for the last statement group, zero or more statements. (These definitions match the Java Language Specification, §14.11.)</paragraph><heading level="5">4.8.4.1 Indentation</heading><paragraph>As with any other block, the contents of a switch block are indented +2. Each switch label starts with this +2 indentation.</paragraph><paragraph>In a new-style switch, a switch rule can be written on a single line if it otherwise follows Google style. (It must not exceed the column limit, and if it contains a non-empty block then there must be a line break after {.) The line-wrapping rules of Section 4.5 apply, including the +4 indent for continuation lines. For a switch rule with a non-empty block after the arrow, the same rules apply as for blocks elsewhere: lines between { and } are indented a further +2 relative to the line with the switch label.</paragraph><code language="javascript">switch (number) {
  case 0, 1 -> handleZeroOrOne();
  case 2 ->
      handleTwoWithAnExtremelyLongMethodCallThatWouldNotFitOnTheSameLine();
  default -> {
    logger.atInfo().log("Surprising number %s", number);
    handleSurprisingNumber(number);
  }
}
</code><paragraph>In an old-style switch, the colon of each switch label is followed by a line break. The statements within a statement group are indented a further +2.</paragraph><heading level="5">4.8.4.2 Fall-through: commented</heading><paragraph>Within an old-style switch block, each statement group either terminates abruptly (with a break, continue, return or thrown exception), or is marked with a comment to indicate that execution will or might continue into the next statement group. Any comment that communicates the idea of fall-through is sufficient (typically // fall through). This special comment is not required in the last statement group of the switch block. Example:</paragraph><code language="javascript">switch (input) {
  case 1:
  case 2:
    prepareOneOrTwo();
  // fall through
  case 3:
    handleOneTwoOrThree();
    break;
  default:
    handleLargeNumber(input);
}
</code><paragraph>Notice that no comment is needed after case 1:, only at the end of the statement group.</paragraph><paragraph>There is no fall-through in new-style switches.</paragraph><heading level="5">4.8.4.3 Exhaustiveness and presence of the default label</heading><paragraph>The Java language requires switch expressions and many kinds of switch statements to be exhaustive. That effectively means that every possible value that could be switched on will be matched by one of the switch labels. A switch is exhaustive if it has a default label, but also for example if the value being switched on is an enum and every value of the enum is matched by a switch label. Google Style requires every switch to be exhaustive, even those where the language itself does not require it. This may require adding a default label, even if it contains no code.</paragraph><heading level="5">4.8.4.4 Switch expressions</heading><paragraph>Switch expressions must be new-style switches:</paragraph><code language="javascript">  return switch (list.size()) {
    case 0 -> "";
    case 1 -> list.getFirst();
    default -> String.join(", ", list);
  };
</code><heading level="4">4.8.5 Annotations</heading><heading level="5">4.8.5.1 Type-use annotations</heading><paragraph>Type-use annotations appear immediately before the annotated type. An annotation is a type-use annotation if it is meta-annotated with @Target(ElementType.TYPE_USE). Example:</paragraph><code language="code">final @Nullable String name;

public @Nullable Person getPersonByName(String name);
</code><heading level="5">4.8.5.2 Class, package, and module annotations</heading><paragraph>Annotations applying to a class, package, or module declaration appear immediately after the documentation block, and each annotation is listed on a line of its own (that is, one annotation per line). These line breaks do not constitute line-wrapping (Section 4.5, Line-wrapping), so the indentation level is not increased. Examples:</paragraph><code language="code">/** This is a class. */
@Deprecated
@CheckReturnValue
public final class Frozzler { ... }
</code><code language="code">/** This is a package. */
@Deprecated
@CheckReturnValue
package com.example.frozzler;
</code><code language="code">/** This is a module. */
@Deprecated
@SuppressWarnings("CheckReturnValue")
module com.example.frozzler { ... }
</code><heading level="5">4.8.5.3 Method and constructor annotations</heading><paragraph>The rules for annotations on method and constructor declarations are the same as the previous section. Example:</paragraph><code language="java">@Deprecated
@Override
public String getNameIfPresent() { ... }
</code><paragraph>Exception: A single parameterless annotation may instead appear together with the first line of the signature, for example:</paragraph><code language="java">@Override public int hashCode() { ... }
</code><heading level="5">4.8.5.4 Field annotations</heading><paragraph>Annotations applying to a field also appear immediately after the documentation block, but in this case, multiple annotations (possibly parameterized) may be listed on the same line; for example:</paragraph><code language="code">@Partial @Mock DataLoader loader;
</code><heading level="5">4.8.5.5 Parameter and local variable annotations</heading><paragraph>There are no specific rules for formatting annotations on parameters or local variables (except, of course, when the annotation is a type-use annotation).</paragraph><paragraph>This section addresses implementation comments. Javadoc is addressed separately in Section 7, Javadoc.</paragraph><paragraph>Any line break may be preceded by arbitrary whitespace followed by an implementation comment. Such a comment renders the line non-blank.</paragraph><paragraph>Block comments are indented at the same level as the surrounding code. They may be in /* ... */ style or // ... style. For multi-line /* ... */ comments, subsequent lines must start with * aligned with the * on the previous line.</paragraph><code language="code">/*
 * This is          // And so           /* Or you can
 * okay.            // is this.          * even do this. */
 */
</code><paragraph>Comments are not enclosed in boxes drawn with asterisks or other characters.</paragraph><paragraph>Tip: When writing multi-line comments, use the /* ... */ style if you want automatic code formatters to re-wrap the lines when necessary (paragraph-style). Most formatters don't re-wrap lines in // ... style comment blocks.</paragraph><paragraph>Use TODO comments for code that is temporary, a short-term solution, or good-enough but not perfect.</paragraph><paragraph>A TODO comment begins with the word TODO in all caps, a following colon, and a link to a resource that contains the context, ideally a bug reference. A bug reference is preferable because bugs are tracked and have follow-up comments. Follow this piece of context with an explanatory string introduced with a hyphen -.</paragraph><paragraph>The purpose is to have a consistent TODO format that can be searched to find out how to get more details.</paragraph><code language="code">// TODO: crbug.com/12345678 - Remove this after the 2047q4 compatibility window expires.
</code><paragraph>Avoid adding TODOs that refer to an individual or team as the context:</paragraph><code language="code">// TODO: @yourusername - File an issue and use a '*' for repetition.
</code><paragraph>If your TODO is of the form "At a future date do something" make sure that you either include a very specific date ("Fix by November 2005") or a very specific event ("Remove this code when all clients can handle XML responses.").</paragraph><heading level="4">4.8.7 Modifiers</heading><paragraph>Class and member modifiers, when present, appear in the order recommended by the Java Language Specification:</paragraph><code language="code">public protected private abstract default static final sealed non-sealed
  transient volatile synchronized native strictfp
</code><paragraph>Modifiers on requires module directives, when present, appear in the following order:</paragraph><code language="code">transitive static</code><heading level="4">4.8.8 Numeric Literals</heading><paragraph>long-valued integer literals use an uppercase L suffix, never lowercase (to avoid confusion with the digit 1). For example, 3000000000L rather than 3000000000l.</paragraph><heading level="4">4.8.9 Text Blocks</heading><paragraph>The opening """ of a text block is always on a new line. That line may either follow the same indentation rules as other constructs, or it may have no indentation at all (so it starts at the left margin). The closing """ is on a new line with the same indentation as the opening """, and may be followed on the same line by further code. Each line of text in the text block is indented at least as much as the opening and closing """. (If a line is indented further, then the string literal defined by the text block will have space at the start of that line.)</paragraph><paragraph>The contents of a text block may exceed the column limit.</paragraph><heading level="2">5 Naming</heading><heading level="3">5.1 Rules common to all identifiers</heading><paragraph>Identifiers use only ASCII letters and digits, and, in a small number of cases noted below, underscores. Thus each valid identifier name is matched by the regular expression \w+ .</paragraph><paragraph>In Google Style, special prefixes or suffixes are not used. For example, these names are not Google Style: name_, mName, s_name and kName.</paragraph><heading level="3">5.2 Rules by identifier type</heading><heading level="4">5.2.1 Package and module names</heading><paragraph>Package and module names use only lowercase letters and digits (no underscores). Consecutive words are simply concatenated together. For example, com.example.deepspace, not com.example.deepSpace or com.example.deep_space.</paragraph><heading level="4">5.2.2 Class names</heading><paragraph>Class names are written in UpperCamelCase.</paragraph><paragraph>Class names are typically nouns or noun phrases. For example, Character or ImmutableList. Interface names may also be nouns or noun phrases (for example, List), but may sometimes be adjectives or adjective phrases instead (for example, Readable).</paragraph><paragraph>There are no specific rules or even well-established conventions for naming annotation types.</paragraph><paragraph>A test class has a name that ends with Test, for example, HashIntegrationTest. If it covers a single class, its name is the name of that class plus Test, for example HashImplTest.</paragraph><heading level="4">5.2.3 Method names</heading><paragraph>Method names are written in lowerCamelCase.</paragraph><paragraph>Method names are typically verbs or verb phrases. For example, sendMessage or stop.</paragraph><paragraph>Underscores may appear in JUnit test method names to separate logical components of the name, with each component written in lowerCamelCase, for example transferMoney_deductsFromSource. There is no One Correct Way to name test methods.</paragraph><heading level="4">5.2.4 Constant names</heading><paragraph>Constant names use UPPER_SNAKE_CASE: all uppercase letters, with each word separated from the next by a single underscore. But what is a constant, exactly?</paragraph><paragraph>Constants are static final fields whose contents are deeply immutable and whose methods have no detectable side effects. Examples include primitives, strings, immutable value classes, and anything set to null. If any of the instance's observable state can change, it is not a constant. Merely intending to never mutate the object is not enough. Examples:</paragraph><code language="code">// Constants
static final int NUMBER = 5;
static final ImmutableList<String> NAMES = ImmutableList.of("Ed", "Ann");
static final Map<String, Integer> AGES = ImmutableMap.of("Ed", 35, "Ann", 32);
static final Joiner COMMA_JOINER = Joiner.on(','); // because Joiner is immutable
static final SomeMutableType[] EMPTY_ARRAY = {};

// Not constants
static String nonFinal = "non-final";
final String nonStatic = "non-static";
static final Set<String> mutableCollection = new HashSet<String>();
static final ImmutableSet<SomeMutableType> mutableElements = ImmutableSet.of(mutable);
static final ImmutableMap<String, SomeMutableType> mutableValues =
    ImmutableMap.of("Ed", mutableInstance, "Ann", mutableInstance2);
static final Logger logger = Logger.getLogger(MyClass.getName());
static final String[] nonEmptyArray = {"these", "can", "change"};
</code><paragraph>These names are typically nouns or noun phrases.</paragraph><heading level="4">5.2.5 Non-constant field names</heading><paragraph>Non-constant field names (static or otherwise) are written in lowerCamelCase.</paragraph><paragraph>These names are typically nouns or noun phrases. For example, computedValues or index.</paragraph><heading level="4">5.2.6 Parameter names</heading><paragraph>Parameter names are written in lowerCamelCase.</paragraph><paragraph>One-character parameter names in public methods should be avoided.</paragraph><heading level="4">5.2.7 Local variable names</heading><paragraph>Local variable names are written in lowerCamelCase.</paragraph><paragraph>Even when final and immutable, local variables are not considered to be constants, and should not be styled as constants.</paragraph><heading level="4">5.2.8 Type variable names</heading><paragraph>Each type variable is named in one of two styles:</paragraph><list type="ul"><item>A single capital letter, optionally followed by a single numeral (such as E, T, X, T2)</item><item>A name in the form used for classes (see Section 5.2.2, Class names), followed by the capital letter T (examples: RequestT, FooBarT).</item></list><heading level="3">5.3 Camel case: defined</heading><paragraph>Sometimes there is more than one reasonable way to convert an English phrase into camel case, such as when acronyms or unusual constructs like "IPv6" or "iOS" are present. To improve predictability, Google Style specifies the following (nearly) deterministic scheme.</paragraph><paragraph>Beginning with the prose form of the name:</paragraph><list type="ol"><item>Convert the phrase to plain ASCII and remove any apostrophes. For example, "Müller's algorithm" might become "Muellers algorithm".</item><item>Divide this result into words, splitting on spaces and any remaining punctuation (typically hyphens). Recommended: if any word already has a conventional camel-case appearance in common usage, split this into its constituent parts (e.g., "AdWords" becomes "ad words"). Note that a word such as "iOS" is not really in camel case per se; it defies any convention, so this recommendation does not apply.</item><item>Now lowercase everything (including acronyms), then uppercase only the first character of: ... each word, to yield upper camel case, or ... each word except the first, to yield lower camel case</item><item>Finally, join all the words into a single identifier. Note that the casing of the original words is almost entirely disregarded.</item></list><list type="ul"><item>Recommended: if any word already has a conventional camel-case appearance in common usage, split this into its constituent parts (e.g., "AdWords" becomes "ad words"). Note that a word such as "iOS" is not really in camel case per se; it defies any convention, so this recommendation does not apply.</item></list><list type="ul"><item>... each word, to yield upper camel case, or</item><item>... each word except the first, to yield lower camel case</item></list><paragraph>In very rare circumstances (for example, multipart version numbers), you may need to use underscores to separate adjacent numbers, since numbers do not have upper and lower case variants.</paragraph><paragraph>Examples:</paragraph><table><thead><tr><th>Prose form</th><th>Correct</th><th>Incorrect</th></tr></thead><tbody><tr><td>"XML HTTP request"</td><td>XmlHttpRequest</td><td>XMLHTTPRequest</td></tr><tr><td>"new customer ID"</td><td>newCustomerId</td><td>newCustomerID</td></tr><tr><td>"inner stopwatch"</td><td>innerStopwatch</td><td>innerStopWatch</td></tr><tr><td>"supports IPv6 on iOS?"</td><td>supportsIpv6OnIos</td><td>supportsIPv6OnIOS</td></tr><tr><td>"YouTube importer"</td><td>YouTubeImporter YoutubeImporter*</td><td></td></tr><tr><td>"Turn on 2SV"</td><td>turnOn2sv</td><td>turnOn2Sv</td></tr><tr><td>"Guava 33.4.6"</td><td>guava33_4_6</td><td>guava3346</td></tr></tbody></table><paragraph>*Acceptable, but not recommended.</paragraph><paragraph>Note: Some words are ambiguously hyphenated in the English language: for example "nonempty" and "non-empty" are both correct, so the method names checkNonempty and checkNonEmpty are likewise both correct.</paragraph><heading level="2">6 Programming Practices</heading><heading level="3">6.1 @Override: always used</heading><paragraph>A method is marked with the @Override annotation whenever it is legal. This includes a class method overriding a superclass method, a class method implementing an interface method, an interface method respecifying a superinterface method, and an explicitly declared accessor method for a record component.</paragraph><paragraph>Exception: @Override may be omitted when the parent method is @Deprecated.</paragraph><heading level="3">6.2 Caught exceptions: not ignored</heading><paragraph>It is very rarely correct to do nothing in response to a caught exception. (Typical responses are to log it, or if it is considered "impossible", rethrow it as an AssertionError.)</paragraph><paragraph>When it truly is appropriate to take no action whatsoever in a catch block, the reason this is justified is explained in a comment.</paragraph><code language="javascript">try {
  int i = Integer.parseInt(response);
  return handleNumericResponse(i);
} catch (NumberFormatException ok) {
  // it's not numeric; that's fine, just continue
}
return handleTextResponse(response);
</code><heading level="3">6.3 Static members: qualified using class</heading><paragraph>When a reference to a static class member must be qualified, it is qualified with that class's name, not with a reference or expression of that class's type.</paragraph><code language="code">Foo aFoo = ...;
Foo.aStaticMethod(); // good
aFoo.aStaticMethod(); // bad
somethingThatYieldsAFoo().aStaticMethod(); // very bad
</code><heading level="3">6.4 Finalizers: not used</heading><paragraph>Do not override Object.finalize. Finalization support is scheduled for removal.</paragraph><heading level="2">7 Javadoc</heading><heading level="3">7.1 Formatting</heading><heading level="4">7.1.1 General form</heading><paragraph>The basic formatting of Javadoc blocks is as seen in this example:</paragraph><code language="code">/**
 * Multiple lines of Javadoc text are written here,
 * wrapped normally...
 */
public int method(String p1) { ... }
</code><paragraph>... or in this single-line example:</paragraph><code language="code">/** An especially short bit of Javadoc. */
</code><paragraph>The basic form is always acceptable. The single-line form may be substituted when the entirety of the Javadoc block (including comment markers) can fit on a single line. Note that this only applies when there are no block tags such as @param.</paragraph><heading level="4">7.1.2 Paragraphs</heading><paragraph>One blank line—that is, a line containing only the aligned leading asterisk (*)—appears between paragraphs, and before the group of block tags if present. Each paragraph except the first has <p> immediately before the first word, with no space after it. HTML tags for other block-level elements, such as <ul> or <table>, are not preceded with <p>.</paragraph><paragraph>Any of the standard "block tags" that are used appear in the order @param, @return, @throws, @deprecated, and these four types never appear with an empty description. When a block tag doesn't fit on a single line, continuation lines are indented four (or more) spaces from the position of the @.</paragraph><heading level="3">7.2 The summary fragment</heading><paragraph>Each Javadoc block begins with a brief summary fragment. This fragment is very important: it is the only part of the text that appears in certain contexts such as class and method indexes.</paragraph><paragraph>This is a fragment—a noun phrase or verb phrase, not a complete sentence. It does not begin with A {@code Foo} is a..., or This method returns..., nor does it form a complete imperative sentence like Save the record.. However, the fragment is capitalized and punctuated as if it were a complete sentence.</paragraph><paragraph>Tip: A common mistake is to write simple Javadoc in the form /** @return the customer ID */. This is incorrect, and should be changed to /** Returns the customer ID. */ or /** {@return the customer ID} */.</paragraph><heading level="3">7.3 Where Javadoc is used</heading><paragraph>At the minimum, Javadoc is present for every visible class, member, or record component, with a few exceptions noted below. A top-level class is visible if it is public; a member is visible if it is public or protected and its containing class is visible; and a record component is visible if its containing record is visible.</paragraph><paragraph>Additional Javadoc content may also be present, as explained in Section 7.3.4, Non-required Javadoc.</paragraph><heading level="4">7.3.1 Exception: self-explanatory members</heading><paragraph>Javadoc is optional for "simple, obvious" members and record components, such as a getFoo() method, if there really and truly is nothing else worthwhile to say but "the foo".</paragraph><paragraph>Important: it is not appropriate to cite this exception to justify omitting relevant information that a typical reader might need to know. For example, for a record component named canonicalName, don't omit its documentation (with the rationale that it would say only @param canonicalName the canonical name) if a typical reader may have no idea what the term "canonical name" means!</paragraph><heading level="4">7.3.2 Exception: overrides</heading><paragraph>Javadoc is not always present on a method that overrides a supertype method.</paragraph><heading level="4">7.3.4 Non-required Javadoc</heading><paragraph>Other classes, members, and record components have Javadoc as needed or desired.</paragraph><paragraph>Whenever an implementation comment would be used to define the overall purpose or behavior of a class or member, that comment is written as Javadoc instead (using /**).</paragraph><paragraph>Non-required Javadoc is not strictly required to follow the formatting rules of Sections 7.1.1, 7.1.2, 7.1.3, and 7.2, though it is of course recommended.</paragraph></content>
</page>
<page url="https://google.github.io/styleguide/docguide/style.html">
<title>Markdown style guide | styleguide</title>
<content><heading level="1">Markdown style guide</heading><paragraph>Much of what makes Markdown refreshing is the ability to write plain text and get great formatted output as a result. To keep the slate clean for the next author, your Markdown should be simple and consistent with the whole corpus wherever possible.</paragraph><paragraph>We seek to balance three goals:</paragraph><list type="ol"><item>Source text is readable and portable.</item><item>The Markdown corpus is maintainable over time and across teams.</item><item>The syntax is simple and easy to remember.</item></list><paragraph>Contents:</paragraph><list type="ol"><item>Minimum viable documentation</item><item>Better is better than best</item><item>Capitalization</item><item>Document layout</item><item>Table of contents</item><item>Character line limit</item><item>Trailing whitespace</item><item>Headings ATX-style headings Use unique, complete names for headings Add spacing to headings Use a single H1 heading Capitalization of titles and headers</item><item>Lists Use lazy numbering for long lists Nested list spacing</item><item>Code Inline Use code span for escaping Codeblocks Declare the language Escape newlines Use fenced code blocks instead of indented code blocks Nest codeblocks within lists</item><item>Links Use explicit paths for links within Markdown Avoid relative paths unless within the same directory Use informative Markdown link titles Reference links Use reference links for long links Use reference links to reduce duplication Define reference links after their first use</item><item>Images</item><item>Tables</item><item>Strongly prefer Markdown to HTML</item></list><list type="ol"><item>ATX-style headings</item><item>Use unique, complete names for headings</item><item>Add spacing to headings</item><item>Use a single H1 heading</item><item>Capitalization of titles and headers</item></list><list type="ol"><item>Use lazy numbering for long lists</item><item>Nested list spacing</item></list><list type="ol"><item>Inline</item><item>Use code span for escaping</item><item>Codeblocks Declare the language Escape newlines Use fenced code blocks instead of indented code blocks Nest codeblocks within lists</item></list><list type="ol"><item>Declare the language</item><item>Escape newlines</item><item>Use fenced code blocks instead of indented code blocks</item><item>Nest codeblocks within lists</item></list><list type="ol"><item>Use explicit paths for links within Markdown</item><item>Avoid relative paths unless within the same directory</item><item>Use informative Markdown link titles</item><item>Reference links Use reference links for long links Use reference links to reduce duplication Define reference links after their first use</item></list><list type="ol"><item>Use reference links for long links</item><item>Use reference links to reduce duplication</item><item>Define reference links after their first use</item></list><heading level="2">Minimum viable documentation</heading><paragraph>A small set of fresh and accurate docs is better than a sprawling, loose assembly of "documentation" in various states of disrepair.</paragraph><paragraph>The Markdown way encourages engineers to take ownership of their docs and keep them up to date with the same zeal we keep our tests in good order. Strive for this.</paragraph><list type="ul"><item>Identify what you really need: release docs, API docs, testing guidelines.</item><item>Delete cruft frequently and in small batches.</item></list><heading level="2">Better is better than best</heading><paragraph>The standards for an internal documentation review are different from the standards for code reviews. Reviewers should ask for improvements, but in general, the author should always be able to invoke the "Better/Best Rule."</paragraph><paragraph>Fast iteration is your friend. To get long-term improvement, authors must stay productive when making short-term improvements. Set lower standards for each CL, so that more such CLs can happen.</paragraph><paragraph>As a reviewer of a documentation CL:</paragraph><list type="ol"><item>When reasonable, LGTM immediately and trust that comments will be fixed appropriately.</item><item>Prefer to suggest an alternative rather than leaving a vague comment.</item><item>For substantial changes, start your own follow-up CL instead. Especially try to avoid comments of the form "You should also…".</item><item>On rare occasions, hold up submission if the CL actually makes the docs worse. It's okay to ask the author to revert.</item></list><paragraph>As an author:</paragraph><list type="ol"><item>Avoid wasting cycles with trivial argument. Capitulate early and move on.</item><item>Cite the Better/Best Rule as often as needed.</item></list><heading level="2">Capitalization</heading><paragraph>Use the original names of products, tools and binaries, preserving the capitalization. E.g.:</paragraph><code language="code"># Markdown style guide

`Markdown` is a dead-simple platform for internal engineering documentation.
</code><paragraph>and not</paragraph><code language="code"># markdown bad style guide example

`markdown` is a dead-simple platform for internal engineering documentation.
</code><heading level="2">Document layout</heading><paragraph>In general, documents benefit from some variation of the following layout:</paragraph><code language="code"># Document Title

Short introduction.

[TOC]

## Topic

Content.

## See also

* https://link-to-more-info
</code><list type="ol"><item># Document title: The first heading should be a level-one heading, ideally the same or nearly the same as the filename. The first level-one heading is used as the page <title>.</item><item>author: Optional. If you'd like to claim ownership of the document or if you are very proud of it, add yourself under the title. However, revision history generally suffices.</item><item>Short introduction. 1–3 sentences providing a high-level overview of the topic. Imagine yourself as a complete newbie who landed on your "Extending Foo" doc and doesn't know the most basic information you take for granted. "What is Foo? Why would I extend it?"</item><item>[TOC]: if you use hosting that supports table of contents, such as Gitiles, put [TOC] after the short introduction. See [TOC] documentation.</item><item>## Topic: The rest of your headings should start from level 2.</item><item>## See also: Put miscellaneous links at the bottom for the user who wants to know more or didn't find what they needed.</item></list><paragraph># Document title: The first heading should be a level-one heading, ideally the same or nearly the same as the filename. The first level-one heading is used as the page <title>.</paragraph><paragraph>author: Optional. If you'd like to claim ownership of the document or if you are very proud of it, add yourself under the title. However, revision history generally suffices.</paragraph><paragraph>Short introduction. 1–3 sentences providing a high-level overview of the topic. Imagine yourself as a complete newbie who landed on your "Extending Foo" doc and doesn't know the most basic information you take for granted. "What is Foo? Why would I extend it?"</paragraph><paragraph>[TOC]: if you use hosting that supports table of contents, such as Gitiles, put [TOC] after the short introduction. See [TOC] documentation.</paragraph><paragraph>## Topic: The rest of your headings should start from level 2.</paragraph><paragraph>## See also: Put miscellaneous links at the bottom for the user who wants to know more or didn't find what they needed.</paragraph><heading level="2">Table of contents</heading><heading level="3">Use a [TOC] directive</heading><paragraph>Use a [TOC] directive unless all of your content is above the fold on a laptop.</paragraph><heading level="3">Place the [TOC] directive after the introduction</heading><paragraph>Place the [TOC] directive after your page's introduction and before the first H2 heading. For example:</paragraph><code language="code"># My Page

This is my introduction **before** the TOC.

[TOC]

## My first H2
</code><code language="code"># My Page

[TOC]

This is my introduction **after** the TOC where it should not be.

## My first H2
</code><paragraph>For users who read your documentation visually, it doesn't matter where your [TOC] directive is placed, as Markdown always displays the TOC toward the top and to the right of the page. However, [TOC] placement matters a lot when screen readers or keyboard controls are involved.</paragraph><paragraph>That's because [TOC] inserts the HTML for the table of contents into the DOM wherever you've included the directive in your Markdown file. If, for example, you place the directive at the very bottom of your file, screen readers won't read it until they get to the end of the document.</paragraph><heading level="2">Character line limit</heading><paragraph>Markdown content follows the residual convention of an 80-character line limit. Why? Because it's what most of us do for code.</paragraph><list type="ul"><item>Tooling integration: All our tooling is designed around code, so the more our documents are formatted according to similar rules, the better these tools will work. For example, Code Search doesn't soft wrap.</item><item>Quality. The more engineers use their well-worn coding habits when creating and editing Markdown content, the better the quality. Markdown takes advantage of the excellent review culture we already have.</item></list><paragraph>Tooling integration: All our tooling is designed around code, so the more our documents are formatted according to similar rules, the better these tools will work. For example, Code Search doesn't soft wrap.</paragraph><paragraph>Quality. The more engineers use their well-worn coding habits when creating and editing Markdown content, the better the quality. Markdown takes advantage of the excellent review culture we already have.</paragraph><heading level="3">Exceptions</heading><paragraph>Exceptions to the 80-character rule include:</paragraph><list type="ul"><item>Links</item><item>Tables</item><item>Headings</item><item>Code blocks</item></list><paragraph>This means that lines with links are allowed to extend past column 80, along with any relevant punctuation:</paragraph><code language="code">*   See the
    [foo docs](https://gerrit.googlesource.com/gitiles/+/HEAD/Documentation/markdown.md).
    and find the logfile.
</code><paragraph>However, note that text before and after the link gets wrapped.</paragraph><paragraph>Tables may also run long. However, there are best practices for creating short, readable tables.</paragraph><code language="code">Foo                                                                           | Bar | Baz
----------------------------------------------------------------------------- | --- | ---
Somehow-unavoidable-long-cell-filled-with-content-that-simply-refuses-to-wrap | Foo | Bar
</code><heading level="2">Trailing whitespace</heading><paragraph>Don't use trailing whitespace. Use a trailing backslash to break lines.</paragraph><paragraph>The CommonMark spec decrees that two spaces at the end of a line should insert a <br /> tag. However, many directories have a presubmit check for trailing whitespace, and many IDEs will clean it up anyway.</paragraph><paragraph>Use a trailing backslash, sparingly:</paragraph><code language="code">For some reason I just really want a break here,\
though it's probably not necessary.
</code><paragraph>Best practice is to avoid the need for a <br /> altogether. A pair of newlines will create a paragraph tag; get used to that.</paragraph><heading level="2">Headings</heading><heading level="3">ATX-style headings</heading><paragraph>Headings with = or - underlines can be annoying to maintain and don't fit with the rest of the heading syntax. An editor has to ask: Does --- mean H1 or H2?</paragraph><code language="code">Heading - do you remember what level? DO NOT DO THIS.
---------
</code><heading level="3">Use unique, complete names for headings</heading><paragraph>Use unique and fully descriptive names for each heading, even for sub-sections. Since link anchors are constructed from headings, this helps ensure that the automatically-constructed anchor links are intuitive and clear.</paragraph><paragraph>For example, instead of:</paragraph><code language="code">## Foo
### Summary
### Example
## Bar
### Summary
### Example
</code><paragraph>prefer:</paragraph><code language="code">## Foo
### Foo summary
### Foo example
## Bar
### Bar summary
### Bar example
</code><heading level="3">Add spacing to headings</heading><paragraph>Prefer spacing after # and newlines before and after:</paragraph><code language="code">...text before.

## Heading 2

Text after...
</code><paragraph>Lack of spacing makes it a little harder to read in source:</paragraph><code language="code">...text before.

##Heading 2
Text after... DO NOT DO THIS.
</code><heading level="3">Use a single H1 heading</heading><paragraph>Use one H1 heading as the title of your document. Subsequent headings should be H2 or deeper. See Document layout for more information.</paragraph><heading level="3">Capitalization of titles and headers</heading><paragraph>Follow the guidance for capitalization in the Google Developer Documentation Style Guide.</paragraph><heading level="2">Lists</heading><heading level="3">Use lazy numbering for long lists</heading><paragraph>Markdown is smart enough to let the resulting HTML render your numbered lists correctly. For longer lists that may change, especially long nested lists, use "lazy" numbering:</paragraph><code language="code">1.  Foo.
1.  Bar.
    1.  Foofoo.
    1.  Barbar.
1.  Baz.
</code><paragraph>However, if the list is small and you don't anticipate changing it, prefer fully numbered lists, because it's nicer to read in source:</paragraph><heading level="3">Nested list spacing</heading><paragraph>When nesting lists, use a 4-space indent for both numbered and bulleted lists:</paragraph><code language="code">1.  Use 2 spaces after the item number, so the text itself is indented 4 spaces.
    Use a 4-space indent for wrapped text.
2.  Use 2 spaces again for the next item.

*   Use 3 spaces after a bullet, so the text itself is indented 4 spaces.
    Use a 4-space indent for wrapped text.
    1.  Use 2 spaces with numbered lists, as before.
        Wrapped text in a nested list needs an 8-space indent.
    2.  Looks nice, doesn't it?
*   Back to the bulleted list, indented 3 spaces.
</code><paragraph>The following works, but it's very messy:</paragraph><code language="code">* One space,
with no indent for wrapped text.
     1. Irregular nesting... DO NOT DO THIS.
</code><paragraph>Even when there's no nesting, using the 4 space indent makes layout consistent for wrapped text:</paragraph><code language="code">*   Foo,
    wrapped with a 4-space indent.

1.  Two spaces for the list item
    and 4 spaces before wrapped text.
2.  Back to 2 spaces.
</code><paragraph>However, when lists are small, not nested, and a single line, one space can suffice for both kinds of lists:</paragraph><code language="code">* Foo
* Bar
* Baz.

1. Foo.
2. Bar.
</code><heading level="2">Code</heading><heading level="3">Inline</heading><paragraph>`Backticks` designate inline code that will be rendered literally. Use them for short code quotations, field names, and more:</paragraph><code language="code">You'll want to run `really_cool_script.sh arg`.

Pay attention to the `foo_bar_whammy` field in that table.
</code><paragraph>Use inline code when referring to file types in a generic sense, rather than a specific existing file:</paragraph><code language="code">Be sure to update your `README.md`!
</code><heading level="3">Use code span for escaping</heading><paragraph>When you don't want text to be processed as normal Markdown, like a fake path or example URL that would lead to a bad autolink, wrap it in backticks:</paragraph><code language="code">An example Markdown shortlink would be: `Markdown/foo/Markdown/bar.md`

An example query might be: `https://www.google.com/search?q=$TERM`
</code><heading level="3">Codeblocks</heading><paragraph>For code quotations longer than a single line, use a fenced code block:</paragraph><code language="python">
```python
def Foo(self, bar):
  self.bar = bar
```
</code><heading level="4">Declare the language</heading><paragraph>It is best practice to explicitly declare the language, so that neither the syntax highlighter nor the next editor must guess.</paragraph><heading level="4">Use fenced code blocks instead of indented code blocks</heading><paragraph>Four-space indenting is also interpreted as a code block. However, we strongly recommend fencing for all code blocks.</paragraph><paragraph>Indented code blocks can sometimes look cleaner in the source, but they have several drawbacks:</paragraph><list type="ul"><item>You cannot specify the language. Some Markdown features are tied to language specifiers.</item><item>The beginning and end of the code block are ambiguous.</item><item>Indented code blocks are harder to search for in Code Search.</item></list><code language="code">You'll need to run:

    bazel run :thing -- --foo

And then:

    bazel run :another_thing -- --bar

And again:

    bazel run :yet_again -- --baz
</code><heading level="4">Escape newlines</heading><paragraph>Because most command-line snippets are intended to be copied and pasted directly into a terminal, it's best practice to escape any newlines. Use a single backslash at the end of the line:</paragraph><code language="code">
```shell
$ bazel run :target -- --flag --foo=longlonglonglonglongvalue \
  --bar=anotherlonglonglonglonglonglonglonglonglonglongvalue
```
</code><heading level="4">Nest codeblocks within lists</heading><paragraph>If you need a code block within a list, make sure to indent it so as to not break the list:</paragraph><code language="code">*   Bullet.

    ```c++
    int foo;
    ```

*   Next bullet.
</code><paragraph>You can also create a nested code block with 4 spaces. Simply indent 4 additional spaces from the list indentation:</paragraph><code language="code">*   Bullet.

        int foo;

*   Next bullet.
</code><heading level="2">Links</heading><paragraph>Long links make source Markdown difficult to read and break the 80 character wrapping. Wherever possible, shorten your links.</paragraph><heading level="3">Use explicit paths for links within Markdown</heading><paragraph>Use the explicit path for Markdown links. For example:</paragraph><code language="code">[...](/path/to/other/markdown/page.md)
</code><paragraph>You don't need to use the entire qualified URL:</paragraph><code language="code">[...](https://bad-full-url.example.com/path/to/other/markdown/page.md)
</code><heading level="3">Avoid relative paths unless within the same directory</heading><paragraph>Relative paths are fairly safe within the same directory. For example:</paragraph><code language="code">[...](other-page-in-same-dir.md)
[...](/path/to/another/dir/other-page.md)
</code><paragraph>Avoid relative links if you need to specify other directories with ../:</paragraph><code language="code">[...](../../bad/path/to/another/dir/other-page.md)
</code><heading level="3">Use informative Markdown link titles</heading><paragraph>Markdown link syntax allows you to set a link title. Use it wisely. Users often do not read documents; they scan them.</paragraph><paragraph>Links catch the eye. But titling your links "here," "link," or simply duplicating the target URL tells the hasty reader precisely nothing and is a waste of space:</paragraph><code language="code">DO NOT DO THIS.

See the Markdown guide for more info: [link](markdown.md), or check out the
style guide [here](/styleguide/docguide/style.html).

Check out a typical test result:
[https://example.com/foo/bar](https://example.com/foo/bar).
</code><paragraph>Instead, write the sentence naturally, then go back and wrap the most appropriate phrase with the link:</paragraph><code language="code">See the [Markdown guide](markdown.md) for more info, or check out the
[style guide](/styleguide/docguide/style.html).

Check out a
[typical test result](https://example.com/foo/bar).
</code><heading level="3">Reference</heading><paragraph>For long links or image URLs, you may want to split the link use from the link definition, like this:</paragraph><code language="code">See the [Markdown style guide][style], which has suggestions for making docs more
readable.

﻿[style]: http://Markdown/corp/Markdown/docs/reference/style.md
</code><heading level="4">Use reference links for long links</heading><paragraph>Use reference links where the length of the link would detract from the readability of the surrounding text if it were inlined. Reference links make it harder to see the destination of a link in source text, and add additional syntax.</paragraph><paragraph>In this example, reference link usage is not appropriate, because the link is not long enough to disrupt the flow of the text:</paragraph><code language="code">DO NOT DO THIS.

The [style guide][style_guide] says not to use reference links unless you have
to.

﻿[style_guide]: https://google.com/Markdown-style
</code><paragraph>Just inline it instead:</paragraph><code language="code">https://google.com/Markdown-style says not to use reference links unless you have to.
</code><paragraph>In this example, the link destination is long enough that it makes sense to use a reference link:</paragraph><code language="code">The [style guide] says not to use reference links unless you have to.

﻿[style guide]: https://docs.google.com/document/d/13HQBxfhCwx8lVRuN2Wf6poqvAfVeEXmFVcawP5I6B3c/edit
</code><paragraph>Use reference links more often in tables. It is particularly important to keep table content short, since Markdown does not provide a facility to break text in cell tables across multiple lines, and smaller tables are more readable.</paragraph><paragraph>For example, this table's readability is worsened by inline links:</paragraph><code language="code">DO NOT DO THIS.

Site                                                             | Description
---------------------------------------------------------------- | -----------------------
[site 1](http://google.com/excessively/long/path/example_site_1) | This is example site 1.
[site 2](http://google.com/excessively/long/path/example_site_2) | This is example site 2.
</code><paragraph>Instead, use reference links to keep the line length manageable:</paragraph><code language="code">Site     | Description
-------- | -----------------------
[site 1] | This is example site 1.
[site 2] | This is example site 2.

﻿[site 1]: http://google.com/excessively/long/path/example_site_1
﻿[site 2]: http://google.com/excessively/long/path/example_site_2
</code><heading level="4">Use reference links to reduce duplication</heading><paragraph>Consider using reference links when referencing the same link destination multiple times in a document, to reduce duplication.</paragraph><heading level="4">Define reference links after their first use</heading><paragraph>We recommend putting reference link definitions just before the next heading, at the end of the section in which they're first used. If your editor has its own opinion about where they should go, don't fight it; the tools always win.</paragraph><paragraph>We define a "section" as all text between two headings. Think of reference links like footnotes, and the current section like the current page.</paragraph><paragraph>This arrangement makes it easy to find the link destination in source view, while keeping the flow of text free from clutter. In long documents with lots of reference links, it also prevents "footnote overload" at the bottom of the file, which makes it difficult to pick out the relevant link destination.</paragraph><paragraph>There is one exception to this rule: reference link definitions that are used in multiple sections should go at the end of the document. This avoids dangling links when a section is updated or moved.</paragraph><paragraph>In the following example, the reference definition is far from its initial use, which makes the document harder to read:</paragraph><code language="code"># Header FOR A BAD DOCUMENT

Some text with a [link][link_def].

Some more text with the same [link][link_def].

## Header 2

... lots of text ...

## Header 3

Some more text using a [different_link][different_link_def].

﻿[link_def]: http://reallyreallyreallylonglink.com
﻿[different_link_def]: http://differentreallyreallylonglink.com
</code><paragraph>Instead, put it just before the header following its first use:</paragraph><code language="code"># Header

Some text with a [link][link_def].

Some more text with the same [link][link_def].

﻿[link_def]: http://reallyreallyreallylonglink.com

## Header 2

... lots of text ...

## Header 3

Some more text using a [different_link][different_link_def].

﻿[different_link_def]: http://differentreallyreallylonglink.com
</code><heading level="2">Images</heading><paragraph>See image syntax.</paragraph><paragraph>Use images sparingly, and prefer simple screenshots. This guide is designed around the idea that plain text gets users down to the business of communication faster with less reader distraction and author procrastination. However, it's sometimes very helpful to show what you mean.</paragraph><list type="ul"><item>Use images when it's easier to show a reader something than to describe it. For example, explaining how to navigate a UI is often easier with an image than text.</item><item>Make sure to provide appropriate text to describe your image. Readers who are not sighted cannot see your image and still need to understand the content! See the alt text best practices below.</item></list><heading level="2">Tables</heading><paragraph>Use tables when they make sense: for the presentation of tabular data that needs to be scanned quickly.</paragraph><paragraph>Avoid using tables when your data could easily be presented in a list. Lists are much easier to write and read in Markdown.</paragraph><paragraph>For example:</paragraph><code language="code">DO NOT DO THIS

Fruit  | Metrics      | Grows on | Acute curvature    | Attributes                                                                                                  | Notes
------ | ------------ | -------- | ------------------ | ----------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------
Apple  | Very popular | Trees    |                    | [Juicy](http://cs/SomeReallyReallyReallyReallyReallyReallyReallyReallyLongQuery), Firm, Sweet               | Apples keep doctors away.
Banana | Very popular | Trees    | 16 degrees average | [Convenient](http://cs/SomeDifferentReallyReallyReallyReallyReallyReallyReallyReallyLongQuery), Soft, Sweet | Contrary to popular belief, most apes prefer mangoes. Don't you? See the [design doc][banana_v2] for the newest hotness in bananiels.
</code><paragraph>This table illustrates a few typical problems:</paragraph><list type="ul"><item>Poor distribution: Several columns don't differ across rows, and some cells are empty. This is usually a sign that your data may not benefit from tabular display.</item><item>Unbalanced dimensions: There are a small number of rows relative to columns. When this ratio is unbalanced in either direction, a table becomes little more than an inflexible format for text.</item><item>Rambling prose in some cells. Tables should tell a succinct story at a glance.</item></list><paragraph>Poor distribution: Several columns don't differ across rows, and some cells are empty. This is usually a sign that your data may not benefit from tabular display.</paragraph><paragraph>Unbalanced dimensions: There are a small number of rows relative to columns. When this ratio is unbalanced in either direction, a table becomes little more than an inflexible format for text.</paragraph><paragraph>Rambling prose in some cells. Tables should tell a succinct story at a glance.</paragraph><paragraph>Lists and subheadings sometimes suffice to present the same information. Let's see this data in list form:</paragraph><code language="code">## Fruits

Both types are highly popular, sweet, and grow on trees.

### Apple

*   [Juicy](http://SomeReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyReallyLongURL)
*   Firm

Apples keep doctors away.

### Banana

*   [Convenient](http://cs/SomeDifferentReallyReallyReallyReallyReallyReallyReallyReallyLongQuery)
*   Soft
*   16 degrees average acute curvature.

Contrary to popular belief, most apes prefer mangoes. Don't you?

See the [design doc][banana_v2] for the newest hotness in bananiels.
</code><paragraph>The list form is more spacious, and arguably therefore much easier for the reader to find what interests her in this case.</paragraph><paragraph>However, there are times a table is the best choice. When you have:</paragraph><list type="ul"><item>Relatively uniform data distribution across two dimensions.</item><item>Many parallel items with distinct attributes.</item></list><paragraph>In those cases, a table format is just the thing. In fact, a compact table can improve readability:</paragraph><code language="code">Transport        | Favored by     | Advantages
---------------- | -------------- | -----------------------------------------------
Swallow          | Coconuts       | [Fast when unladen][airspeed]
Bicycle          | Miss Gulch     | [Weatherproof][tornado_proofing]
X-34 landspeeder | Whiny farmboys | [Cheap][tosche_station] since the XP-38 came out

﻿[airspeed]: http://google3/airspeed.h
﻿[tornado_proofing]: http://google3/kansas/
﻿[tosche_station]: http://google3/power_converter.h
</code><paragraph>Note that reference links are used to keep the table cells manageable.</paragraph><heading level="2">Strongly prefer Markdown to HTML</heading><paragraph>Please prefer standard Markdown syntax wherever possible and avoid HTML hacks. If you can't seem to accomplish what you want, reconsider whether you really need it. Except for big tables, Markdown meets almost all needs already.</paragraph><paragraph>Every bit of HTML hacking reduces the readability and portability of our Markdown corpus. This in turn limits the usefulness of integrations with other tools, which may either present the source as plain text or render it. See Philosophy.</paragraph><paragraph>Gitiles does not render HTML.</paragraph></content>
</page>
<page url="https://google.github.io/styleguide/objcguide.html">
<title>Google Objective-C Style Guide | styleguide</title>
<content><heading level="1">Google Objective-C Style Guide</heading><paragraph>Objective-C is a dynamic, object-oriented extension of C. It's designed to be easy to use and read, while enabling sophisticated object-oriented design. It is one of the primary development languages for applications on Apple platforms.</paragraph><paragraph>Apple has already written a very good, and widely accepted, Cocoa Coding Guidelines for Objective-C. Please read it in addition to this guide.</paragraph><paragraph>The purpose of this document is to describe the Objective-C (and Objective-C++) coding guidelines and practices. These guidelines have evolved and been proven over time on other projects and teams. Open-source projects developed by Google conform to the requirements in this guide.</paragraph><paragraph>Note that this guide is not an Objective-C tutorial. We assume that the reader is familiar with the language. If you are new to Objective-C or need a refresher, please read Programming with Objective-C.</paragraph><heading level="2">Principles</heading><heading level="3">Optimize for the reader, not the writer</heading><paragraph>Codebases often have extended lifetimes and more time is spent reading the code than writing it. We explicitly choose to optimize for the experience of our average software engineer reading, maintaining, and debugging code in our codebase rather than the ease of writing said code. For example, when something surprising or unusual is happening in a snippet of code, leaving textual hints for the reader is valuable.</paragraph><heading level="3">Be consistent</heading><paragraph>When the style guide allows multiple options it is preferable to pick one option over mixed usage of multiple options. Using one style consistently throughout a codebase lets engineers focus on other (more important) issues. Consistency also enables better automation because consistent code allows more efficient development and operation of tools that format or refactor code. In many cases, rules that are attributed to "Be Consistent" boil down to "Just pick one and stop worrying about it"; the potential value of allowing flexibility on these points is outweighed by the cost of having people argue over them.</paragraph><heading level="3">Be consistent with Apple SDKs</heading><paragraph>Consistency with the way Apple SDKs use Objective-C has value for the same reasons as consistency within our code base. If an Objective-C feature solves a problem that's an argument for using it. However, sometimes language features and idioms are flawed, or were just designed with assumptions that are not universal. In those cases it is appropriate to constrain or ban language features or idioms.</paragraph><heading level="3">Style rules should pull their weight</heading><paragraph>The benefit of a style rule must be large enough to justify asking engineers to remember it. The benefit is measured relative to the codebase we would get without the rule, so a rule against a very harmful practice may still have a small benefit if people are unlikely to do it anyway. This principle mostly explains the rules we don't have, rather than the rules we do: for example, goto contravenes many of the following principles, but is not discussed due to its extreme rarity.</paragraph><heading level="2">Example</heading><paragraph>They say an example is worth a thousand words, so let's start off with an example that should give you a feel for the style, spacing, naming, and so on.</paragraph><paragraph>Here is an example header file, demonstrating the correct commenting and spacing for an @interface declaration.</paragraph><code language="code">// GOOD:

#import <Foundation/Foundation.h>

@class Bar;

/**
 * A sample class demonstrating good Objective-C style. All interfaces,
 * categories, and protocols (read: all non-trivial top-level declarations
 * in a header) MUST be commented. Comments must also be adjacent to the
 * object they're documenting.
 */
@interface Foo : NSObject

/** The retained Bar. */
@property(nonatomic) Bar *bar;

/** The current drawing attributes. */
@property(nonatomic, copy) NSDictionary<NSString *, NSNumber *> *attributes;

/**
 * Convenience creation method.
 * See -initWithBar: for details about @c bar.
 *
 * @param bar The string for fooing.
 * @return An instance of Foo.
 */
+ (instancetype)fooWithBar:(Bar *)bar;

/**
 * Initializes and returns a Foo object using the provided Bar instance.
 *
 * @param bar A string that represents a thing that does a thing.
 */
- (instancetype)initWithBar:(Bar *)bar NS_DESIGNATED_INITIALIZER;

/**
 * Does some work with @c blah.
 *
 * @param blah
 * @return YES if the work was completed; NO otherwise.
 */
- (BOOL)doWorkWithBlah:(NSString *)blah;

@end
</code><paragraph>An example source file, demonstrating the correct commenting and spacing for the @implementation of an interface.</paragraph><code language="javascript">// GOOD:

#import "Shared/Util/Foo.h"

@implementation Foo {
  /** The string used for displaying "hi". */
  NSString *_string;
}

+ (instancetype)fooWithBar:(Bar *)bar {
  return [[self alloc] initWithBar:bar];
}

- (instancetype)init {
  // Classes with a custom designated initializer should always override
  // the superclass's designated initializer.
  return [self initWithBar:nil];
}

- (instancetype)initWithBar:(Bar *)bar {
  self = [super init];
  if (self) {
    _bar = [bar copy];
    _string = [[NSString alloc] initWithFormat:@"hi %d", 3];
    _attributes = @{
      @"color" : UIColor.blueColor,
      @"hidden" : @NO
    };
  }
  return self;
}

- (BOOL)doWorkWithBlah:(NSString *)blah {
  // Work should be done here.
  return NO;
}

@end
</code><heading level="2">Naming</heading><paragraph>Names should be as descriptive as possible, within reason. Follow standard Objective-C naming rules.</paragraph><paragraph>Avoid non-standard abbreviations (including non-standard acronyms and initialisms). Don't worry about saving horizontal space as it is far more important to make your code immediately understandable by a new reader. For example:</paragraph><code language="code">// GOOD:

// Good names.
int numberOfErrors = 0;
int completedConnectionsCount = 0;
tickets = [[NSMutableArray alloc] init];
userInfo = [someObject object];
port = [network port];
NSDate *gAppLaunchDate;
</code><code language="code">// AVOID:

// Names to avoid.
int w;
int nerr;
int nCompConns;
tix = [[NSMutableArray alloc] init];
obj = [someObject object];
p = [network port];
</code><paragraph>Any class, category, method, function, or variable name should use all capitals for acronyms and initialisms within (including at the beginning of) the name. This follows Apple's standard of using all capitals within a name for acronyms such as URL, ID, TIFF, and EXIF.</paragraph><paragraph>Names of C functions and typedefs should be capitalized and use camel case as appropriate for the surrounding code.</paragraph><heading level="3">Inclusive Language</heading><paragraph>In all code, including naming and comments, use inclusive language and avoid terms that other programmers might find disrespectful or offensive (such as "master" and "slave", "blacklist" and "whitelist", or "redline"), even if the terms also have an ostensibly neutral meaning. Similarly, use gender-neutral language unless you're referring to a specific person (and using their pronouns). For example, use "they"/"them"/"their" for people of unspecified gender (even when singular), and "it"/"its" for non-people.</paragraph><heading level="3">File Names</heading><paragraph>File names should reflect the name of the class implementation that they contain—including case.</paragraph><paragraph>Follow the convention that your project uses.</paragraph><paragraph>File extensions should be as follows:</paragraph><table><thead><tr><th>Extension</th><th>Type</th></tr></thead><tbody><tr><td>.h</td><td>C/C++/Objective-C header file</td></tr><tr><td>.m</td><td>Objective-C implementation file</td></tr><tr><td>.mm</td><td>Objective-C++ implementation file</td></tr><tr><td>.cc</td><td>Pure C++ implementation file</td></tr><tr><td>.c</td><td>C implementation file</td></tr></tbody></table><paragraph>Files containing code that may be shared across projects or used in a large project should have a clearly unique name, typically including the project or class prefix.</paragraph><paragraph>File names for categories should include the name of the class being extended, like GTMNSString+Utils.h or NSTextView+GTMAutocomplete.h</paragraph><heading level="3">Prefixes</heading><paragraph>Prefixes are commonly required in Objective-C to avoid naming collisions in a global namespace. Classes, protocols, global functions, and global constants should generally be named with a prefix that begins with a capital letter followed by one or more capital letters or numbers.</paragraph><paragraph>WARNING: Apple reserves two-letter prefixes—see Conventions in Programming with Objective-C—so prefixes with a minimum of three characters are considered best practice.</paragraph><code language="code">// GOOD:

/** An example error domain. */
GTM_EXTERN NSString *GTMExampleErrorDomain;

/** Gets the default time zone. */
GTM_EXTERN NSTimeZone *GTMGetDefaultTimeZone(void);

/** An example delegate. */
@protocol GTMExampleDelegate <NSObject>
@end

/** An example class. */
@interface GTMExample : NSObject
@end

</code><heading level="3">Class Names</heading><paragraph>Class names (along with category and protocol names) should start as uppercase and use mixed case to delimit words.</paragraph><paragraph>Classes and protocols in code shared across multiple applications must have an appropriate prefix (e.g. GTMSendMessage). Prefixes are recommended, but not required, for other classes and protocols.</paragraph><heading level="3">Category Naming</heading><paragraph>Category names should start with an appropriate prefix identifying the category as part of a project or open for general use.</paragraph><paragraph>Category source file names should begin with the class being extended followed by a plus sign and the name of the category, e.g., NSString+GTMParsing.h. Methods in a category should be prefixed with a lowercase version of the prefix used for the category name followed by an underscore (e.g., gtm_myCategoryMethodOnAString:) in order to prevent collisions in Objective-C's global namespace.</paragraph><paragraph>There should be a single space between the class name and the opening parenthesis of the category.</paragraph><code language="code">// GOOD:

// UIViewController+GTMCrashReporting.h

/** A category that adds metadata to include in crash reports to UIViewController. */
@interface UIViewController (GTMCrashReporting)

/** A unique identifier to represent the view controller in crash reports. */
@property(nonatomic, setter=gtm_setUniqueIdentifier:) int gtm_uniqueIdentifier;

/** Returns an encoded representation of the view controller's current state. */
- (nullable NSData *)gtm_encodedState;

@end
</code><paragraph>If a class is not shared with other projects, categories extending it may omit name prefixes and method name prefixes.</paragraph><code language="code">// GOOD:

/** This category extends a class that is not shared with other projects. */
@interface XYZDataObject (Storage)
- (NSString *)storageIdentifier;
@end
</code><heading level="3">Objective-C Method Names</heading><paragraph>Method and parameter names typically start as lowercase and then use mixed case.</paragraph><paragraph>Proper capitalization should be respected, including at the beginning of names.</paragraph><code language="code">// GOOD:

+ (NSURL *)URLWithString:(NSString *)URLString;
</code><paragraph>The method name should read like a sentence if possible, meaning you should choose parameter names that flow with the method name. Objective-C method names tend to be very long, but this has the benefit that a block of code can almost read like prose, thus rendering many implementation comments unnecessary.</paragraph><paragraph>Use prepositions and conjunctions like "with", "from", and "to" in the second and later parameter names only where necessary to clarify the meaning or behavior of the method.</paragraph><code language="code">// GOOD:

- (void)addTarget:(id)target action:(SEL)action;                          // GOOD; no conjunction needed
- (CGPoint)convertPoint:(CGPoint)point fromView:(UIView *)view;           // GOOD; conjunction clarifies parameter
- (void)replaceCharactersInRange:(NSRange)aRange
            withAttributedString:(NSAttributedString *)attributedString;  // GOOD.
</code><paragraph>If the method returns an attribute of the receiver, name the method after the attribute.</paragraph><code language="code">// GOOD:

/** Returns this instance's sandwich. */
- (Sandwich *)sandwich;      // GOOD.

- (CGFloat)height;           // GOOD.

// GOOD; Returned value is not an attribute.
- (UIBackgroundTaskIdentifier)beginBackgroundTask;
</code><code language="code">// AVOID:

- (CGFloat)calculateHeight;  // AVOID.
- (id)theDelegate;           // AVOID.
</code><paragraph>An accessor method should be named the same as the object it's getting, but it should not be prefixed with the word get. For example:</paragraph><code language="code">// GOOD:

- (id)delegate;     // GOOD.
</code><code language="code">// AVOID:

- (id)getDelegate;  // AVOID.
</code><paragraph>Accessors that return the value of boolean adjectives have method names beginning with is, but property names for those methods omit the is.</paragraph><paragraph>Dot notation is used only with property names, not with method names.</paragraph><code language="code">// GOOD:

@property(nonatomic, getter=isGlorious) BOOL glorious;
// The method for the getter of the property above is:
// - (BOOL)isGlorious;

BOOL isGood = object.glorious;      // GOOD.
BOOL isGood = [object isGlorious];  // GOOD.
</code><code language="code">// AVOID:

BOOL isGood = object.isGlorious;    // AVOID.
</code><code language="code">// GOOD:

NSArray<Frog *> *frogs = [NSArray<Frog *> arrayWithObject:frog];
NSEnumerator *enumerator = [frogs reverseObjectEnumerator];  // GOOD.
</code><code language="code">// AVOID:

NSEnumerator *enumerator = frogs.reverseObjectEnumerator;    // AVOID.
</code><paragraph>See Apple's Guide to Naming Methods for more details on Objective-C naming.</paragraph><paragraph>These guidelines are for Objective-C methods only. C++ method names continue to follow the rules set in the C++ style guide.</paragraph><heading level="3">Function Names</heading><paragraph>Function names should start with a capital letter and have a capital letter for each new word (a.k.a. "camel case" or "Pascal case").</paragraph><code language="code">// GOOD:

static void AddTableEntry(NSString *tableEntry);
static BOOL DeleteFile(const char *filename);
</code><paragraph>Because Objective-C does not provide namespacing, non-static functions should have a prefix that minimizes the chance of a name collision.</paragraph><code language="code">// GOOD:

GTM_EXTERN NSTimeZone *GTMGetDefaultTimeZone(void);
GTM_EXTERN NSString *GTMGetURLScheme(NSURL *URL);
</code><heading level="3">Variable Names</heading><paragraph>Variable names typically start with a lowercase and use mixed case to delimit words.</paragraph><paragraph>Instance variables have leading underscores. File scope or global variables have a prefix g. For example: myLocalVariable, _myInstanceVariable, gMyGlobalVariable.</paragraph><heading level="4">Common Variable Names</heading><paragraph>Readers should be able to infer the variable type from the name, but do not use Hungarian notation for syntactic attributes, such as the static type of a variable (int or pointer).</paragraph><paragraph>File scope or global variables (as opposed to constants) declared outside the scope of a method or function should be rare, and should have the prefix g.</paragraph><code language="code">// GOOD:

static int gGlobalCounter;
</code><heading level="4">Instance Variables</heading><paragraph>Instance variable names are mixed case and should be prefixed with an underscore, like _usernameTextField.</paragraph><paragraph>NOTE: Google's previous convention for Objective-C ivars was a trailing underscore. Existing projects may opt to continue using trailing underscores in new code in order to maintain consistency within the project codebase. Consistency of prefix or suffix underscores should be maintained within each class.</paragraph><heading level="4">Constants</heading><paragraph>Constant symbols (const global and static variables and constants created with #define) should use mixed case to delimit words.</paragraph><paragraph>Global and file scope constants should have an appropriate prefix.</paragraph><code language="python">// GOOD:

/** The domain for GTL service errors. */
GTL_EXTERN NSString *const GTLServiceErrorDomain;

/** An enumeration of GTL service error codes. */
typedef NS_ENUM(int32_t, GTLServiceError) {
  /** An error code indicating that a query result was missing. */
  GTLServiceErrorQueryResultMissing = -3000,
  /** An error code indicating that the query timed out. */
  GTLServiceErrorQueryTimedOut      = -3001,
};
</code><paragraph>Because Objective-C does not provide namespacing, constants with external linkage should have a prefix that minimizes the chance of a name collision, typically like ClassNameConstantName or ClassNameEnumName.</paragraph><paragraph>For interoperability with Swift code, enumerated values should have names that extend the typedef name:</paragraph><code language="python">// GOOD:

/** An enumeration of supported display tinges. */
typedef NS_ENUM(int32_t, DisplayTinge) {
  DisplayTingeGreen = 1,
  DisplayTingeBlue = 2,
};
</code><paragraph>A lowercase k can be used as a standalone prefix for constants of static storage duration declared within implementation files:</paragraph><code language="code">// GOOD:

static const int kFileCount = 12;
static NSString *const kUserKey = @"kUserKey";
</code><paragraph>NOTE: Previous convention was for public constant names to begin with a lowercase k followed by a project-specific prefix. This practice is no longer recommended.</paragraph><heading level="2">Types and Declarations</heading><heading level="3">Method Declarations</heading><paragraph>As shown in the example, the recommended order for declarations in an @interface declaration are: properties, class methods, initializers, and then finally instance methods. The class methods section should begin with any convenience constructors.</paragraph><heading level="3">Local Variables</heading><paragraph>Declare variables in the narrowest practical scopes, and close to their use. Initialize variables in their declarations.</paragraph><code language="javascript">// GOOD:

CLLocation *location = [self lastKnownLocation];
for (int meters = 1; meters < 10; meters++) {
  reportFrogsWithinRadius(location, meters);
}
</code><paragraph>Occasionally, efficiency will make it more appropriate to declare a variable outside the scope of its use. This example declares meters separate from initialization, and needlessly sends the lastKnownLocation message each time through the loop:</paragraph><code language="javascript">// AVOID:

int meters;                                         // AVOID.
for (meters = 1; meters < 10; meters++) {
  CLLocation *location = [self lastKnownLocation];  // AVOID.
  reportFrogsWithinRadius(location, meters);
}
</code><paragraph>Under Automatic Reference Counting, strong and weak pointers to Objective-C objects are automatically initialized to nil, so explicit initialization to nil is not required for those common cases. However, automatic initialization does not occur for many Objective-C pointer types, including object pointers declared with the __unsafe_unretained ownership qualifier and CoreFoundation object pointer types. When in doubt, prefer to initialize all Objective-C local variables.</paragraph><heading level="3">Static Variables</heading><paragraph>When file scope variable/constant declarations in an implementation file do not need to be referenced outside that file, declare them static (or in an anonymous namespace in Objective-C++). Do not declare file scope variables or constants with static storage duration (or in anonymous namespaces in Objective-C++) in .h files.</paragraph><code language="code">// GOOD:

// file: Foo.m
static const int FOORequestLimit = 5;
</code><code language="code">// AVOID:

// file: Foo.h
static const int FOORequestLimit = 5;  // AVOID.
</code><heading level="3">Unsigned Integers</heading><paragraph>Avoid unsigned integers except when matching types used by system interfaces.</paragraph><paragraph>Subtle errors crop up when doing math or counting down to zero using unsigned integers. Rely only on signed integers in math expressions except when matching NSUInteger in system interfaces.</paragraph><code language="code">// GOOD:

NSUInteger numberOfObjects = array.count;
for (NSInteger counter = numberOfObjects - 1; counter >= 0; --counter)
</code><code language="code">// AVOID:

for (NSUInteger counter = numberOfObjects - 1; counter >= 0; --counter)  // AVOID.
</code><paragraph>Unsigned integers may be used for flags and bitmasks, though often NS_OPTIONS or NS_ENUM will be more appropriate.</paragraph><heading level="3">Types with Inconsistent Sizes</heading><paragraph>Be aware that types long, NSInteger, NSUInteger and CGFloat have sizes that differ in 32- and 64-bit builds. Their use is appropriate when matching system interfaces but should be avoided when dealing with APIs that require exact sizing, e.g., proto APIs.</paragraph><code language="code">// GOOD:

int32_t scalar1 = proto.intValue;

int64_t scalar2 = proto.longValue;

NSUInteger numberOfObjects = array.count;

CGFloat offset = view.bounds.origin.x;
</code><code language="code">// AVOID:

NSInteger scalar2 = proto.longValue;  // AVOID.
</code><paragraph>File and buffer sizes often exceed 32-bit limits, so they should be declared using int64_t, not with long, NSInteger, or NSUInteger.</paragraph><heading level="4">Floating Point Constants</heading><paragraph>When defining CGFloat constants, please keep in mind the following.</paragraph><paragraph>Previously for projects targeting 32-bit platforms, using float literals (numbers with the f suffix) could be necessary to avoid type-conversion warnings.</paragraph><paragraph>Since all Google iOS projects are now targeting only 64-bit runtime, CGFloat constants may omit the suffix (use double values). However, teams may choose to continue using float numbers for legacy code consistency, until they eventually migrate to double values everywhere. Avoid a mixture of float and double values in the same code.</paragraph><code language="code">// GOOD:

// Good since CGFloat is double
static const CGFloat kHorizontalMargin = 8.0;
static const CGFloat kVerticalMargin = 12.0;

// This is OK as long as all values for CGFloat constants in your project are float
static const CGFloat kHorizontalMargin = 8.0f;
static const CGFloat kVerticalMargin = 12.0f;
</code><code language="code">// AVOID:

// Avoid a mixture of float and double constants
static const CGFloat kHorizontalMargin = 8.0f;
static const CGFloat kVerticalMargin = 12.0;
</code><paragraph>Comments are absolutely vital to keeping our code readable. The following rules describe what you should comment and where. But remember: while comments are important, the best code is self-documenting. Giving sensible names to types and variables is much better than using obscure names and then trying to explain them through comments.</paragraph><paragraph>Pay attention to punctuation, spelling, and grammar; it is easier to read well-written comments than badly written ones.</paragraph><paragraph>Comments should be as readable as narrative text, with proper capitalization and punctuation. In many cases, complete sentences are more readable than sentence fragments. Shorter comments, such as comments at the end of a line of code, can sometimes be less formal, but use a consistent style.</paragraph><paragraph>When writing your comments, write for your audience: the next contributor who will need to understand your code. Be generous—the next one may be you!</paragraph><paragraph>A file may optionally start with a description of its contents.</paragraph><paragraph>Every file may contain the following items, in order</paragraph><list type="ul"><item>License boilerplate if necessary. Choose the appropriate boilerplate for the license used by the project.</item><item>A basic description of the contents of the file if necessary.</item></list><paragraph>If you make significant changes to a file with an author line, consider deleting the author line since revision history already provides a more detailed and accurate record of authorship.</paragraph><paragraph>Every non-trivial interface, public and private, should have an accompanying comment describing its purpose and how it fits into the larger picture.</paragraph><paragraph>Comments should be used to document classes, properties, ivars, functions, categories, protocol declarations, and enums.</paragraph><code language="javascript">// GOOD:

/**
 * A delegate for NSApplication to handle notifications about app
 * launch and shutdown. Owned by the main app controller.
 */
@interface MyAppDelegate : NSObject {
  /**
   * The background task in progress, if any. This is initialized
   * to the value UIBackgroundTaskInvalid.
   */
  UIBackgroundTaskIdentifier _backgroundTaskID;
}

/** The factory that creates and manages fetchers for the app. */
@property(nonatomic) GTMSessionFetcherService *fetcherService;

@end
</code><paragraph>Doxygen-style comments are encouraged for interfaces as they are parsed by Xcode to display formatted documentation. There is a wide variety of Doxygen commands; use them consistently within a project.</paragraph><paragraph>If you have already described an interface in detail in the comments at the top of your file, feel free to simply state, "See comment at top of file for a complete description", but be sure to have some sort of comment.</paragraph><paragraph>Additionally, each method should have a comment explaining its function, arguments, return value, thread or queue assumptions, and any side effects. Documentation comments should be in the header for public methods, or immediately preceding the method for non-trivial private methods.</paragraph><paragraph>Use descriptive form ("Opens the file") rather than imperative form ("Open the file") for method and function comments. The comment describes the function; it does not tell the function what to do.</paragraph><paragraph>Document the thread usage assumptions the class, properties, or methods make, if any. If an instance of the class can be accessed by multiple threads, take extra care to document the rules and invariants surrounding multithreaded use.</paragraph><paragraph>Any sentinel values for properties and ivars, such as NULL or -1, should be documented in comments.</paragraph><paragraph>Declaration comments explain how a method or function is used. Comments explaining how a method or function is implemented should be with the implementation rather than with the declaration.</paragraph><paragraph>Declaration comments may be omitted on test case classes and test methods if comments would communicate no additional information beyond the method's name. Utility methods in tests or test-specific classes (such as helpers) should be commented.</paragraph><paragraph>Provide comments explaining tricky, subtle, or complicated sections of code.</paragraph><code language="code">// GOOD:

// Set the property to nil before invoking the completion handler to
// avoid the risk of reentrancy leading to the callback being
// invoked again.
CompletionHandler handler = self.completionHandler;
self.completionHandler = nil;
handler();
</code><paragraph>When useful, also provide comments about implementation approaches that were considered or abandoned.</paragraph><paragraph>End-of-line comments should be separated from the code by at least 2 spaces. If you have several comments on subsequent lines, it can often be more readable to line them up.</paragraph><code language="code">// GOOD:

[self doSomethingWithALongName];  // Two spaces before the comment.
[self doSomethingShort];          // More spacing to align the comment.
</code><heading level="3">Disambiguating Symbols</heading><paragraph>Where needed to avoid ambiguity, use backticks or vertical bars to quote variable names and symbols in comments in preference to using quotation marks or naming the symbols inline.</paragraph><paragraph>In Doxygen-style comments, prefer demarcating symbols with a monospace text command, such as @c.</paragraph><paragraph>Demarcation helps provide clarity when a symbol is a common word that might make the sentence read like it was poorly constructed. A common example is the symbol count:</paragraph><code language="code">// GOOD:

// Sometimes `count` will be less than zero.
</code><paragraph>or when quoting something which already contains quotes</paragraph><code language="code">// GOOD:

// Remember to call `StringWithoutSpaces("foo bar baz")`
</code><paragraph>Backticks or vertical bars are not needed when a symbol is self-apparent.</paragraph><code language="code">// GOOD:

// This class serves as a delegate to GTMDepthCharge.
</code><paragraph>Doxygen formatting is also suitable for identifying symbols.</paragraph><code language="code">// GOOD:

/** @param maximum The highest value for @c count. */
</code><heading level="3">Object Ownership</heading><paragraph>For objects not managed by ARC, make the pointer ownership model as explicit as possible when it falls outside the most common Objective-C usage idioms.</paragraph><heading level="4">Manual Reference Counting</heading><paragraph>Instance variables for NSObject-derived objects are presumed to be retained; if they are not retained, they should be either commented as weak or declared with the __weak lifetime qualifier.</paragraph><paragraph>An exception is in Mac software for instance variables labeled as @IBOutlets, which are presumed to not be retained.</paragraph><paragraph>Where instance variables are pointers to Core Foundation, C++, and other non-Objective-C objects, they should always be declared with strong and weak comments to indicate which pointers are and are not retained. Core Foundation and other non-Objective-C object pointers require explicit memory management, even when building for automatic reference counting.</paragraph><paragraph>Examples of strong and weak declarations:</paragraph><code language="javascript">// GOOD:

@interface MyDelegate : NSObject

@property(nonatomic) NSString *doohickey;
@property(nonatomic, weak) NSString *parent;

@end


@implementation MyDelegate {
  IBOutlet NSButton *_okButton;  // Normal NSControl; implicitly weak on Mac only

  AnObjcObject *_doohickey;  // My doohickey
  __weak MyObjcParent *_parent;  // To send messages back (owns this instance)

  // non-NSObject pointers...
  CWackyCPPClass *_wacky;  // Strong, some cross-platform object
  CFDictionaryRef *_dict;  // Strong
}
@end
</code><heading level="4">Automatic Reference Counting</heading><paragraph>Object ownership and lifetime are explicit when using ARC, so no additional comments are required for automatically retained objects.</paragraph><heading level="2">C Language Features</heading><heading level="3">Macros</heading><paragraph>Avoid macros, especially where const variables, enums, Xcode snippets, or C functions may be used instead.</paragraph><paragraph>Macros make the code you see different from the code the compiler sees. Modern C renders traditional uses of macros for constants and utility functions unnecessary. Macros should only be used when there is no other solution available.</paragraph><paragraph>Where a macro is needed, use a unique name to avoid the risk of a symbol collision in the compilation unit. If practical, keep the scope limited by #undefining the macro after its use.</paragraph><paragraph>Macro names should use SHOUTY_SNAKE_CASE—all uppercase letters with underscores between words. Function-like macros may use C function naming practices. Do not define macros that appear to be C or Objective-C keywords.</paragraph><code language="code">// GOOD:

#define GTM_EXPERIMENTAL_BUILD ...      // GOOD

// Assert unless X > Y
#define GTM_ASSERT_GT(X, Y) ...         // GOOD, macro style.

// Assert unless X > Y
#define GTMAssertGreaterThan(X, Y) ...  // GOOD, function style.
</code><code language="code">// AVOID:

#define kIsExperimentalBuild ...        // AVOID

#define unless(X) if(!(X))              // AVOID
</code><paragraph>Avoid macros that expand to unbalanced C or Objective-C constructs. Avoid macros that introduce scope, or may obscure the capturing of values in blocks.</paragraph><paragraph>Avoid macros that generate class, property, or method definitions in headers to be used as public API. These only make the code hard to understand, and the language already has better ways of doing this.</paragraph><paragraph>Avoid macros that generate method implementations, or that generate declarations of variables that are later used outside of the macro. Macros shouldn't make code hard to understand by hiding where and how a variable is declared.</paragraph><code language="javascript">// AVOID:

#define ARRAY_ADDER(CLASS) \
  -(void)add ## CLASS ## :(CLASS *)obj toArray:(NSMutableArray *)array

ARRAY_ADDER(NSString) {
  if (array.count > 5) {              // AVOID -- where is 'array' defined?
    ...
  }
}
</code><paragraph>Examples of acceptable macro use include assertion and debug logging macros that are conditionally compiled based on build settings—often, these are not compiled into release builds.</paragraph><heading level="3">Nonstandard Extensions</heading><paragraph>Nonstandard extensions to C/Objective-C may not be used unless otherwise specified.</paragraph><paragraph>Compilers support various extensions that are not part of standard C. Examples include compound statement expressions (e.g. foo = ({ int x; Bar(&x); x })).</paragraph><heading level="4">The __typeof__ Keyword</heading><paragraph>The __typeof__ keyword is allowed in cases where the type doesn't aid in clarity for the reader. The __typeof__ keyword is encouraged over other similar keywords (e.g., the typeof keyword) as it is supported in all language variants.</paragraph><code language="code">// GOOD:

  __weak __typeof__(self) weakSelf = self;
</code><code language="code">// AVOID:

  __typeof__(data) copiedData = [data copy];  // AVOID.
  __weak typeof(self) weakSelf = self;        // AVOID.
</code><heading level="4">The __auto_type Keyword and Type Deduction</heading><paragraph>Type deduction using the __auto_type keyword is allowed only for local variables of block and function pointer types. Avoid type deduction if a typedef already exists for the block or pointer type.</paragraph><code language="python">// GOOD:

__auto_type block = ^(NSString *arg1, int arg2) { ... };
__auto_type functionPointer = &MyFunction;

typedef void(^SignInCallback)(Identity *, NSError *);
SignInCallback signInCallback = ^(Identity *identity, NSError *error) { ... };
</code><code language="python">// AVOID:

__auto_type button = [self createButtonForInfo:info];
__auto_type viewController = [[MyCustomViewControllerClass alloc] initWith...];

typedef void(^SignInCallback)(Identity *, NSError *);
__auto_type signInCallback = ^(Identity *identity, NSError *error) { ... };
</code><heading level="4">Approved Nonstandard Extensions</heading><list type="ul"><item>The __attribute__ keyword is approved as it is used in Apple API declarations.</item><item>The binary form of the conditional operator, A ?: B, is approved.</item></list><heading level="2">Cocoa and Objective-C Features</heading><heading level="3">Identify Designated Initializers</heading><paragraph>Clearly identify your designated initializer(s).</paragraph><paragraph>It is important for subclassing that a class clearly identify its designated initializers. This allows a subclass to override a subset of initializers to initialize subclass state or invoke a new designated initializer provided by the subclass. Clearly identified designated initializers also make tracing through and debugging initialization code easier.</paragraph><paragraph>Prefer identifying designated initializers by annotating them with designated initializer attributes, e.g., NS_DESIGNATED_INITIALIZER. Declare designated initializers in comments when designated initializer attributes are not available. Prefer a single designated initializer unless there is a compelling reason or requirement for multiple designated initializers.</paragraph><paragraph>Support initializers inherited from superclasses by overriding superclass designated initializers to ensure that all inherited initializers are directed through subclass designated initializers. When there is a compelling reason or requirement that an inherited initializer should not be supported, the initializer may be annotated with availability attributes (e.g., NS_UNAVAILABLE) to discourage usage; however, note that availability attributes alone do not completely protect against invalid initialization.</paragraph><heading level="3">Override Designated Initializers</heading><paragraph>When writing a subclass that requires a new designated initializer, make sure you override any designated initializers of the superclass.</paragraph><paragraph>When declaring designated initializers on a class, remember that any initializers that were considered designated initializers on the superclass become convenience initializers of the subclass unless declared otherwise. Failure to override superclass designated initializers can result in bugs due to invalid initialization using superclass initializers. To avoid invalid initialization, ensure convenience initializers call through to a designated initializer.</paragraph><heading level="3">Overridden NSObject Method Placement</heading><paragraph>Put overridden methods of NSObject at the top of an @implementation.</paragraph><paragraph>This commonly applies to (but is not limited to) the init..., copyWithZone:, and dealloc methods. The init... methods should be grouped together, including those init... methods that are not NSObject overrides, followed by other typical NSObject methods such as description, isEqual:, and hash.</paragraph><paragraph>Convenience class factory methods for creating instances may precede the NSObject methods.</paragraph><heading level="3">Initialization</heading><paragraph>Don't initialize instance variables to 0 or nil in the init method; doing so is redundant.</paragraph><paragraph>All instance variables for a newly allocated object are initialized to 0 (except for isa), so don't clutter up the init method by re-initializing variables to 0 or nil.</paragraph><paragraph>Instance variables should typically be declared in implementation files or auto-synthesized by properties. When ivars are declared in a header file, they should be marked @protected or @private.</paragraph><code language="javascript">// GOOD:

@interface MyClass : NSObject {
 @protected
  id _myInstanceVariable;
}
@end
</code><heading level="3">Do Not Use +new</heading><paragraph>Do not invoke the NSObject class method new, nor override it in a subclass. +new is rarely used and contrasts greatly with initializer usage. Instead, use +alloc and -init methods to instantiate retained objects.</paragraph><heading level="3">Keep the Public API Simple</heading><paragraph>Keep your class simple; avoid "kitchen-sink" APIs. If a method doesn't need to be public, keep it out of the public interface.</paragraph><paragraph>Unlike C++, Objective-C doesn't differentiate between public and private methods; any message may be sent to an object. As a result, avoid placing methods in the public API unless they are actually expected to be used by a consumer of the class. This helps reduce the likelihood they'll be called when you're not expecting it. This includes methods that are being overridden from the parent class.</paragraph><paragraph>Since internal methods are not really private, it's easy to accidentally override a superclass's "private" method, thus making a very difficult bug to squash. In general, private methods should have a fairly unique name that will prevent subclasses from unintentionally overriding them.</paragraph><heading level="3">#import and #include</heading><paragraph>#import Objective-C and Objective-C++ headers, and #include C/C++ headers.</paragraph><paragraph>C/C++ headers include other C/C++ headers using #include. Using #import on C/C++ headers prevents future inclusions using #include and could result in unintended compilation behavior.</paragraph><paragraph>C/C++ headers should provide their own #define guard.</paragraph><heading level="3">Order of Includes</heading><paragraph>The standard order for header inclusion is the related header, operating system headers, language library headers, and finally groups of headers for other dependencies.</paragraph><paragraph>The related header precedes others to ensure it has no hidden dependencies. For implementation files the related header is the header file. For test files the related header is the header containing the tested interface.</paragraph><paragraph>Separate each non-empty group of includes with one blank line. Within each group the includes should be ordered alphabetically.</paragraph><paragraph>Import headers using their path relative to the project's source directory.</paragraph><code language="cpp">// GOOD:

#import "ProjectX/BazViewController.h"

#import <Foundation/Foundation.h>

#include <unistd.h>
#include <vector>

#include "base/basictypes.h"
#include "base/integral_types.h"
#import "base/mac/FOOComplexNumberSupport"
#include "util/math/mathutil.h"

#import "ProjectX/BazModel.h"
#import "Shared/Util/Foo.h"
</code><paragraph>Import umbrella headers for system frameworks and system libraries rather than include individual files.</paragraph><paragraph>While it may seem tempting to include individual system headers from a framework such as Cocoa or Foundation, in fact it's less work on the compiler if you include the top-level root framework. The root framework is generally pre-compiled and can be loaded much more quickly. In addition, remember to use @import or #import rather than #include for Objective-C frameworks.</paragraph><code language="code">// GOOD:

@import UIKit;     // GOOD.
#import <Foundation/Foundation.h>     // GOOD.
</code><code language="code">// AVOID:

#import <Foundation/NSArray.h>        // AVOID.
#import <Foundation/NSString.h>
...
</code><heading level="3">Avoid Messaging the Current Object Within Initializers and -dealloc</heading><paragraph>Code in initializers and -dealloc should avoid invoking instance methods when possible.</paragraph><paragraph>Superclass initialization completes before subclass initialization. Until all classes have had a chance to initialize their instance state any method invocation on self may lead to a subclass operating on uninitialized instance state.</paragraph><paragraph>A similar issue exists for -dealloc, where a method invocation may cause a class to operate on state that has been deallocated.</paragraph><paragraph>One case where this is less obvious is property accessors. These can be overridden just like any other selector. Whenever practical, directly assign to and release ivars in initializers and -dealloc, rather than rely on accessors.</paragraph><code language="javascript">// GOOD:

- (instancetype)init {
  self = [super init];
  if (self) {
    _bar = 23;  // GOOD.
  }
  return self;
}
</code><paragraph>Beware of factoring common initialization code into helper methods:</paragraph><list type="ul"><item>Methods can be overridden in subclasses, either deliberately, or accidentally due to naming collisions.</item><item>When editing a helper method, it may not be obvious that the code is being run from an initializer.</item></list><code language="javascript">// AVOID:

- (instancetype)init {
  self = [super init];
  if (self) {
    self.bar = 23;  // AVOID.
    [self sharedMethod];  // AVOID. Fragile to subclassing or future extension.
  }
  return self;
}
</code><code language="javascript">// GOOD:

- (void)dealloc {
  [_notifier removeObserver:self];  // GOOD.
}
</code><code language="javascript">// AVOID:

- (void)dealloc {
  [self removeNotifications];  // AVOID.
}
</code><paragraph>There are common cases where a class may need to use properties and methods provided by a superclass during initialization. This commonly occurs for classes derived from UIKit and AppKit base classes, among other base classes. Use your judgement and knowledge of common practice when deciding whether to make an exception to this rule.</paragraph><heading level="3">Avoid redundant property access</heading><paragraph>Code should avoid redundant property access. Prefer to assign a property value to a local variable when the property value is not expected to change and needs to be used multiple times.</paragraph><code language="code">// GOOD:

UIView *view = self.view;
UIScrollView *scrollView = self.scrollView;
[scrollView.leadingAnchor constraintEqualToAnchor:view.leadingAnchor].active = YES;
[scrollView.trailingAnchor constraintEqualToAnchor:view.trailingAnchor].active = YES;
</code><code language="code">// AVOID:

[self.scrollView.loadingAnchor constraintEqualToAnchor:self.view.loadingAnchor].active = YES;
[self.scrollView.trailingAnchor constraintEqualToAnchor:self.view.trailingAnchor].active = YES;
</code><paragraph>When repeatedly referencing chained property invocations, prefer to capture the repeated expression in a local variable:</paragraph><code language="code">// AVOID:

foo.bar.baz.field1 = 10;
foo.bar.baz.field2 = @"Hello";
foo.bar.baz.field3 = 2.71828183;
</code><code language="code">// GOOD:

Baz *baz = foo.bar.baz;
baz.field1 = 10;
baz.field2 = @"Hello";
baz.field3 = 2.71828183;
</code><paragraph>Redundantly accessing the same properties results in multiple message dispatches to fetch the same value, and under ARC requires retains and releases of any returned objects; the compiler cannot optimize away these extra operations, leading to slower execution and substantial increases in binary size.</paragraph><heading level="3">Mutables, Copies and Ownership</heading><paragraph>For Foundation and other hierarchies containing both immutable and mutable subclasses a mutable subclass may be substituted for an immutable so long as the immutable's contract is honored.</paragraph><paragraph>The most common example of this sort of substitution are ownership transfers, particularly for return values. In these cases an additional copy is not necessary and returning the mutable subclass is more efficient. Callers are expected to treat return values as their declared type, and thus the return value will be treated as an immutable going forward.</paragraph><code language="javascript">// GOOD:

- (NSArray *)listOfThings {
  NSMutableArray *generatedList = [NSMutableArray array];
  for (NSInteger i = 0; i < _someLimit; i++) {
    [generatedList addObject:[self thingForIndex:i]];
  }
  // Copy not necessary, ownership of generatedList is transferred.
  return generatedList;
}
</code><paragraph>This rule also applies to classes where only a mutable variant exists so long as the ownership transfer is clear. Protos are a common example.</paragraph><code language="javascript">// GOOD:

- (SomeProtoMessage *)someMessageForValue:(BOOL)value {
  SomeProtoMessage *message = [SomeProtoMessage message];
  message.someValue = value;
  return message;
}
</code><paragraph>It is not necessary to create a local immutable copy of a mutable type to match the method signature of a method being called so long as the mutable argument will not change for the duration of the method call. Called methods are expected to treat arguments as the declared type, and take defensive copies (referred to by Apple as "snapshots") if they intend to retain those arguments beyond the duration of the call.</paragraph><code language="code">// AVOID:

NSMutableArray *updatedThings = [NSMutableArray array];
[updatedThings addObject:newThing];
[_otherManager updateWithCurrentThings:[updatedThings copy]];  // AVOID
</code><heading level="3">Copy Potentially Mutable Objects</heading><paragraph>Code receiving and retaining collections or other types with mutable variants should consider that the passed object may be mutable, and thus an immutable or mutable copy should be retained instead of the original object. In particular, initializers and setters should copy instead of retaining objects whose types have mutable variants.</paragraph><paragraph>Synthesized accessors should use the copy keyword to ensure the generated code matches these expectations.</paragraph><paragraph>NOTE: The copy property keyword only affects the synthesized setter and has no effect on getters. Since property keywords have no effect on direct ivar access custom accessors must implement the same copy semantics.</paragraph><code language="javascript">// GOOD:

@property(nonatomic, copy) NSString *name;
@property(nonatomic, copy) NSSet<FilterThing *> *filters;

- (instancetype)initWithName:(NSString *)name
                     filters:(NSSet<FilterThing *> *)filters {
  self = [super init];
  if (self) {
    _name = [name copy];
    _filters = [filters copy];
  }
  return self;
}

- (void)setFilters:(NSSet<FilterThing *> *)filters {
  // Ensure that we retain an immutable collection.
  _filters = [filters copy];
}
</code><paragraph>Similarly, getters must return types that match the contract expectations of the immutable types they return.</paragraph><code language="javascript">// GOOD:


@implementation Foo {
  NSMutableArray<ContentThing *> *_currentContent;
}

- (NSArray<ContentThing *> *)currentContent {
  return [_currentContent copy];
}

</code><paragraph>All Objective-C protos are mutable and typically should be copied rather than retained except in clear cases of ownership transfer.</paragraph><code language="javascript">// GOOD:

- (void)setFooMessage:(FooMessage *)fooMessage {
  // Copy proto to ensure no other retainer can mutate our value.
  _fooMessage = [fooMessage copy];
}

- (FooMessage *)fooMessage {
  // Copy proto to return so that caller cannot mutate our value.
  return [_fooMessage copy];
}
</code><paragraph>Asynchronous code should copy potentially mutable objects prior to dispatch. Objects captured by blocks are retained but not copied.</paragraph><code language="javascript">// GOOD:

- (void)doSomethingWithThings:(NSArray<Thing *> *)things {
  NSArray<Thing *> *thingsToWorkOn = [things copy];
  dispatch_async(_workQueue, ^{
    for (id<Thing> thing in thingsToWorkOn) {
      ...
    }
  });
}
</code><paragraph>NOTE: It is unnecessary to copy objects that do not have mutable variants, e.g. NSURL, NSNumber, NSDate, UIColor, etc.</paragraph><heading level="3">Use Lightweight Generics to Document Contained Types</heading><paragraph>All projects compiling on Xcode 7 or newer versions should make use of the Objective-C lightweight generics notation to type contained objects.</paragraph><paragraph>Every NSArray, NSDictionary, or NSSet reference should be declared using lightweight generics for improved type safety and to explicitly document usage.</paragraph><code language="code">// GOOD:

@property(nonatomic, copy) NSArray<Location *> *locations;
@property(nonatomic, copy, readonly) NSSet<NSString *> *identifiers;

NSMutableArray<MyLocation *> *mutableLocations = [otherObject.locations mutableCopy];
</code><paragraph>If the fully-annotated types become complex, consider using a typedef to preserve readability.</paragraph><code language="code">// GOOD:

typedef NSSet<NSDictionary<NSString *, NSDate *> *> TimeZoneMappingSet;
TimeZoneMappingSet *timeZoneMappings = [TimeZoneMappingSet setWithObjects:...];
</code><paragraph>Use the most descriptive common superclass or protocol available. In the most generic case when nothing else is known, declare the collection to be explicitly heterogeneous using id.</paragraph><code language="code">// GOOD:

@property(nonatomic, copy) NSArray<id> *unknowns;
</code><heading level="3">Avoid Throwing Exceptions</heading><paragraph>Don't @throw Objective-C exceptions, but you should be prepared to catch them from third-party or OS calls.</paragraph><paragraph>This follows the recommendation to use error objects for error delivery in Apple's Introduction to Exception Programming Topics for Cocoa.</paragraph><paragraph>We do compile with -fobjc-exceptions (mainly so we get @synchronized), but we don't @throw. Use of @try, @catch, and @finally are allowed when required to properly use 3rd party code or libraries. If you do use them, please document exactly which methods you expect to throw.</paragraph><heading level="3">nil Checks</heading><paragraph>Avoid nil pointer checks that exist only to prevent sending messages to nil. Sending a message to nil reliably returns nil as a pointer, zero as an integer or floating-point value, structs initialized to 0, and _Complex values equal to {0, 0}.</paragraph><code language="code">// AVOID:

if (dataSource) {  // AVOID.
  [dataSource moveItemAtIndex:1 toIndex:0];
}
</code><code language="code">// GOOD:

[dataSource moveItemAtIndex:1 toIndex:0];  // GOOD.
</code><paragraph>Note that this applies to nil as a message target, not as a parameter value. Individual methods may or may not safely handle nil parameter values.</paragraph><paragraph>Note too that this is distinct from checking C/C++ pointers and block pointers against NULL, which the runtime does not handle and will cause your application to crash. You still need to make sure you do not dereference a NULL pointer.</paragraph><heading level="3">Nullability</heading><paragraph>Interfaces can be decorated with nullability annotations to describe how the interface should be used and how it behaves. Use of nullability regions (e.g., NS_ASSUME_NONNULL_BEGIN and NS_ASSUME_NONNULL_END) and explicit nullability annotations are both accepted. Prefer using the _Nullable and _Nonnull keywords over the __nullable and __nonnull keywords. For Objective-C methods and properties prefer using the context-sensitive, non-underscored keywords, e.g., nonnull and nullable.</paragraph><code language="code">// GOOD:

/** A class representing an owned book. */
@interface GTMBook : NSObject

/** The title of the book. */
@property(nonatomic, readonly, copy, nonnull) NSString *title;

/** The author of the book, if one exists. */
@property(nonatomic, readonly, copy, nullable) NSString *author;

/** The owner of the book. Setting nil resets to the default owner. */
@property(nonatomic, copy, null_resettable) NSString *owner;

/** Initializes a book with a title and an optional author. */
- (nonnull instancetype)initWithTitle:(nonnull NSString *)title
                               author:(nullable NSString *)author
    NS_DESIGNATED_INITIALIZER;

/** Returns nil because a book is expected to have a title. */
- (nullable instancetype)init;

@end

/** Loads books from the file specified by the given path. */
NSArray<GTMBook *> *_Nullable GTMLoadBooksFromFile(NSString *_Nonnull path);
</code><code language="code">// AVOID:

NSArray<GTMBook *> *__nullable GTMLoadBooksFromTitle(NSString *__nonnull path);
</code><paragraph>Do not assume that a pointer is not null based on a nonnull qualifier, because the compiler only checks a subset of such cases, and does not guarantee that the pointer is not null. Avoid intentionally violating nullability semantics of function, method, and property declarations.</paragraph><heading level="3">BOOL Pitfalls</heading><heading level="4">BOOL Expressions and Conversions</heading><paragraph>Be careful when converting general integral values to BOOL. Avoid comparing directly with YES or comparing multiple BOOL values with comparison operators.</paragraph><paragraph>BOOL on some Apple platforms (notably Intel macOS, watchOS, and 32-bit iOS) is defined as a signed char, so it may have values other than YES (1) and NO (0). Do not cast or convert general integral values directly to BOOL.</paragraph><paragraph>Common mistakes include casting or converting an array's size, a pointer value, or the result of a bitwise logic operation to a BOOL. These operations can depend on the value of the last byte of the integer value and result in an unexpected NO value. Operations with NS_OPTIONS values and flag masking are especially common errors.</paragraph><paragraph>When converting a general integral value to a BOOL, use conditional operators to return a YES or NO value.</paragraph><paragraph>You can safely interchange and convert BOOL, _Bool and bool (see C++ Std 4.7.4, 4.12 and C99 Std 6.3.1.2). Use BOOL in Objective-C method signatures.</paragraph><paragraph>Using logical operators (&&, || and !) with BOOL is also valid and will return values that can be safely converted to BOOL without the need for a conditional operator.</paragraph><code language="javascript">// AVOID:

- (BOOL)isBold {
  return [self fontTraits] & NSFontBoldTrait;  // AVOID.
}
- (BOOL)isValid {
  return [self stringValue];  // AVOID.
}
- (BOOL)isLongEnough {
  return (BOOL)([self stringValue].count);  // AVOID.
}
</code><code language="javascript">// GOOD:

- (BOOL)isBold {
  return ([self fontTraits] & NSFontBoldTrait) ? YES : NO;
}
- (BOOL)isValid {
  return [self stringValue] != nil;
}
- (BOOL)isLongEnough {
  return [self stringValue].count > 0;
}
- (BOOL)isEnabled {
  return [self isValid] && [self isBold];
}
</code><paragraph>Don't directly compare BOOL variables directly with YES. Not only is it harder to read for those well-versed in C, but the first point above demonstrates that return values may not always be what you expect.</paragraph><code language="code">// AVOID:

BOOL great = [foo isGreat];
if (great == YES) {  // AVOID.
  // ...be great!
}
</code><code language="code">// GOOD:

BOOL great = [foo isGreat];
if (great) {         // GOOD.
  // ...be great!
}
</code><paragraph>Don't directly compare BOOL values using comparison operators. BOOL values that are true may not be equal. Use logical operators in place of bitwise comparisons of BOOL values.</paragraph><code language="code">// AVOID:

if (oldBOOLValue != newBOOLValue) {  // AVOID.
  // ... code that should only run when the value changes.
}
</code><code language="javascript">// GOOD:

if ((!oldBoolValue && newBoolValue) || (oldBoolValue && !newBoolValue)) {  // GOOD.
  // ... code that should only run when the value changes.
}

// GOOD, the results of logical operators on BOOLs are safe to compare.
if (!oldBoolValue != !newBoolValue) {
  // ... code that should only run when the value changes.
}
</code><heading level="4">BOOL Literals</heading><paragraph>The BOOL NSNumber literals are @YES and @NO which are equivalent to [NSNumber numberWithBool:...].</paragraph><paragraph>Avoid using boxed expressions to create BOOL values, including simple expressions like @(YES). Boxed expressions suffer from [the same pitfalls as other BOOL expressions] (#BOOL_Expressions_Conversions) as boxing general integral values can produce true or false NSNumbers that are not equal to @YES and @NO.</paragraph><paragraph>When converting a general integral value to a BOOL literal, use conditional operators to convert to @YES or @NO. Do not embed a conditional operator inside a boxed expression as this is equivalent to boxing general integral values even when the result of the operation is a BOOL.</paragraph><code language="code">// AVOID:

[_boolArray addValue:@(YES)];  // AVOID boxing even in simple cases.
NSNumber *isBold = @(self.fontTraits & NSFontBoldTrait);  // AVOID.
NSNumber *hasContent = @([self stringValue].length);  // AVOID.
NSNumber *isValid = @([self stringValue]);  // AVOID.
NSNumber *isStringNotNil = @([self stringValue] ? YES : NO);  // AVOID.
</code><code language="code">// GOOD:

[_boolArray addValue:@YES];  // GOOD.
NSNumber *isBold = self.fontTraits & NSFontBoldTrait ? @YES : @NO;  // GOOD.
NSNumber *hasContent = [self stringValue].length ? @YES : @NO;  // GOOD.
NSNumber *isValid = [self stringValue] ? @YES : @NO;  // GOOD.
NSNumber *isStringNotNil = [self stringValue] ? @YES : @NO;  // GOOD.
</code><heading level="3">Containers Without Instance Variables</heading><paragraph>Omit the empty set of braces on interfaces, class extensions, and implementations without any instance variable declarations.</paragraph><code language="code">// GOOD:

@interface MyClass : NSObject
// Does a lot of stuff.
- (void)fooBarBam;
@end

@interface MyClass ()
- (void)classExtensionMethod;
@end

@implementation MyClass
// Actual implementation.
@end
</code><code language="javascript">// AVOID:

@interface MyClass : NSObject {
}
// Does a lot of stuff.
- (void)fooBarBam;
@end

@interface MyClass () {
}
- (void)classExtensionMethod;
@end

@implementation MyClass {
}
// Actual implementation.
@end
</code><heading level="2">Cocoa Patterns</heading><heading level="3">Delegate Pattern</heading><paragraph>Delegates, target objects, and block pointers should not be retained when doing so would create a retain cycle.</paragraph><paragraph>To avoid causing a retain cycle, a delegate or target pointer should be released as soon as it is clear there will no longer be a need to message the object.</paragraph><paragraph>If there is no clear time at which the delegate or target pointer is no longer needed, the pointer should only be retained weakly.</paragraph><paragraph>Block pointers cannot be retained weakly. To avoid causing retain cycles in the client code, block pointers should be used for callbacks only where they can be explicitly released after they have been called or once they are no longer needed. Otherwise, callbacks should be done via weak delegate or target pointers.</paragraph><heading level="2">Objective-C++</heading><heading level="3">Style Matches the Language</heading><paragraph>Within an Objective-C++ source file, follow the style for the language of the function or method you're implementing. In order to minimize clashes between the differing naming styles when mixing Cocoa/Objective-C and C++, follow the style of the method being implemented.</paragraph><paragraph>For code in an @implementation block, use the Objective-C naming rules. For code in a method of a C++ class, use the C++ naming rules.</paragraph><paragraph>For code in an Objective-C++ file outside of a class implementation, be consistent within the file.</paragraph><code language="javascript">// GOOD:

// file: cross_platform_header.h

class CrossPlatformAPI {
 public:
  ...
  int DoSomethingPlatformSpecific();  // impl on each platform
 private:
  int an_instance_var_;
};

// file: mac_implementation.mm
#include "cross_platform_header.h"

/** A typical Objective-C class, using Objective-C naming. */
@interface MyDelegate : NSObject {
 @private
  int _instanceVar;
  CrossPlatformAPI* _backEndObject;
}

- (void)respondToSomething:(id)something;

@end

@implementation MyDelegate

- (void)respondToSomething:(id)something {
  // bridge from Cocoa through our C++ backend
  _instanceVar = _backEndObject->DoSomethingPlatformSpecific();
  NSString* tempString = [NSString stringWithFormat:@"%d", _instanceVar];
  NSLog(@"%@", tempString);
}

@end

/** The platform-specific implementation of the C++ class, using C++ naming. */
int CrossPlatformAPI::DoSomethingPlatformSpecific() {
  NSString* temp_string = [NSString stringWithFormat:@"%d", an_instance_var_];
  NSLog(@"%@", temp_string);
  return [temp_string intValue];
}
</code><paragraph>Projects may opt to use an 80 column line length limit for consistency with Google's C++ style guide.</paragraph><heading level="2">Spacing and Formatting</heading><heading level="3">Spaces vs. Tabs</heading><paragraph>Use only spaces, and indent 2 spaces at a time. We use spaces for indentation. Do not use tabs in your code.</paragraph><paragraph>You should set your editor to emit spaces when you hit the tab key, and to trim trailing spaces on lines.</paragraph><heading level="3">Line Length</heading><paragraph>The maximum line length for Objective-C files is 100 columns.</paragraph><heading level="3">Method Declarations and Definitions</heading><paragraph>One space should be used between the - or + and the return type. In general, there should be no spacing in the parameter list except between parameters.</paragraph><paragraph>Methods should look like this:</paragraph><code language="javascript">// GOOD:

- (void)doSomethingWithString:(NSString *)theString {
  ...
}
</code><paragraph>The spacing before the asterisk is optional. When adding new code, be consistent with the surrounding file's style.</paragraph><paragraph>If a method declaration does not fit on a single line, put each parameter on its own line. All lines except the first should be indented at least four spaces. Colons before parameters should be aligned on all lines. If the colon before the parameter on the first line of a method declaration is positioned such that colon alignment would cause indentation on a subsequent line to be less than four spaces, then colon alignment is only required for all lines except the first. If a parameter declared after the : in a method declaration or definition would cause the line limit to be exceeded, wrap the content to the next line indented by at least four spaces.</paragraph><code language="javascript">// GOOD:

- (void)doSomethingWithFoo:(GTMFoo *)theFoo
                      rect:(NSRect)theRect
                  interval:(float)theInterval {
  ...
}

- (void)shortKeyword:(GTMFoo *)theFoo
            longerKeyword:(NSRect)theRect
    someEvenLongerKeyword:(float)theInterval
                    error:(NSError **)theError {
  ...
}

- (id<UIAdaptivePresentationControllerDelegate>)
    adaptivePresentationControllerDelegateForViewController:(UIViewController *)viewController;

- (void)presentWithAdaptivePresentationControllerDelegate:
    (id<UIAdaptivePresentationControllerDelegate>)delegate;

- (void)updateContentHeaderViewForExpansionToContentOffset:(CGPoint)contentOffset
                                            withController:
                                                (GTMCollectionExpansionController *)controller;

</code><heading level="3">Function Declarations and Definitions</heading><paragraph>Prefer putting the return type on the same line as the function name and append all parameters on the same line if they will fit. Wrap parameter lists which do not fit on a single line as you would wrap arguments in a function call.</paragraph><code language="javascript">// GOOD:

NSString *GTMVersionString(int majorVersion, int minorVersion) {
  ...
}

void GTMSerializeDictionaryToFileOnDispatchQueue(
    NSDictionary<NSString *, NSString *> *dictionary,
    NSString *filename,
    dispatch_queue_t queue) {
  ...
}
</code><paragraph>Function declarations and definitions should also satisfy the following conditions:</paragraph><list type="ul"><item>The opening parenthesis must always be on the same line as the function name.</item><item>If you cannot fit the return type and the function name on a single line, break between them and do not indent the function name.</item><item>There should never be a space before the opening parenthesis.</item><item>There should never be a space between function parentheses and parameters.</item><item>The open curly brace is always on the end of the last line of the function declaration, not the start of the next line.</item><item>The close curly brace is either on the last line by itself or on the same line as the open curly brace.</item><item>There should be a space between the close parenthesis and the open curly brace.</item><item>All parameters should be aligned if possible.</item><item>Function scopes should be indented 2 spaces.</item><item>Wrapped parameters should have a 4 space indent.</item></list><heading level="3">Conditionals</heading><paragraph>Include a space after if, while, for, and switch, and around comparison operators.</paragraph><code language="javascript">// GOOD:

for (int i = 0; i < 5; ++i) {
}

while (test) {};
</code><paragraph>Braces may be omitted when a loop body or conditional statement fits on a single line.</paragraph><code language="javascript">// GOOD:

if (hasSillyName) LaughOutLoud();

for (int i = 0; i < 10; i++) {
  BlowTheHorn();
}
</code><code language="code">// AVOID:

if (hasSillyName)
  LaughOutLoud();               // AVOID.

for (int i = 0; i < 10; i++)
  BlowTheHorn();                // AVOID.
</code><paragraph>If an if clause has an else clause, both clauses should use braces.</paragraph><code language="javascript">// GOOD:

if (hasBaz) {
  foo();
} else {  // The else goes on the same line as the closing brace.
  bar();
}
</code><code language="javascript">// AVOID:

if (hasBaz) foo();
else bar();        // AVOID.

if (hasBaz) {
  foo();
} else bar();      // AVOID.
</code><paragraph>Intentional fall-through to the next case should be documented with a comment unless the case has no intervening code before the next case.</paragraph><code language="javascript">// GOOD:

switch (i) {
  case 1:
    ...
    break;
  case 2:
    j++;
    // Falls through.
  case 3: {
    int k;
    ...
    break;
  }
  case 4:
  case 5:
  case 6: break;
}
</code><heading level="3">Expressions</heading><paragraph>Use a space around binary operators and assignments. Omit a space for a unary operator. Do not add spaces inside parentheses.</paragraph><code language="code">// GOOD:

x = 0;
v = w * x + y / z;
v = -y * (x + z);
</code><paragraph>Factors in an expression may omit spaces.</paragraph><heading level="3">Method Invocations</heading><paragraph>Method invocations should be formatted much like method declarations.</paragraph><paragraph>When there's a choice of formatting styles, follow the convention already used in a given source file. Invocations should have all arguments on one line:</paragraph><code language="code">// GOOD:

[myObject doFooWith:arg1 name:arg2 error:arg3];
</code><paragraph>or have one argument per line, with colons aligned:</paragraph><code language="code">// GOOD:

[myObject doFooWith:arg1
               name:arg2
              error:arg3];
</code><paragraph>Don't use any of these styles:</paragraph><code language="code">// AVOID:

[myObject doFooWith:arg1 name:arg2  // some lines with >1 arg
              error:arg3];

[myObject doFooWith:arg1
               name:arg2 error:arg3];

[myObject doFooWith:arg1
          name:arg2  // aligning keywords instead of colons
          error:arg3];
</code><paragraph>As with declarations and definitions, when the first keyword is shorter than the others, indent the later lines by at least four spaces, maintaining colon alignment:</paragraph><code language="code">// GOOD:

[myObj short:arg1
          longKeyword:arg2
    evenLongerKeyword:arg3
                error:arg4];
</code><paragraph>Invocations containing multiple inlined blocks may have their parameter names left-aligned at a four space indent.</paragraph><heading level="3">Function Calls</heading><paragraph>Function calls should include as many parameters as fit on each line, except where shorter lines are needed for clarity or documentation of the parameters.</paragraph><paragraph>Continuation lines for function parameters may be indented to align with the opening parenthesis, or may have a four-space indent.</paragraph><code language="sql">// GOOD:

CFArrayRef array = CFArrayCreate(kCFAllocatorDefault, objects, numberOfObjects,
                                 &kCFTypeArrayCallBacks);

NSString *string = NSLocalizedStringWithDefaultValue(@"FEET", @"DistanceTable",
    resourceBundle,  @"%@ feet", @"Distance for multiple feet");

UpdateTally(scores[x] * y + bases[x],  // Score heuristic.
            x, y, z);

TransformImage(image,
               x1, x2, x3,
               y1, y2, y3,
               z1, z2, z3);
</code><paragraph>Use local variables with descriptive names to shorten function calls and reduce nesting of calls.</paragraph><code language="sql">// GOOD:

double scoreHeuristic = scores[x] * y + bases[x];
UpdateTally(scoreHeuristic, x, y, z);
</code><heading level="3">Exceptions</heading><paragraph>Format exceptions with @catch and @finally labels on the same line as the preceding }. Add a space between the @ label and the opening brace ({), as well as between the @catch and the caught object declaration. If you must use Objective-C exceptions, format them as follows. However, see Avoid Throwing Exceptions for reasons why you should not be using exceptions.</paragraph><code language="javascript">// GOOD:

@try {
  foo();
} @catch (NSException *ex) {
  bar(ex);
} @finally {
  baz();
}
</code><heading level="3">Function Length</heading><paragraph>Prefer small and focused functions.</paragraph><paragraph>Long functions and methods are occasionally appropriate, so no hard limit is placed on function length. If a function exceeds about 40 lines, think about whether it can be broken up without harming the structure of the program.</paragraph><paragraph>Even if your long function works perfectly now, someone modifying it in a few months may add new behavior. This could result in bugs that are hard to find. Keeping your functions short and simple makes it easier for other people to read and modify your code.</paragraph><paragraph>When updating legacy code, consider also breaking long functions into smaller and more manageable pieces.</paragraph><heading level="3">Vertical Whitespace</heading><paragraph>Use vertical whitespace sparingly.</paragraph><paragraph>To allow more code to be easily viewed on a screen, avoid putting blank lines just inside the braces of functions.</paragraph><paragraph>Limit blank lines to one or two between functions and between logical groups of code.</paragraph><heading level="2">Objective-C Style Exceptions</heading><heading level="3">Indicating style exceptions</heading><paragraph>Lines of code that are not expected to adhere to these style recommendations require // NOLINT at the end of the line or // NOLINTNEXTLINE at the end of the previous line. Sometimes it is required that parts of Objective-C code must ignore these style recommendations (for example code may be machine generated or code constructs are such that its not possible to style correctly).</paragraph><paragraph>A // NOLINT comment on that line or // NOLINTNEXTLINE on the previous line can be used to indicate to the reader that code is intentionally ignoring style guidelines. In addition these annotations can also be picked up by automated tools such as linters and handle code correctly. Note that there is a single space between // and NOLINT*.</paragraph></content>
</page>
<page url="https://google.github.io/styleguide/pyguide.html">
<title>styleguide | Style guides for Google-originated open-source projects</title>
<content><heading level="1">Google Python Style Guide</heading><heading level="2">1 Background</heading><paragraph>Python is the main dynamic language used at Google. This style guide is a list of dos and don'ts for Python programs.</paragraph><paragraph>To help you format code correctly, we've created a settings file for Vim. For Emacs, the default settings should be fine.</paragraph><paragraph>Many teams use the Black or Pyink auto-formatter to avoid arguing over formatting.</paragraph><heading level="2">2 Python Language Rules</heading><heading level="3">2.1 Lint</heading><paragraph>Run pylint over your code using this pylintrc.</paragraph><heading level="4">2.1.1 Definition</heading><paragraph>pylint is a tool for finding bugs and style problems in Python source code. It finds problems that are typically caught by a compiler for less dynamic languages like C and C++. Because of the dynamic nature of Python, some warnings may be incorrect; however, spurious warnings should be fairly infrequent.</paragraph><heading level="4">2.1.2 Pros</heading><paragraph>Catches easy-to-miss errors like typos, using-vars-before-assignment, etc.</paragraph><heading level="4">2.1.3 Cons</heading><paragraph>pylint isn't perfect. To take advantage of it, sometimes we'll need to write around it, suppress its warnings or fix it.</paragraph><heading level="4">2.1.4 Decision</heading><paragraph>Make sure you run pylint on your code.</paragraph><paragraph>Suppress warnings if they are inappropriate so that other issues are not hidden. To suppress warnings, you can set a line-level comment:</paragraph><code language="python">def do_PUT(self):  # WSGI name, so pylint: disable=invalid-name
  ...
</code><paragraph>pylint warnings are each identified by symbolic name (empty-docstring) Google-specific warnings start with g-.</paragraph><paragraph>If the reason for the suppression is not clear from the symbolic name, add an explanation.</paragraph><paragraph>Suppressing in this way has the advantage that we can easily search for suppressions and revisit them.</paragraph><paragraph>You can get a list of pylint warnings by doing:</paragraph><paragraph>To get more information on a particular message, use:</paragraph><code language="code">pylint --help-msg=invalid-name
</code><paragraph>Prefer pylint: disable to the deprecated older form pylint: disable-msg.</paragraph><paragraph>Unused argument warnings can be suppressed by deleting the variables at the beginning of the function. Always include a comment explaining why you are deleting it. "Unused." is sufficient. For example:</paragraph><code language="python">def viking_cafe_order(spam: str, beans: str, eggs: str | None = None) -> str:
    del beans, eggs  # Unused by vikings.
    return spam + spam + spam
</code><paragraph>Other common forms of suppressing this warning include using '_' as the identifier for the unused argument or prefixing the argument name with 'unused_', or assigning them to '_'. These forms are allowed but no longer encouraged. These break callers that pass arguments by name and do not enforce that the arguments are actually unused.</paragraph><heading level="3">2.2 Imports</heading><paragraph>Use import statements for packages and modules only, not for individual types, classes, or functions.</paragraph><heading level="4">2.2.1 Definition</heading><paragraph>Reusability mechanism for sharing code from one module to another.</paragraph><heading level="4">2.2.2 Pros</heading><paragraph>The namespace management convention is simple. The source of each identifier is indicated in a consistent way; x.Obj says that object Obj is defined in module x.</paragraph><heading level="4">2.2.3 Cons</heading><paragraph>Module names can still collide. Some module names are inconveniently long.</paragraph><heading level="4">2.2.4 Decision</heading><list type="ul"><item>Use import x for importing packages and modules.</item><item>Use from x import y where x is the package prefix and y is the module name with no prefix.</item><item>Use from x import y as z in any of the following circumstances: Two modules named y are to be imported. y conflicts with a top-level name defined in the current module. y conflicts with a common parameter name that is part of the public API (e.g., features). y is an inconveniently long name. y is too generic in the context of your code (e.g., from storage.file_system import options as fs_options).</item><item>Use import y as z only when z is a standard abbreviation (e.g., import numpy as np).</item></list><list type="ul"><item>Two modules named y are to be imported.</item><item>y conflicts with a top-level name defined in the current module.</item><item>y conflicts with a common parameter name that is part of the public API (e.g., features).</item><item>y is an inconveniently long name.</item><item>y is too generic in the context of your code (e.g., from storage.file_system import options as fs_options).</item></list><paragraph>For example the module sound.effects.echo may be imported as follows:</paragraph><code language="code">from sound.effects import echo
...
echo.EchoFilter(input, output, delay=0.7, atten=4)
</code><paragraph>Do not use relative names in imports. Even if the module is in the same package, use the full package name. This helps prevent unintentionally importing a package twice.</paragraph><heading level="5">2.2.4.1 Exemptions</heading><paragraph>Exemptions from this rule:</paragraph><list type="ul"><item>Symbols from the following modules are used to support static analysis and type checking:</item><item>Redirects from the six.moves module.</item></list><heading level="3">2.3 Packages</heading><paragraph>Import each module using the full pathname location of the module.</paragraph><heading level="4">2.3.1 Pros</heading><paragraph>Avoids conflicts in module names or incorrect imports due to the module search path not being what the author expected. Makes it easier to find modules.</paragraph><heading level="4">2.3.2 Cons</heading><paragraph>Makes it harder to deploy code because you have to replicate the package hierarchy. Not really a problem with modern deployment mechanisms.</paragraph><heading level="4">2.3.3 Decision</heading><paragraph>All new code should import each module by its full package name.</paragraph><paragraph>Imports should be as follows:</paragraph><code language="javascript">Yes:
  # Reference absl.flags in code with the complete name (verbose).
  import absl.flags
  from doctor.who import jodie

  _FOO = absl.flags.DEFINE_string(...)
</code><code language="python">Yes:
  # Reference flags in code with just the module name (common).
  from absl import flags
  from doctor.who import jodie

  _FOO = flags.DEFINE_string(...)
</code><paragraph>(assume this file lives in doctor/who/ where jodie.py also exists)</paragraph><code language="javascript">No:
  # Unclear what module the author wanted and what will be imported.  The actual
  # import behavior depends on external factors controlling sys.path.
  # Which possible jodie module did the author intend to import?
  import jodie
</code><paragraph>The directory the main binary is located in should not be assumed to be in sys.path despite that happening in some environments. This being the case, code should assume that import jodie refers to a third-party or top-level package named jodie, not a local jodie.py.</paragraph><heading level="3">2.4 Exceptions</heading><paragraph>Exceptions are allowed but must be used carefully.</paragraph><heading level="4">2.4.1 Definition</heading><paragraph>Exceptions are a means of breaking out of normal control flow to handle errors or other exceptional conditions.</paragraph><heading level="4">2.4.2 Pros</heading><paragraph>The control flow of normal operation code is not cluttered by error-handling code. It also allows the control flow to skip multiple frames when a certain condition occurs, e.g., returning from N nested functions in one step instead of having to plumb error codes through.</paragraph><heading level="4">2.4.3 Cons</heading><paragraph>May cause the control flow to be confusing. Easy to miss error cases when making library calls.</paragraph><heading level="4">2.4.4 Decision</heading><paragraph>Exceptions must follow certain conditions:</paragraph><list type="ul"><item>Make use of built-in exception classes when it makes sense. For example, raise a ValueError to indicate a programming mistake like a violated precondition, such as may happen when validating function arguments.</item><item>Do not use assert statements in place of conditionals or validating preconditions. They must not be critical to the application logic. A litmus test would be that the assert could be removed without breaking the code. assert conditionals are not guaranteed to be evaluated. For pytest based tests, assert is okay and expected to verify expectations. For example: Yes: def connect_to_next_port(self, minimum: int) -> int: """Connects to the next available port. Args: minimum: A port value greater or equal to 1024. Returns: The new minimum port. Raises: ConnectionError: If no available port is found. """ if minimum < 1024: # Note that this raising of ValueError is not mentioned in the doc # string's "Raises:" section because it is not appropriate to # guarantee this specific behavioral reaction to API misuse. raise ValueError(f'Min. port must be at least 1024, not {minimum}.') port = self._find_next_open_port(minimum) if port is None: raise ConnectionError( f'Could not connect to service on port {minimum} or higher.') # The code does not depend on the result of this assert. assert port >= minimum, ( f'Unexpected port {port} when minimum was {minimum}.') return port No: def connect_to_next_port(self, minimum: int) -> int: """Connects to the next available port. Args: minimum: A port value greater or equal to 1024. Returns: The new minimum port. """ assert minimum >= 1024, 'Minimum port must be at least 1024.' # The following code depends on the previous assert. port = self._find_next_open_port(minimum) assert port is not None # The type checking of the return statement relies on the assert. return port</item><item>Libraries or packages may define their own exceptions. When doing so they must inherit from an existing exception class. Exception names should end in Error and should not introduce repetition (foo.FooError).</item><item>Never use catch-all except: statements, or catch Exception or StandardError, unless you are re-raising the exception, or creating an isolation point in the program where exceptions are not propagated but are recorded and suppressed instead, such as protecting a thread from crashing by guarding its outermost block. Python is very tolerant in this regard and except: will really catch everything including misspelled names, sys.exit() calls, Ctrl+C interrupts, unittest failures and all kinds of other exceptions that you simply don't want to catch.</item><item>Minimize the amount of code in a try/except block. The larger the body of the try, the more likely that an exception will be raised by a line of code that you didn't expect to raise an exception. In those cases, the try/except block hides a real error.</item><item>Use the finally clause to execute code whether or not an exception is raised in the try block. This is often useful for cleanup, i.e., closing a file.</item></list><paragraph>Make use of built-in exception classes when it makes sense. For example, raise a ValueError to indicate a programming mistake like a violated precondition, such as may happen when validating function arguments.</paragraph><paragraph>Do not use assert statements in place of conditionals or validating preconditions. They must not be critical to the application logic. A litmus test would be that the assert could be removed without breaking the code. assert conditionals are not guaranteed to be evaluated. For pytest based tests, assert is okay and expected to verify expectations. For example:</paragraph><code language="python">Yes:
  def connect_to_next_port(self, minimum: int) -> int:
    """Connects to the next available port.

    Args:
      minimum: A port value greater or equal to 1024.

    Returns:
      The new minimum port.

    Raises:
      ConnectionError: If no available port is found.
    """
    if minimum < 1024:
      # Note that this raising of ValueError is not mentioned in the doc
      # string's "Raises:" section because it is not appropriate to
      # guarantee this specific behavioral reaction to API misuse.
      raise ValueError(f'Min. port must be at least 1024, not {minimum}.')
    port = self._find_next_open_port(minimum)
    if port is None:
      raise ConnectionError(
          f'Could not connect to service on port {minimum} or higher.')
    # The code does not depend on the result of this assert.
    assert port >= minimum, (
        f'Unexpected port {port} when minimum was {minimum}.')
    return port
</code><code language="python">No:
  def connect_to_next_port(self, minimum: int) -> int:
    """Connects to the next available port.

    Args:
      minimum: A port value greater or equal to 1024.

    Returns:
      The new minimum port.
    """
    assert minimum >= 1024, 'Minimum port must be at least 1024.'
    # The following code depends on the previous assert.
    port = self._find_next_open_port(minimum)
    assert port is not None
    # The type checking of the return statement relies on the assert.
    return port
</code><paragraph>Libraries or packages may define their own exceptions. When doing so they must inherit from an existing exception class. Exception names should end in Error and should not introduce repetition (foo.FooError).</paragraph><paragraph>Never use catch-all except: statements, or catch Exception or StandardError, unless you are</paragraph><list type="ul"><item>re-raising the exception, or</item><item>creating an isolation point in the program where exceptions are not propagated but are recorded and suppressed instead, such as protecting a thread from crashing by guarding its outermost block.</item></list><paragraph>Python is very tolerant in this regard and except: will really catch everything including misspelled names, sys.exit() calls, Ctrl+C interrupts, unittest failures and all kinds of other exceptions that you simply don't want to catch.</paragraph><paragraph>Minimize the amount of code in a try/except block. The larger the body of the try, the more likely that an exception will be raised by a line of code that you didn't expect to raise an exception. In those cases, the try/except block hides a real error.</paragraph><paragraph>Use the finally clause to execute code whether or not an exception is raised in the try block. This is often useful for cleanup, i.e., closing a file.</paragraph><heading level="3">2.5 Mutable Global State</heading><paragraph>Avoid mutable global state.</paragraph><heading level="4">2.5.1 Definition</heading><paragraph>Module-level values or class attributes that can get mutated during program execution.</paragraph><heading level="4">2.5.2 Pros</heading><paragraph>Occasionally useful.</paragraph><heading level="4">2.5.3 Cons</heading><list type="ul"><item>Breaks encapsulation: Such design can make it hard to achieve valid objectives. For example, if global state is used to manage a database connection, then connecting to two different databases at the same time (such as for computing differences during a migration) becomes difficult. Similar problems easily arise with global registries.</item><item>Has the potential to change module behavior during the import, because assignments to global variables are done when the module is first imported.</item></list><paragraph>Breaks encapsulation: Such design can make it hard to achieve valid objectives. For example, if global state is used to manage a database connection, then connecting to two different databases at the same time (such as for computing differences during a migration) becomes difficult. Similar problems easily arise with global registries.</paragraph><paragraph>Has the potential to change module behavior during the import, because assignments to global variables are done when the module is first imported.</paragraph><heading level="4">2.5.4 Decision</heading><paragraph>Avoid mutable global state.</paragraph><paragraph>In those rare cases where using global state is warranted, mutable global entities should be declared at the module level or as a class attribute and made internal by prepending an _ to the name. If necessary, external access to mutable global state must be done through public functions or class methods. See Naming below. Please explain the design reasons why mutable global state is being used in a comment or a doc linked to from a comment.</paragraph><paragraph>Module-level constants are permitted and encouraged. For example: _MAX_HOLY_HANDGRENADE_COUNT = 3 for an internal use constant or SIR_LANCELOTS_FAVORITE_COLOR = "blue" for a public API constant. Constants must be named using all caps with underscores. See Naming below.</paragraph><heading level="3">2.6 Nested/Local/Inner Classes and Functions</heading><paragraph>Nested local functions or classes are fine when used to close over a local variable. Inner classes are fine.</paragraph><heading level="4">2.6.1 Definition</heading><paragraph>A class can be defined inside of a method, function, or class. A function can be defined inside a method or function. Nested functions have read-only access to variables defined in enclosing scopes.</paragraph><heading level="4">2.6.2 Pros</heading><paragraph>Allows definition of utility classes and functions that are only used inside of a very limited scope. Very ADT-y. Commonly used for implementing decorators.</paragraph><heading level="4">2.6.3 Cons</heading><paragraph>Nested functions and classes cannot be directly tested. Nesting can make the outer function longer and less readable.</paragraph><heading level="4">2.6.4 Decision</heading><paragraph>They are fine with some caveats. Avoid nested functions or classes except when closing over a local value other than self or cls. Do not nest a function just to hide it from users of a module. Instead, prefix its name with an _ at the module level so that it can still be accessed by tests.</paragraph><heading level="3">2.7 Comprehensions & Generator Expressions</heading><paragraph>Okay to use for simple cases.</paragraph><heading level="4">2.7.1 Definition</heading><paragraph>List, Dict, and Set comprehensions as well as generator expressions provide a concise and efficient way to create container types and iterators without resorting to the use of traditional loops, map(), filter(), or lambda.</paragraph><heading level="4">2.7.2 Pros</heading><paragraph>Simple comprehensions can be clearer and simpler than other dict, list, or set creation techniques. Generator expressions can be very efficient, since they avoid the creation of a list entirely.</paragraph><heading level="4">2.7.3 Cons</heading><paragraph>Complicated comprehensions or generator expressions can be hard to read.</paragraph><heading level="4">2.7.4 Decision</heading><paragraph>Comprehensions are allowed, however multiple for clauses or filter expressions are not permitted. Optimize for readability, not conciseness.</paragraph><code language="javascript">Yes:
  result = [mapping_expr for value in iterable if filter_expr]

  result = [
      is_valid(metric={'key': value})
      for value in interesting_iterable
      if a_longer_filter_expression(value)
  ]

  descriptive_name = [
      transform({'key': key, 'value': value}, color='black')
      for key, value in generate_iterable(some_input)
      if complicated_condition_is_met(key, value)
  ]

  result = []
  for x in range(10):
    for y in range(5):
      if x * y > 10:
        result.append((x, y))

  return {
      x: complicated_transform(x)
      for x in long_generator_function(parameter)
      if x is not None
  }

  return (x**2 for x in range(10))

  unique_names = {user.name for user in users if user is not None}
</code><code language="code">No:
  result = [(x, y) for x in range(10) for y in range(5) if x * y > 10]

  return (
      (x, y, z)
      for x in range(5)
      for y in range(5)
      if x != y
      for z in range(5)
      if y != z
  )
</code><heading level="3">2.8 Default Iterators and Operators</heading><paragraph>Use default iterators and operators for types that support them, like lists, dictionaries, and files.</paragraph><heading level="4">2.8.1 Definition</heading><paragraph>Container types, like dictionaries and lists, define default iterators and membership test operators ("in" and "not in").</paragraph><heading level="4">2.8.2 Pros</heading><paragraph>The default iterators and operators are simple and efficient. They express the operation directly, without extra method calls. A function that uses default operators is generic. It can be used with any type that supports the operation.</paragraph><heading level="4">2.8.3 Cons</heading><paragraph>You can't tell the type of objects by reading the method names (unless the variable has type annotations). This is also an advantage.</paragraph><heading level="4">2.8.4 Decision</heading><paragraph>Use default iterators and operators for types that support them, like lists, dictionaries, and files. The built-in types define iterator methods, too. Prefer these methods to methods that return lists, except that you should not mutate a container while iterating over it.</paragraph><code language="code">Yes:  for key in adict: ...
      if obj in alist: ...
      for line in afile: ...
      for k, v in adict.items(): ...
</code><code language="code">No:   for key in adict.keys(): ...
      for line in afile.readlines(): ...
</code><heading level="3">2.9 Generators</heading><paragraph>Use generators as needed.</paragraph><heading level="4">2.9.1 Definition</heading><paragraph>A generator function returns an iterator that yields a value each time it executes a yield statement. After it yields a value, the runtime state of the generator function is suspended until the next value is needed.</paragraph><heading level="4">2.9.2 Pros</heading><paragraph>Simpler code, because the state of local variables and control flow are preserved for each call. A generator uses less memory than a function that creates an entire list of values at once.</paragraph><heading level="4">2.9.3 Cons</heading><paragraph>Local variables in the generator will not be garbage collected until the generator is either consumed to exhaustion or itself garbage collected.</paragraph><heading level="4">2.9.4 Decision</heading><paragraph>Fine. Use "Yields:" rather than "Returns:" in the docstring for generator functions.</paragraph><paragraph>If the generator manages an expensive resource, make sure to force the clean up.</paragraph><paragraph>A good way to do the clean up is by wrapping the generator with a context manager PEP-0533.</paragraph><heading level="3">2.10 Lambda Functions</heading><paragraph>Okay for one-liners. Prefer generator expressions over map() or filter() with a lambda.</paragraph><heading level="4">2.10.1 Definition</heading><paragraph>Lambdas define anonymous functions in an expression, as opposed to a statement.</paragraph><heading level="4">2.10.2 Pros</heading><paragraph>Convenient.</paragraph><heading level="4">2.10.3 Cons</heading><paragraph>Harder to read and debug than local functions. The lack of names means stack traces are more difficult to understand. Expressiveness is limited because the function may only contain an expression.</paragraph><heading level="4">2.10.4 Decision</heading><paragraph>Lambdas are allowed. If the code inside the lambda function spans multiple lines or is longer than 60-80 chars, it might be better to define it as a regular nested function.</paragraph><paragraph>For common operations like multiplication, use the functions from the operator module instead of lambda functions. For example, prefer operator.mul to lambda x, y: x * y.</paragraph><heading level="3">2.11 Conditional Expressions</heading><paragraph>Okay for simple cases.</paragraph><heading level="4">2.11.1 Definition</heading><paragraph>Conditional expressions (sometimes called a "ternary operator") are mechanisms that provide a shorter syntax for if statements. For example: x = 1 if cond else 2.</paragraph><heading level="4">2.11.2 Pros</heading><paragraph>Shorter and more convenient than an if statement.</paragraph><heading level="4">2.11.3 Cons</heading><paragraph>May be harder to read than an if statement. The condition may be difficult to locate if the expression is long.</paragraph><heading level="4">2.11.4 Decision</heading><paragraph>Okay to use for simple cases. Each portion must fit on one line: true-expression, if-expression, else-expression. Use a complete if statement when things get more complicated.</paragraph><code language="code">Yes:
    one_line = 'yes' if predicate(value) else 'no'
    slightly_split = ('yes' if predicate(value)
                      else 'no, nein, nyet')
    the_longest_ternary_style_that_can_be_done = (
        'yes, true, affirmative, confirmed, correct'
        if predicate(value)
        else 'no, false, negative, nay')
</code><code language="code">No:
    bad_line_breaking = ('yes' if predicate(value) else
                         'no')
    portion_too_long = ('yes'
                        if some_long_module.some_long_predicate_function(
                            really_long_variable_name)
                        else 'no, false, negative, nay')
</code><heading level="3">2.12 Default Argument Values</heading><paragraph>Okay in most cases.</paragraph><heading level="4">2.12.1 Definition</heading><paragraph>You can specify values for variables at the end of a function's parameter list, e.g., def foo(a, b=0):. If foo is called with only one argument, b is set to 0. If it is called with two arguments, b has the value of the second argument.</paragraph><heading level="4">2.12.2 Pros</heading><paragraph>Often you have a function that uses lots of default values, but on rare occasions you want to override the defaults. Default argument values provide an easy way to do this, without having to define lots of functions for the rare exceptions. As Python does not support overloaded methods/functions, default arguments are an easy way of "faking" the overloading behavior.</paragraph><heading level="4">2.12.3 Cons</heading><paragraph>Default arguments are evaluated once at module load time. This may cause problems if the argument is a mutable object such as a list or a dictionary. If the function modifies the object (e.g., by appending an item to a list), the default value is modified.</paragraph><heading level="4">2.12.4 Decision</heading><paragraph>Okay to use with the following caveat:</paragraph><paragraph>Do not use mutable objects as default values in the function or method definition.</paragraph><code language="python">Yes: def foo(a, b=None):
         if b is None:
             b = []
Yes: def foo(a, b: Sequence | None = None):
         if b is None:
             b = []
Yes: def foo(a, b: Sequence = ()):  # Empty tuple OK since tuples are immutable.
         ...
</code><code language="python">from absl import flags
_FOO = flags.DEFINE_string(...)

No:  def foo(a, b=[]):
         ...
No:  def foo(a, b=time.time()):  # Is `b` supposed to represent when this module was loaded?
         ...
No:  def foo(a, b=_FOO.value):  # sys.argv has not yet been parsed...
         ...
No:  def foo(a, b: Mapping = {}):  # Could still get passed to unchecked code.
         ...
</code><heading level="3">2.13 Properties</heading><paragraph>Properties may be used to control getting or setting attributes that require trivial computations or logic. Property implementations must match the general expectations of regular attribute access: that they are cheap, straightforward, and unsurprising.</paragraph><heading level="4">2.13.1 Definition</heading><paragraph>A way to wrap method calls for getting and setting an attribute as a standard attribute access.</paragraph><heading level="4">2.13.2 Pros</heading><list type="ul"><item>Allows for an attribute access and assignment API rather than getter and setter method calls.</item><item>Can be used to make an attribute read-only.</item><item>Allows calculations to be lazy.</item><item>Provides a way to maintain the public interface of a class when the internals evolve independently of class users.</item></list><heading level="4">2.13.3 Cons</heading><list type="ul"><item>Can hide side-effects much like operator overloading.</item><item>Can be confusing for subclasses.</item></list><heading level="4">2.13.4 Decision</heading><paragraph>Properties are allowed, but, like operator overloading, should only be used when necessary and match the expectations of typical attribute access; follow the getters and setters rules otherwise.</paragraph><paragraph>For example, using a property to simply both get and set an internal attribute isn't allowed: there is no computation occurring, so the property is unnecessary (make the attribute public instead). In comparison, using a property to control attribute access or to calculate a trivially derived value is allowed: the logic is simple and unsurprising.</paragraph><paragraph>Properties should be created with the @property decorator. Manually implementing a property descriptor is considered a power feature.</paragraph><paragraph>Inheritance with properties can be non-obvious. Do not use properties to implement computations a subclass may ever want to override and extend.</paragraph><heading level="3">2.14 True/False Evaluations</heading><paragraph>Use the "implicit" false if at all possible (with a few caveats).</paragraph><heading level="4">2.14.1 Definition</heading><paragraph>Python evaluates certain values as False when in a boolean context. A quick "rule of thumb" is that all "empty" values are considered false, so 0, None, [], {}, '' all evaluate as false in a boolean context.</paragraph><heading level="4">2.14.2 Pros</heading><paragraph>Conditions using Python booleans are easier to read and less error-prone. In most cases, they're also faster.</paragraph><heading level="4">2.14.3 Cons</heading><paragraph>May look strange to C/C++ developers.</paragraph><heading level="4">2.14.4 Decision</heading><paragraph>Use the "implicit" false if possible, e.g., if foo: rather than if foo != []:. There are a few caveats that you should keep in mind though:</paragraph><list type="ul"><item>Always use if foo is None: (or is not None) to check for a None value. E.g., when testing whether a variable or argument that defaults to None was set to some other value. The other value might be a value that's false in a boolean context!</item><item>Never compare a boolean variable to False using ==. Use if not x: instead. If you need to distinguish False from None then chain the expressions, such as if not x and x is not None:.</item><item>For sequences (strings, lists, tuples), use the fact that empty sequences are false, so if seq: and if not seq: are preferable to if len(seq): and if not len(seq): respectively.</item><item>When handling integers, implicit false may involve more risk than benefit (i.e., accidentally handling None as 0). You may compare a value which is known to be an integer (and is not the result of len()) against the integer 0. Yes: if not users: print('no users') if i % 10 == 0: self.handle_multiple_of_ten() def f(x=None): if x is None: x = [] No: if len(users) == 0: print('no users') if not i % 10: self.handle_multiple_of_ten() def f(x=None): x = x or []</item><item>Note that '0' (i.e., 0 as string) evaluates to true.</item><item>Note that Numpy arrays may raise an exception in an implicit boolean context. Prefer the .size attribute when testing emptiness of a np.array (e.g. if not users.size).</item></list><paragraph>Always use if foo is None: (or is not None) to check for a None value. E.g., when testing whether a variable or argument that defaults to None was set to some other value. The other value might be a value that's false in a boolean context!</paragraph><paragraph>Never compare a boolean variable to False using ==. Use if not x: instead. If you need to distinguish False from None then chain the expressions, such as if not x and x is not None:.</paragraph><paragraph>For sequences (strings, lists, tuples), use the fact that empty sequences are false, so if seq: and if not seq: are preferable to if len(seq): and if not len(seq): respectively.</paragraph><paragraph>When handling integers, implicit false may involve more risk than benefit (i.e., accidentally handling None as 0). You may compare a value which is known to be an integer (and is not the result of len()) against the integer 0.</paragraph><code language="python">Yes: if not users:
         print('no users')

     if i % 10 == 0:
         self.handle_multiple_of_ten()

     def f(x=None):
         if x is None:
             x = []
</code><code language="python">No:  if len(users) == 0:
         print('no users')

     if not i % 10:
         self.handle_multiple_of_ten()

     def f(x=None):
         x = x or []
</code><paragraph>Note that '0' (i.e., 0 as string) evaluates to true.</paragraph><paragraph>Note that Numpy arrays may raise an exception in an implicit boolean context. Prefer the .size attribute when testing emptiness of a np.array (e.g. if not users.size).</paragraph><heading level="3">2.16 Lexical Scoping</heading><paragraph>Okay to use.</paragraph><heading level="4">2.16.1 Definition</heading><paragraph>A nested Python function can refer to variables defined in enclosing functions, but cannot assign to them. Variable bindings are resolved using lexical scoping, that is, based on the static program text. Any assignment to a name in a block will cause Python to treat all references to that name as a local variable, even if the use precedes the assignment. If a global declaration occurs, the name is treated as a global variable.</paragraph><paragraph>An example of the use of this feature is:</paragraph><code language="python">def get_adder(summand1: float) -> Callable[[float], float]:
    """Returns a function that adds numbers to a given number."""
    def adder(summand2: float) -> float:
        return summand1 + summand2

    return adder
</code><heading level="4">2.16.2 Pros</heading><paragraph>Often results in clearer, more elegant code. Especially comforting to experienced Lisp and Scheme (and Haskell and ML and …) programmers.</paragraph><heading level="4">2.16.3 Cons</heading><paragraph>Can lead to confusing bugs, such as this example based on PEP-0227:</paragraph><code language="python">i = 4
def foo(x: Iterable[int]):
    def bar():
        print(i, end='')
    # ...
    # A bunch of code here
    # ...
    for i in x:  # Ah, i *is* local to foo, so this is what bar sees
        print(i, end='')
    bar()
</code><paragraph>So foo([1, 2, 3]) will print 1 2 3 3, not 1 2 3 4.</paragraph><heading level="4">2.16.4 Decision</heading><paragraph>Okay to use.</paragraph><heading level="3">2.17 Function and Method Decorators</heading><paragraph>Use decorators judiciously when there is a clear advantage. Avoid staticmethod and limit use of classmethod.</paragraph><heading level="4">2.17.1 Definition</heading><paragraph>Decorators for Functions and Methods (a.k.a "the @ notation"). One common decorator is @property, used for converting ordinary methods into dynamically computed attributes. However, the decorator syntax allows for user-defined decorators as well. Specifically, for some function my_decorator, this:</paragraph><code language="python">class C:
    @my_decorator
    def method(self):
        # method body ...
</code><paragraph>is equivalent to:</paragraph><code language="python">class C:
    def method(self):
        # method body ...
    method = my_decorator(method)
</code><heading level="4">2.17.2 Pros</heading><paragraph>Elegantly specifies some transformation on a method; the transformation might eliminate some repetitive code, enforce invariants, etc.</paragraph><heading level="4">2.17.3 Cons</heading><paragraph>Decorators can perform arbitrary operations on a function's arguments or return values, resulting in surprising implicit behavior. Additionally, decorators execute at object definition time. For module-level objects (classes, module functions, …) this happens at import time. Failures in decorator code are pretty much impossible to recover from.</paragraph><heading level="4">2.17.4 Decision</heading><paragraph>Use decorators judiciously when there is a clear advantage. Decorators should follow the same import and naming guidelines as functions. A decorator docstring should clearly state that the function is a decorator. Write unit tests for decorators.</paragraph><paragraph>Avoid external dependencies in the decorator itself (e.g. don't rely on files, sockets, database connections, etc.), since they might not be available when the decorator runs (at import time, perhaps from pydoc or other tools). A decorator that is called with valid parameters should (as much as possible) be guaranteed to succeed in all cases.</paragraph><paragraph>Decorators are a special case of "top-level code" - see main for more discussion.</paragraph><paragraph>Never use staticmethod unless forced to in order to integrate with an API defined in an existing library. Write a module-level function instead.</paragraph><paragraph>Use classmethod only when writing a named constructor, or a class-specific routine that modifies necessary global state such as a process-wide cache.</paragraph><heading level="3">2.18 Threading</heading><paragraph>Do not rely on the atomicity of built-in types.</paragraph><paragraph>While Python's built-in data types such as dictionaries appear to have atomic operations, there are corner cases where they aren't atomic (e.g. if __hash__ or __eq__ are implemented as Python methods) and their atomicity should not be relied upon. Neither should you rely on atomic variable assignment (since this in turn depends on dictionaries).</paragraph><paragraph>Use the queue module's Queue data type as the preferred way to communicate data between threads. Otherwise, use the threading module and its locking primitives. Prefer condition variables and threading.Condition instead of using lower-level locks.</paragraph><heading level="3">2.19 Power Features</heading><paragraph>Avoid these features.</paragraph><heading level="4">2.19.1 Definition</heading><paragraph>Python is an extremely flexible language and gives you many fancy features such as custom metaclasses, access to bytecode, on-the-fly compilation, dynamic inheritance, object reparenting, import hacks, reflection (e.g. some uses of getattr()), modification of system internals, __del__ methods implementing customized cleanup, etc.</paragraph><heading level="4">2.19.2 Pros</heading><paragraph>These are powerful language features. They can make your code more compact.</paragraph><heading level="4">2.19.3 Cons</heading><paragraph>It's very tempting to use these "cool" features when they're not absolutely necessary. It's harder to read, understand, and debug code that's using unusual features underneath. It doesn't seem that way at first (to the original author), but when revisiting the code, it tends to be more difficult than code that is longer but is straightforward.</paragraph><heading level="4">2.19.4 Decision</heading><paragraph>Avoid these features in your code.</paragraph><paragraph>Standard library modules and classes that internally use these features are okay to use (for example, abc.ABCMeta, dataclasses, and enum).</paragraph><heading level="3">2.20 Modern Python: from __future__ imports</heading><paragraph>New language version semantic changes may be gated behind a special future import to enable them on a per-file basis within earlier runtimes.</paragraph><heading level="4">2.20.1 Definition</heading><paragraph>Being able to turn on some of the more modern features via from __future__ import statements allows early use of features from expected future Python versions.</paragraph><heading level="4">2.20.2 Pros</heading><paragraph>This has proven to make runtime version upgrades smoother as changes can be made on a per-file basis while declaring compatibility and preventing regressions within those files. Modern code is more maintainable as it is less likely to accumulate technical debt that will be problematic during future runtime upgrades.</paragraph><heading level="4">2.20.3 Cons</heading><paragraph>Such code may not work on very old interpreter versions prior to the introduction of the needed future statement. The need for this is more common in projects supporting an extremely wide variety of environments.</paragraph><heading level="4">2.20.4 Decision</heading><heading level="5">from __future__ imports</heading><paragraph>Use of from __future__ import statements is encouraged. It allows a given source file to start using more modern Python syntax features today. Once you no longer need to run on a version where the features are hidden behind a __future__ import, feel free to remove those lines.</paragraph><paragraph>In code that may execute on versions as old as 3.5 rather than >= 3.7, import:</paragraph><code language="python">from __future__ import generator_stop
</code><paragraph>For more information read the Python future statement definitions documentation.</paragraph><paragraph>Please don't remove these imports until you are confident the code is only ever used in a sufficiently modern environment. Even if you do not currently use the feature a specific future import enables in your code today, keeping it in place in the file prevents later modifications of the code from inadvertently depending on the older behavior.</paragraph><paragraph>Use other from __future__ import statements as you see fit.</paragraph><heading level="3">2.21 Type Annotated Code</heading><paragraph>You can annotate Python code with type hints. Type-check the code at build time with a type checking tool like pytype. In most cases, when feasible, type annotations are in source files. For third-party or extension modules, annotations can be in stub .pyi files.</paragraph><heading level="4">2.21.1 Definition</heading><paragraph>Type annotations (or "type hints") are for function or method arguments and return values:</paragraph><code language="python">def func(a: int) -> list[int]:
</code><paragraph>You can also declare the type of a variable using similar syntax:</paragraph><code language="code">a: SomeType = some_func()
</code><heading level="4">2.21.2 Pros</heading><paragraph>Type annotations improve the readability and maintainability of your code. The type checker will convert many runtime errors to build-time errors, and reduce your ability to use Power Features.</paragraph><heading level="4">2.21.3 Cons</heading><paragraph>You will have to keep the type declarations up to date. You might see type errors that you think are valid code. Use of a type checker may reduce your ability to use Power Features.</paragraph><heading level="4">2.21.4 Decision</heading><paragraph>You are strongly encouraged to enable Python type analysis when updating code. When adding or modifying public APIs, include type annotations and enable checking via pytype in the build system. As static analysis is relatively new to Python, we acknowledge that undesired side-effects (such as wrongly inferred types) may prevent adoption by some projects. In those situations, authors are encouraged to add a comment with a TODO or link to a bug describing the issue(s) currently preventing type annotation adoption in the BUILD file or in the code itself as appropriate.</paragraph><heading level="2">3 Python Style Rules</heading><heading level="3">3.1 Semicolons</heading><paragraph>Do not terminate your lines with semicolons, and do not use semicolons to put two statements on the same line.</paragraph><heading level="3">3.2 Line length</heading><paragraph>Maximum line length is 80 characters.</paragraph><paragraph>Explicit exceptions to the 80 character limit:</paragraph><list type="ul"><item>Long import statements.</item><item>URLs, pathnames, or long flags in comments.</item><item>Long string module-level constants not containing whitespace that would be inconvenient to split across lines such as URLs or pathnames. Pylint disable comments. (e.g.: # pylint: disable=invalid-name)</item></list><list type="ul"><item>Pylint disable comments. (e.g.: # pylint: disable=invalid-name)</item></list><paragraph>Do not use a backslash for explicit line continuation.</paragraph><paragraph>Instead, make use of Python's implicit line joining inside parentheses, brackets and braces. If necessary, you can add an extra pair of parentheses around an expression.</paragraph><paragraph>Note that this rule doesn't prohibit backslash-escaped newlines within strings (see below).</paragraph><code language="code">Yes: foo_bar(self, width, height, color='black', design=None, x='foo',
             emphasis=None, highlight=0)
</code><code language="code">
Yes: if (width == 0 and height == 0 and
         color == 'red' and emphasis == 'strong'):

     (bridge_questions.clarification_on
      .average_airspeed_of.unladen_swallow) = 'African or European?'

     with (
         very_long_first_expression_function() as spam,
         very_long_second_expression_function() as beans,
         third_thing() as eggs,
     ):
       place_order(eggs, beans, spam, beans)
</code><code language="code">
No:  if width == 0 and height == 0 and \
         color == 'red' and emphasis == 'strong':

     bridge_questions.clarification_on \
         .average_airspeed_of.unladen_swallow = 'African or European?'

     with very_long_first_expression_function() as spam, \
           very_long_second_expression_function() as beans, \
           third_thing() as eggs:
       place_order(eggs, beans, spam, beans)
</code><paragraph>When a literal string won't fit on a single line, use parentheses for implicit line joining.</paragraph><code language="code">x = ('This will build a very long long '
     'long long long long long long string')
</code><paragraph>Prefer to break lines at the highest possible syntactic level. If you must break a line twice, break it at the same syntactic level both times.</paragraph><code language="code">Yes: bridgekeeper.answer(
         name="Arthur", quest=questlib.find(owner="Arthur", perilous=True))

     answer = (a_long_line().of_chained_methods()
               .that_eventually_provides().an_answer())

     if (
         config is None
         or 'editor.language' not in config
         or config['editor.language'].use_spaces is False
     ):
       use_tabs()
</code><code language="code">No: bridgekeeper.answer(name="Arthur", quest=questlib.find(
        owner="Arthur", perilous=True))

    answer = a_long_line().of_chained_methods().that_eventually_provides(
        ).an_answer()

    if (config is None or 'editor.language' not in config or config[
        'editor.language'].use_spaces is False):
      use_tabs()

</code><paragraph>Within comments, put long URLs on their own line if necessary.</paragraph><code language="code">Yes:  # See details at
      # http://www.example.com/us/developer/documentation/api/content/v2.0/csv_file_name_extension_full_specification.html
</code><code language="code">No:  # See details at
     # http://www.example.com/us/developer/documentation/api/content/\
     # v2.0/csv_file_name_extension_full_specification.html
</code><paragraph>Make note of the indentation of the elements in the line continuation examples above; see the indentation section for explanation.</paragraph><paragraph>Docstring summary lines must remain within the 80 character limit.</paragraph><paragraph>In all other cases where a line exceeds 80 characters, and the Black or Pyink auto-formatter does not help bring the line below the limit, the line is allowed to exceed this maximum. Authors are encouraged to manually break the line up per the notes above when it is sensible.</paragraph><heading level="3">3.3 Parentheses</heading><paragraph>Use parentheses sparingly.</paragraph><paragraph>It is fine, though not required, to use parentheses around tuples. Do not use them in return statements or conditional statements unless using parentheses for implied line continuation or to indicate a tuple.</paragraph><code language="code">Yes: if foo:
         bar()
     while x:
         x = bar()
     if x and y:
         bar()
     if not x:
         bar()
     # For a 1 item tuple the ()s are more visually obvious than the comma.
     onesie = (foo,)
     return foo
     return spam, beans
     return (spam, beans)
     for (x, y) in dict.items(): ...
</code><code language="code">No:  if (x):
         bar()
     if not(x):
         bar()
     return (foo)
</code><heading level="3">3.4 Indentation</heading><paragraph>Indent your code blocks with 4 spaces.</paragraph><paragraph>Never use tabs. Implied line continuation should align wrapped elements vertically (see line length examples), or use a hanging 4-space indent. Closing (round, square or curly) brackets can be placed at the end of the expression, or on separate lines, but then should be indented the same as the line with the corresponding opening bracket.</paragraph><code language="javascript">Yes:   # Aligned with opening delimiter.
       foo = long_function_name(var_one, var_two,
                                var_three, var_four)
       meal = (spam,
               beans)

       # Aligned with opening delimiter in a dictionary.
       foo = {
           'long_dictionary_key': value1 +
                                  value2,
           ...
       }

       # 4-space hanging indent; nothing on first line.
       foo = long_function_name(
           var_one, var_two, var_three,
           var_four)
       meal = (
           spam,
           beans)

       # 4-space hanging indent; nothing on first line,
       # closing parenthesis on a new line.
       foo = long_function_name(
           var_one, var_two, var_three,
           var_four
       )
       meal = (
           spam,
           beans,
       )

       # 4-space hanging indent in a dictionary.
       foo = {
           'long_dictionary_key':
               long_dictionary_value,
           ...
       }
</code><code language="javascript">No:    # Stuff on first line forbidden.
       foo = long_function_name(var_one, var_two,
           var_three, var_four)
       meal = (spam,
           beans)

       # 2-space hanging indent forbidden.
       foo = long_function_name(
         var_one, var_two, var_three,
         var_four)

       # No hanging indent in a dictionary.
       foo = {
           'long_dictionary_key':
           long_dictionary_value,
           ...
       }
</code><heading level="4">3.4.1 Trailing commas in sequences of items?</heading><paragraph>Trailing commas in sequences of items are recommended only when the closing container token ], ), or } does not appear on the same line as the final element, as well as for tuples with a single element. The presence of a trailing comma is also used as a hint to our Python code auto-formatter Black or Pyink to direct it to auto-format the container of items to one item per line when the , after the final element is present.</paragraph><code language="code">Yes:   golomb3 = [0, 1, 3]
       golomb4 = [
           0,
           1,
           4,
           6,
       ]
</code><code language="code">No:    golomb4 = [
           0,
           1,
           4,
           6,]
</code><heading level="3">3.5 Blank Lines</heading><paragraph>Two blank lines between top-level definitions, be they function or class definitions. One blank line between method definitions and between the docstring of a class and the first method. No blank line following a def line. Use single blank lines as you judge appropriate within functions or methods.</paragraph><paragraph>Blank lines need not be anchored to the definition. For example, related comments immediately preceding function, class, and method definitions can make sense. Consider if your comment might be more useful as part of the docstring.</paragraph><heading level="3">3.6 Whitespace</heading><paragraph>Follow standard typographic rules for the use of spaces around punctuation.</paragraph><paragraph>No whitespace inside parentheses, brackets or braces.</paragraph><code language="code">Yes: spam(ham[1], {'eggs': 2}, [])
</code><code language="code">No:  spam( ham[ 1 ], { 'eggs': 2 }, [ ] )
</code><paragraph>No whitespace before a comma, semicolon, or colon. Do use whitespace after a comma, semicolon, or colon, except at the end of the line.</paragraph><code language="code">Yes: if x == 4:
         print(x, y)
     x, y = y, x
</code><code language="code">No:  if x == 4 :
         print(x , y)
     x , y = y , x
</code><paragraph>No whitespace before the open paren/bracket that starts an argument list, indexing or slicing.</paragraph><code language="code">Yes: dict['key'] = list[index]
</code><code language="code">No:  dict ['key'] = list [index]
</code><paragraph>No trailing whitespace.</paragraph><paragraph>Surround binary operators with a single space on either side for assignment (=), comparisons (==, <, >, !=, <>, <=, >=, in, not in, is, is not), and Booleans (and, or, not). Use your better judgment for the insertion of spaces around arithmetic operators (+, -, *, /, //, %, **, @).</paragraph><paragraph>Never use spaces around = when passing keyword arguments or defining a default parameter value, with one exception: when a type annotation is present, do use spaces around the = for the default parameter value.</paragraph><code language="python">Yes: def complex(real, imag=0.0): return Magic(r=real, i=imag)
Yes: def complex(real, imag: float = 0.0): return Magic(r=real, i=imag)
</code><code language="python">No:  def complex(real, imag = 0.0): return Magic(r = real, i = imag)
No:  def complex(real, imag: float=0.0): return Magic(r = real, i = imag)
</code><paragraph>Don't use spaces to vertically align tokens on consecutive lines, since it becomes a maintenance burden (applies to :, #, =, etc.):</paragraph><code language="javascript">Yes:
  foo = 1000  # comment
  long_name = 2  # comment that should not be aligned

  dictionary = {
      'foo': 1,
      'long_name': 2,
  }
</code><code language="javascript">No:
  foo       = 1000  # comment
  long_name = 2     # comment that should not be aligned

  dictionary = {
      'foo'      : 1,
      'long_name': 2,
  }
</code><heading level="3">3.7 Shebang Line</heading><paragraph>Most .py files do not need to start with a #! line. Start the main file of a program with #!/usr/bin/env python3 (to support virtualenvs) or #!/usr/bin/python3 per PEP-394.</paragraph><paragraph>This line is used by the kernel to find the Python interpreter, but is ignored by Python when importing modules. It is only necessary on a file intended to be executed directly.</paragraph><paragraph>Be sure to use the right style for module, function, method docstrings and inline comments.</paragraph><heading level="4">3.8.1 Docstrings</heading><paragraph>Python uses docstrings to document code. A docstring is a string that is the first statement in a package, module, class or function. These strings can be extracted automatically through the __doc__ member of the object and are used by pydoc. (Try running pydoc on your module to see how it looks.) Always use the three-double-quote """ format for docstrings (per PEP 257). A docstring should be organized as a summary line (one physical line not exceeding 80 characters) terminated by a period, question mark, or exclamation point. When writing more (encouraged), this must be followed by a blank line, followed by the rest of the docstring starting at the same cursor position as the first quote of the first line. There are more formatting guidelines for docstrings below.</paragraph><heading level="4">3.8.2 Modules</heading><paragraph>Every file should contain license boilerplate. Choose the appropriate boilerplate for the license used by the project (for example, Apache 2.0, BSD, LGPL, GPL).</paragraph><paragraph>Files should start with a docstring describing the contents and usage of the module.</paragraph><code language="code">"""A one-line summary of the module or program, terminated by a period.

Leave one blank line.  The rest of this docstring should contain an
overall description of the module or program.  Optionally, it may also
contain a brief description of exported classes and functions and/or usage
examples.

Typical usage example:

  foo = ClassFoo()
  bar = foo.function_bar()
"""
</code><heading level="5">3.8.2.1 Test modules</heading><paragraph>Module-level docstrings for test files are not required. They should be included only when there is additional information that can be provided.</paragraph><paragraph>Examples include some specifics on how the test should be run, an explanation of an unusual setup pattern, dependency on the external environment, and so on.</paragraph><code language="code">"""This blaze test uses golden files.

You can update those files by running
`blaze run //foo/bar:foo_test -- --update_golden_files` from the `google3`
directory.
"""
</code><paragraph>Docstrings that do not provide any new information should not be used.</paragraph><heading level="4">3.8.3 Functions and Methods</heading><paragraph>In this section, "function" means a method, function, generator, or property.</paragraph><paragraph>A docstring is mandatory for every function that has one or more of the following properties:</paragraph><list type="ul"><item>being part of the public API</item><item>nontrivial size</item><item>non-obvious logic</item></list><paragraph>A docstring should give enough information to write a call to the function without reading the function's code. The docstring should describe the function's calling syntax and its semantics, but generally not its implementation details, unless those details are relevant to how the function is to be used. For example, a function that mutates one of its arguments as a side effect should note that in its docstring. Otherwise, subtle but important details of a function's implementation that are not relevant to the caller are better expressed as comments alongside the code than within the function's docstring.</paragraph><paragraph>The docstring may be descriptive-style ("""Fetches rows from a Bigtable.""") or imperative-style ("""Fetch rows from a Bigtable."""), but the style should be consistent within a file. The docstring for a @property data descriptor should use the same style as the docstring for an attribute or a function argument ("""The Bigtable path.""", rather than """Returns the Bigtable path.""").</paragraph><paragraph>Certain aspects of a function should be documented in special sections, listed below. Each section begins with a heading line, which ends with a colon. All sections other than the heading should maintain a hanging indent of two or four spaces (be consistent within a file). These sections can be omitted in cases where the function's name and signature are informative enough that it can be aptly described using a one-line docstring.</paragraph><code language="python">def fetch_smalltable_rows(
    table_handle: smalltable.Table,
    keys: Sequence[bytes | str],
    require_all_keys: bool = False,
) -> Mapping[bytes, tuple[str, ...]]:
    """Fetches rows from a Smalltable.

    Retrieves rows pertaining to the given keys from the Table instance
    represented by table_handle.  String keys will be UTF-8 encoded.

    Args:
        table_handle: An open smalltable.Table instance.
        keys: A sequence of strings representing the key of each table
          row to fetch.  String keys will be UTF-8 encoded.
        require_all_keys: If True only rows with values set for all keys will be
          returned.

    Returns:
        A dict mapping keys to the corresponding table row data
        fetched. Each row is represented as a tuple of strings. For
        example:

        {b'Serak': ('Rigel VII', 'Preparer'),
         b'Zim': ('Irk', 'Invader'),
         b'Lrrr': ('Omicron Persei 8', 'Emperor')}

        Returned keys are always bytes.  If a key from the keys argument is
        missing from the dictionary, then that row was not found in the
        table (and require_all_keys must have been False).

    Raises:
        IOError: An error occurred accessing the smalltable.
    """
</code><paragraph>Similarly, this variation on Args: with a line break is also allowed:</paragraph><code language="python">def fetch_smalltable_rows(
    table_handle: smalltable.Table,
    keys: Sequence[bytes | str],
    require_all_keys: bool = False,
) -> Mapping[bytes, tuple[str, ...]]:
    """Fetches rows from a Smalltable.

    Retrieves rows pertaining to the given keys from the Table instance
    represented by table_handle.  String keys will be UTF-8 encoded.

    Args:
      table_handle:
        An open smalltable.Table instance.
      keys:
        A sequence of strings representing the key of each table row to
        fetch.  String keys will be UTF-8 encoded.
      require_all_keys:
        If True only rows with values set for all keys will be returned.

    Returns:
      A dict mapping keys to the corresponding table row data
      fetched. Each row is represented as a tuple of strings. For
      example:

      {b'Serak': ('Rigel VII', 'Preparer'),
       b'Zim': ('Irk', 'Invader'),
       b'Lrrr': ('Omicron Persei 8', 'Emperor')}

      Returned keys are always bytes.  If a key from the keys argument is
      missing from the dictionary, then that row was not found in the
      table (and require_all_keys must have been False).

    Raises:
      IOError: An error occurred accessing the smalltable.
    """
</code><heading level="5">3.8.3.1 Overridden Methods</heading><paragraph>A method that overrides a method from a base class does not need a docstring if it is explicitly decorated with @override (from typing_extensions or typing modules), unless the overriding method's behavior materially refines the base method's contract, or details need to be provided (e.g., documenting additional side effects), in which case a docstring with at least those differences is required on the overriding method.</paragraph><code language="python">from typing_extensions import override

class Parent:
  def do_something(self):
    """Parent method, includes docstring."""

# Child class, method annotated with override.
class Child(Parent):
  @override
  def do_something(self):
    pass
</code><code language="python"># Child class, but without @override decorator, a docstring is required.
class Child(Parent):
  def do_something(self):
    pass

# Docstring is trivial, @override is sufficient to indicate that docs can be
# found in the base class.
class Child(Parent):
  @override
  def do_something(self):
    """See base class."""
</code><heading level="4">3.8.4 Classes</heading><paragraph>Classes should have a docstring below the class definition describing the class. Public attributes, excluding properties, should be documented here in an Attributes section and follow the same formatting as a function's Args section.</paragraph><code language="python">class SampleClass:
    """Summary of class here.

    Longer class information...
    Longer class information...

    Attributes:
        likes_spam: A boolean indicating if we like SPAM or not.
        eggs: An integer count of the eggs we have laid.
    """

    def __init__(self, likes_spam: bool = False):
        """Initializes the instance based on spam preference.

        Args:
          likes_spam: Defines if instance exhibits this preference.
        """
        self.likes_spam = likes_spam
        self.eggs = 0

    @property
    def butter_sticks(self) -> int:
        """The number of butter sticks we have."""
</code><paragraph>All class docstrings should start with a one-line summary that describes what the class instance represents. This implies that subclasses of Exception should also describe what the exception represents, and not the context in which it might occur. The class docstring should not repeat unnecessary information, such as that the class is a class.</paragraph><code language="python"># Yes:
class CheeseShopAddress:
  """The address of a cheese shop.

  ...
  """

class OutOfCheeseError(Exception):
  """No more cheese is available."""
</code><code language="python"># No:
class CheeseShopAddress:
  """Class that describes the address of a cheese shop.

  ...
  """

class OutOfCheeseError(Exception):
  """Raised when no more cheese is available."""
</code><paragraph>The final place to have comments is in tricky parts of the code. If you're going to have to explain it at the next code review, you should comment it now. Complicated operations get a few lines of comments before the operations commence. Non-obvious ones get comments at the end of the line.</paragraph><code language="code"># We use a weighted dictionary search to find out where i is in
# the array.  We extrapolate position based on the largest num
# in the array and the array size and then do binary search to
# get the exact number.

if i & (i-1) == 0:  # True if i is 0 or a power of 2.
</code><paragraph>To improve legibility, these comments should start at least 2 spaces away from the code with the comment character #, followed by at least one space before the text of the comment itself.</paragraph><paragraph>On the other hand, never describe the code. Assume the person reading the code knows Python (though not what you're trying to do) better than you do.</paragraph><code language="code"># BAD COMMENT: Now go through the b array and make sure whenever i occurs
# the next element is i+1
</code><heading level="4">3.8.6 Punctuation, Spelling, and Grammar</heading><paragraph>Pay attention to punctuation, spelling, and grammar; it is easier to read well-written comments than badly written ones.</paragraph><paragraph>Comments should be as readable as narrative text, with proper capitalization and punctuation. In many cases, complete sentences are more readable than sentence fragments. Shorter comments, such as comments at the end of a line of code, can sometimes be less formal, but you should be consistent with your style.</paragraph><paragraph>Although it can be frustrating to have a code reviewer point out that you are using a comma when you should be using a semicolon, it is very important that source code maintain a high level of clarity and readability. Proper punctuation, spelling, and grammar help with that goal.</paragraph><heading level="3">3.10 Strings</heading><paragraph>Use an f-string, the % operator, or the format method for formatting strings, even when the parameters are all strings. Use your best judgment to decide between string formatting options. A single join with + is okay but do not format with +.</paragraph><code language="code">Yes: x = f'name: {name}; score: {n}'
     x = '%s, %s!' % (imperative, expletive)
     x = '{}, {}'.format(first, second)
     x = 'name: %s; score: %d' % (name, n)
     x = 'name: %(name)s; score: %(score)d' % {'name':name, 'score':n}
     x = 'name: {}; score: {}'.format(name, n)
     x = a + b
</code><code language="code">No: x = first + ', ' + second
    x = 'name: ' + name + '; score: ' + str(n)
</code><paragraph>Avoid using the + and += operators to accumulate a string within a loop. In some conditions, accumulating a string with addition can lead to quadratic rather than linear running time. Although common accumulations of this sort may be optimized on CPython, that is an implementation detail. The conditions under which an optimization applies are not easy to predict and may change. Instead, add each substring to a list and ''.join the list after the loop terminates, or write each substring to an io.StringIO buffer. These techniques consistently have amortized-linear run-time complexity.</paragraph><code language="code">Yes: items = ['<table>']
     for last_name, first_name in employee_list:
         items.append('<tr><td>%s, %s</td></tr>' % (last_name, first_name))
     items.append('</table>')
     employee_table = ''.join(items)
</code><code language="code">No: employee_table = '<table>'
    for last_name, first_name in employee_list:
        employee_table += '<tr><td>%s, %s</td></tr>' % (last_name, first_name)
    employee_table += '</table>'
</code><paragraph>Be consistent with your choice of string quote character within a file. Pick ' or " and stick with it. It is okay to use the other quote character on a string to avoid the need to backslash-escape quote characters within the string.</paragraph><code language="code">Yes:
  Python('Why are you hiding your eyes?')
  Gollum("I'm scared of lint errors.")
  Narrator('"Good!" thought a happy Python reviewer.')
</code><code language="code">No:
  Python("Why are you hiding your eyes?")
  Gollum('The lint. It burns. It burns us.')
  Gollum("Always the great lint. Watching. Watching.")
</code><paragraph>Prefer """ for multi-line strings rather than '''. Projects may choose to use ''' for all non-docstring multi-line strings if and only if they also use ' for regular strings. Docstrings must use """ regardless.</paragraph><paragraph>Multi-line strings do not flow with the indentation of the rest of the program. If you need to avoid embedding extra space in the string, use either concatenated single-line strings or a multi-line string with textwrap.dedent() to remove the initial space on each line:</paragraph><code language="code">  No:
  long_string = """This is pretty ugly.
Don't do this.
"""
</code><code language="code">  Yes:
  long_string = """This is fine if your use case can accept
      extraneous leading spaces."""
</code><code language="code">  Yes:
  long_string = ("And this is fine if you cannot accept\n" +
                 "extraneous leading spaces.")
</code><code language="code">  Yes:
  long_string = ("And this too is fine if you cannot accept\n"
                 "extraneous leading spaces.")
</code><code language="javascript">  Yes:
  import textwrap

  long_string = textwrap.dedent("""\
      This is also fine, because textwrap.dedent()
      will collapse common leading spaces in each line.""")
</code><paragraph>Note that using a backslash here does not violate the prohibition against explicit line continuation; in this case, the backslash is escaping a newline in a string literal.</paragraph><heading level="4">3.10.1 Logging</heading><paragraph>For logging functions that expect a pattern-string (with %-placeholders) as their first argument: Always call them with a string literal (not an f-string!) as their first argument with pattern-parameters as subsequent arguments. Some logging implementations collect the unexpanded pattern-string as a queryable field. It also prevents spending time rendering a message that no logger is configured to output.</paragraph><code language="javascript">  Yes:
  import tensorflow as tf
  logger = tf.get_logger()
  logger.info('TensorFlow Version is: %s', tf.__version__)
</code><code language="python">  Yes:
  import os
  from absl import logging

  logging.info('Current $PAGER is: %s', os.getenv('PAGER', default=''))

  homedir = os.getenv('HOME')
  if homedir is None or not os.access(homedir, os.W_OK):
    logging.error('Cannot write to home directory, $HOME=%r', homedir)
</code><code language="python">  No:
  import os
  from absl import logging

  logging.info('Current $PAGER is:')
  logging.info(os.getenv('PAGER', default=''))

  homedir = os.getenv('HOME')
  if homedir is None or not os.access(homedir, os.W_OK):
    logging.error(f'Cannot write to home directory, $HOME={homedir!r}')
</code><heading level="4">3.10.2 Error Messages</heading><paragraph>Error messages (such as: message strings on exceptions like ValueError, or messages shown to the user) should follow three guidelines:</paragraph><list type="ol"><item>The message needs to precisely match the actual error condition.</item><item>Interpolated pieces need to always be clearly identifiable as such.</item><item>They should allow simple automated processing (e.g. grepping).</item></list><paragraph>The message needs to precisely match the actual error condition.</paragraph><paragraph>Interpolated pieces need to always be clearly identifiable as such.</paragraph><paragraph>They should allow simple automated processing (e.g. grepping).</paragraph><code language="code">  Yes:
  if not 0 <= p <= 1:
    raise ValueError(f'Not a probability: {p=}')

  try:
    os.rmdir(workdir)
  except OSError as error:
    logging.warning('Could not remove directory (reason: %r): %r',
                    error, workdir)
</code><code language="code">  No:
  if p < 0 or p > 1:  # PROBLEM: also false for float('nan')!
    raise ValueError(f'Not a probability: {p=}')

  try:
    os.rmdir(workdir)
  except OSError:
    # PROBLEM: Message makes an assumption that might not be true:
    # Deletion might have failed for some other reason, misleading
    # whoever has to debug this.
    logging.warning('Directory already was deleted: %s', workdir)

  try:
    os.rmdir(workdir)
  except OSError:
    # PROBLEM: The message is harder to grep for than necessary, and
    # not universally non-confusing for all possible values of `workdir`.
    # Imagine someone calling a library function with such code
    # using a name such as workdir = 'deleted'. The warning would read:
    # "The deleted directory could not be deleted."
    logging.warning('The %s directory could not be deleted.', workdir)
</code><heading level="3">3.11 Files, Sockets, and similar Stateful Resources</heading><paragraph>Explicitly close files and sockets when done with them. This rule naturally extends to closeable resources that internally use sockets, such as database connections, and also other resources that need to be closed down in a similar fashion. To name only a few examples, this also includes mmap mappings, h5py File objects, and matplotlib.pyplot figure windows.</paragraph><paragraph>Leaving files, sockets or other such stateful objects open unnecessarily has many downsides:</paragraph><list type="ul"><item>They may consume limited system resources, such as file descriptors. Code that deals with many such objects may exhaust those resources unnecessarily if they're not returned to the system promptly after use.</item><item>Holding files open may prevent other actions such as moving or deleting them, or unmounting a filesystem.</item><item>Files and sockets that are shared throughout a program may inadvertently be read from or written to after logically being closed. If they are actually closed, attempts to read or write from them will raise exceptions, making the problem known sooner.</item></list><paragraph>Furthermore, while files and sockets (and some similarly behaving resources) are automatically closed when the object is destructed, coupling the lifetime of the object to the state of the resource is poor practice:</paragraph><list type="ul"><item>There are no guarantees as to when the runtime will actually invoke the __del__ method. Different Python implementations use different memory management techniques, such as delayed garbage collection, which may increase the object's lifetime arbitrarily and indefinitely.</item><item>Unexpected references to the file, e.g. in globals or exception tracebacks, may keep it around longer than intended.</item></list><paragraph>Relying on finalizers to do automatic cleanup that has observable side effects has been rediscovered over and over again to lead to major problems, across many decades and multiple languages (see e.g. this article for Java).</paragraph><paragraph>The preferred way to manage files and similar resources is using the with statement:</paragraph><code language="code">with open("hello.txt") as hello_file:
    for line in hello_file:
        print(line)
</code><paragraph>For file-like objects that do not support the with statement, use contextlib.closing():</paragraph><code language="javascript">import contextlib

with contextlib.closing(urllib.urlopen("http://www.python.org/")) as front_page:
    for line in front_page:
        print(line)
</code><paragraph>In rare cases where context-based resource management is infeasible, code documentation must explain clearly how resource lifetime is managed.</paragraph><paragraph>Use TODO comments for code that is temporary, a short-term solution, or good-enough but not perfect.</paragraph><paragraph>A TODO comment begins with the word TODO in all caps, a following colon, and a link to a resource that contains the context, ideally a bug reference. A bug reference is preferable because bugs are tracked and have follow-up comments. Follow this piece of context with an explanatory string introduced with a hyphen -. The purpose is to have a consistent TODO format that can be searched to find out how to get more details.</paragraph><code language="code"># TODO: crbug.com/192795 - Investigate cpufreq optimizations.
</code><paragraph>Old style, formerly recommended, but discouraged for use in new code:</paragraph><code language="code"># TODO(crbug.com/192795): Investigate cpufreq optimizations.
# TODO(yourusername): Use a "\*" here for concatenation operator.
</code><paragraph>Avoid adding TODOs that refer to an individual or team as the context:</paragraph><code language="code"># TODO: @yourusername - File an issue and use a '*' for repetition.
</code><paragraph>If your TODO is of the form "At a future date do something" make sure that you either include a very specific date ("Fix by November 2009") or a very specific event ("Remove this code when all clients can handle XML responses.") that future code maintainers will comprehend. Issues are ideal for tracking this.</paragraph><heading level="3">3.13 Imports formatting</heading><paragraph>Imports should be on separate lines; there are exceptions for typing and collections.abc imports.</paragraph><paragraph>E.g.:</paragraph><code language="python">Yes: from collections.abc import Mapping, Sequence
     import os
     import sys
     from typing import Any, NewType
</code><paragraph>Imports are always put at the top of the file, just after any module comments and docstrings and before module globals and constants. Imports should be grouped from most generic to least generic:</paragraph><list type="ol"><item>Python future import statements. For example: from __future__ import annotations See above for more information about those.</item><item>Python standard library imports. For example:</item><item>third-party module or package imports. For example:</item><item>Code repository sub-package imports. For example: from otherproject.ai import mind</item><item>Deprecated: application-specific imports that are part of the same top-level sub-package as this file. For example: from myproject.backend.hgwells import time_machine You may find older Google Python Style code doing this, but it is no longer required. New code is encouraged not to bother with this. Simply treat application-specific sub-package imports the same as other sub-package imports.</item></list><paragraph>Python future import statements. For example:</paragraph><code language="python">from __future__ import annotations
</code><paragraph>See above for more information about those.</paragraph><paragraph>Python standard library imports. For example:</paragraph><paragraph>third-party module or package imports. For example:</paragraph><paragraph>Code repository sub-package imports. For example:</paragraph><code language="code">from otherproject.ai import mind
</code><paragraph>Deprecated: application-specific imports that are part of the same top-level sub-package as this file. For example:</paragraph><code language="code">from myproject.backend.hgwells import time_machine
</code><paragraph>You may find older Google Python Style code doing this, but it is no longer required. New code is encouraged not to bother with this. Simply treat application-specific sub-package imports the same as other sub-package imports.</paragraph><paragraph>Within each grouping, imports should be sorted lexicographically, ignoring case, according to each module's full package path (the path in from path import ...). Code may optionally place a blank line between import sections.</paragraph><code language="python">import collections
import queue
import sys

from absl import app
from absl import flags
import bs4
import cryptography
import tensorflow as tf

from book.genres import scifi
from myproject.backend import huxley
from myproject.backend.hgwells import time_machine
from myproject.backend.state_machine import main_loop
from otherproject.ai import body
from otherproject.ai import mind
from otherproject.ai import soul

# Older style code may have these imports down here instead:
#from myproject.backend.hgwells import time_machine
#from myproject.backend.state_machine import main_loop
</code><heading level="3">3.14 Statements</heading><paragraph>Generally only one statement per line.</paragraph><paragraph>However, you may put the result of a test on the same line as the test only if the entire statement fits on one line. In particular, you can never do so with try/except since the try and except can't both fit on the same line, and you can only do so with an if if there is no else.</paragraph><code language="code">No:

  if foo: bar(foo)
  else:   baz(foo)

  try:               bar(foo)
  except ValueError: baz(foo)

  try:
      bar(foo)
  except ValueError: baz(foo)
</code><heading level="3">3.15 Getters and Setters</heading><paragraph>Getter and setter functions (also called accessors and mutators) should be used when they provide a meaningful role or behavior for getting or setting a variable's value.</paragraph><paragraph>In particular, they should be used when getting or setting the variable is complex or the cost is significant, either currently or in a reasonable future.</paragraph><paragraph>If, for example, a pair of getters/setters simply read and write an internal attribute, the internal attribute should be made public instead. By comparison, if setting a variable means some state is invalidated or rebuilt, it should be a setter function. The function invocation hints that a potentially non-trivial operation is occurring. Alternatively, properties may be an option when simple logic is needed, or refactoring to no longer need getters and setters.</paragraph><paragraph>Getters and setters should follow the Naming guidelines, such as get_foo() and set_foo().</paragraph><paragraph>If the past behavior allowed access through a property, do not bind the new getter/setter functions to the property. Any code still attempting to access the variable by the old method should break visibly so they are made aware of the change in complexity.</paragraph><heading level="3">3.16 Naming</heading><paragraph>module_name, package_name, ClassName, method_name, ExceptionName, function_name, GLOBAL_CONSTANT_NAME, global_var_name, instance_var_name, function_parameter_name, local_var_name, query_proper_noun_for_thing, send_acronym_via_https.</paragraph><paragraph>Names should be descriptive. This includes functions, classes, variables, attributes, files and any other type of named entities.</paragraph><paragraph>Avoid abbreviation. In particular, do not use abbreviations that are ambiguous or unfamiliar to readers outside your project, and do not abbreviate by deleting letters within a word.</paragraph><paragraph>Always use a .py filename extension. Never use dashes.</paragraph><heading level="4">3.16.1 Names to Avoid</heading><list type="ul"><item>single character names, except for specifically allowed cases: counters or iterators (e.g. i, j, k, v, et al.) e as an exception identifier in try/except statements. f as a file handle in with statements private type variables with no constraints (e.g. _T = TypeVar("_T"), _P = ParamSpec("_P")) names that match established notation in a reference paper or algorithm (see Mathematical Notation) Please be mindful not to abuse single-character naming. Generally speaking, descriptiveness should be proportional to the name's scope of visibility. For example, i might be a fine name for 5-line code block but within multiple nested scopes, it is likely too vague.</item><item>dashes (-) in any package/module name</item><item>__double_leading_and_trailing_underscore__ names (reserved by Python)</item><item>offensive terms</item><item>names that needlessly include the type of the variable (for example: id_to_name_dict)</item></list><paragraph>single character names, except for specifically allowed cases:</paragraph><list type="ul"><item>counters or iterators (e.g. i, j, k, v, et al.)</item><item>e as an exception identifier in try/except statements.</item><item>f as a file handle in with statements</item><item>private type variables with no constraints (e.g. _T = TypeVar("_T"), _P = ParamSpec("_P"))</item><item>names that match established notation in a reference paper or algorithm (see Mathematical Notation)</item></list><paragraph>Please be mindful not to abuse single-character naming. Generally speaking, descriptiveness should be proportional to the name's scope of visibility. For example, i might be a fine name for 5-line code block but within multiple nested scopes, it is likely too vague.</paragraph><paragraph>dashes (-) in any package/module name</paragraph><paragraph>__double_leading_and_trailing_underscore__ names (reserved by Python)</paragraph><paragraph>offensive terms</paragraph><paragraph>names that needlessly include the type of the variable (for example: id_to_name_dict)</paragraph><heading level="4">3.16.2 Naming Conventions</heading><list type="ul"><item>"Internal" means internal to a module, or protected or private within a class.</item><item>Prepending a single underscore (_) has some support for protecting module variables and functions (linters will flag protected member access). Note that it is okay for unit tests to access protected constants from the modules under test.</item><item>Prepending a double underscore (__ aka "dunder") to an instance variable or method effectively makes the variable or method private to its class (using name mangling); we discourage its use as it impacts readability and testability, and isn't really private. Prefer a single underscore.</item><item>Place related classes and top-level functions together in a module. Unlike Java, there is no need to limit yourself to one class per module.</item><item>Use CapWords for class names, but lower_with_under.py for module names. Although there are some old modules named CapWords.py, this is now discouraged because it's confusing when the module happens to be named after a class. ("wait – did I write import StringIO or from StringIO import StringIO?")</item><item>New unit test files follow PEP 8 compliant lower_with_under method names, for example, test_<method_under_test>_<state>. For consistency(*) with legacy modules that follow CapWords function names, underscores may appear in method names starting with test to separate logical components of the name. One possible pattern is test<MethodUnderTest>_<state>.</item></list><paragraph>"Internal" means internal to a module, or protected or private within a class.</paragraph><paragraph>Prepending a single underscore (_) has some support for protecting module variables and functions (linters will flag protected member access). Note that it is okay for unit tests to access protected constants from the modules under test.</paragraph><paragraph>Prepending a double underscore (__ aka "dunder") to an instance variable or method effectively makes the variable or method private to its class (using name mangling); we discourage its use as it impacts readability and testability, and isn't really private. Prefer a single underscore.</paragraph><paragraph>Place related classes and top-level functions together in a module. Unlike Java, there is no need to limit yourself to one class per module.</paragraph><paragraph>Use CapWords for class names, but lower_with_under.py for module names. Although there are some old modules named CapWords.py, this is now discouraged because it's confusing when the module happens to be named after a class. ("wait – did I write import StringIO or from StringIO import StringIO?")</paragraph><paragraph>New unit test files follow PEP 8 compliant lower_with_under method names, for example, test_<method_under_test>_<state>. For consistency(*) with legacy modules that follow CapWords function names, underscores may appear in method names starting with test to separate logical components of the name. One possible pattern is test<MethodUnderTest>_<state>.</paragraph><heading level="4">3.16.3 File Naming</heading><paragraph>Python filenames must have a .py extension and must not contain dashes (-). This allows them to be imported and unittested. If you want an executable to be accessible without the extension, use a symbolic link or a simple bash wrapper containing exec "$0.py" "$@".</paragraph><heading level="4">3.16.4 Guidelines derived from Guido's Recommendations</heading><table><thead><tr><th>Type</th><th>Public</th><th>Internal</th></tr></thead><tbody><tr><td>Packages</td><td>lower_with_under</td><td></td></tr><tr><td>Modules</td><td>lower_with_under</td><td>_lower_with_under</td></tr><tr><td>Classes</td><td>CapWords</td><td>_CapWords</td></tr><tr><td>Exceptions</td><td>CapWords</td><td></td></tr><tr><td>Functions</td><td>lower_with_under()</td><td>_lower_with_under()</td></tr><tr><td>Global/Class Constants</td><td>CAPS_WITH_UNDER</td><td>_CAPS_WITH_UNDER</td></tr><tr><td>Global/Class Variables</td><td>lower_with_under</td><td>_lower_with_under</td></tr><tr><td>Instance Variables</td><td>lower_with_under</td><td>_lower_with_under (protected)</td></tr><tr><td>Method Names</td><td>lower_with_under()</td><td>_lower_with_under() (protected)</td></tr><tr><td>Function/Method Parameters</td><td>lower_with_under</td><td></td></tr><tr><td>Local Variables</td><td>lower_with_under</td><td></td></tr></tbody></table><heading level="4">3.16.5 Mathematical Notation</heading><paragraph>For mathematically-heavy code, short variable names that would otherwise violate the style guide are preferred when they match established notation in a reference paper or algorithm.</paragraph><paragraph>When using names based on established notation:</paragraph><list type="ol"><item>Cite the source of all naming conventions, preferably with a hyperlink to academic resource itself, in a comment or docstring. If the source is not accessible, clearly document the naming conventions.</item><item>Prefer PEP8-compliant descriptive_names for public APIs, which are much more likely to be encountered out of context.</item><item>Use a narrowly-scoped pylint: disable=invalid-name directive to silence warnings. For just a few variables, use the directive as an endline comment for each one; for more, apply the directive at the beginning of a block.</item></list><heading level="3">3.17 Main</heading><paragraph>In Python, pydoc as well as unit tests require modules to be importable. If a file is meant to be used as an executable, its main functionality should be in a main() function, and your code should always check if __name__ == '__main__' before executing your main program, so that it is not executed when the module is imported.</paragraph><paragraph>When using absl, use app.run:</paragraph><code language="python">from absl import app
...

def main(argv: Sequence[str]):
    # process non-flag arguments
    ...

if __name__ == '__main__':
    app.run(main)
</code><paragraph>Otherwise, use:</paragraph><code language="python">def main():
    ...

if __name__ == '__main__':
    main()
</code><paragraph>All code at the top level will be executed when the module is imported. Be careful not to call functions, create objects, or perform other operations that should not be executed when the file is being pydoced.</paragraph><heading level="3">3.18 Function length</heading><paragraph>Prefer small and focused functions.</paragraph><paragraph>We recognize that long functions are sometimes appropriate, so no hard limit is placed on function length. If a function exceeds about 40 lines, think about whether it can be broken up without harming the structure of the program.</paragraph><paragraph>Even if your long function works perfectly now, someone modifying it in a few months may add new behavior. This could result in bugs that are hard to find. Keeping your functions short and simple makes it easier for other people to read and modify your code.</paragraph><paragraph>You could find long and complicated functions when working with some code. Do not be intimidated by modifying existing code: if working with such a function proves to be difficult, you find that errors are hard to debug, or you want to use a piece of it in several different contexts, consider breaking up the function into smaller and more manageable pieces.</paragraph><heading level="3">3.19 Type Annotations</heading><heading level="4">3.19.1 General Rules</heading><list type="ul"><item>Familiarize yourself with type hints.</item><item>Annotating self or cls is generally not necessary. Self can be used if it is necessary for proper type information, e.g. from typing import Self class BaseClass: @classmethod def create(cls) -> Self: ... def difference(self, other: Self) -> float: ...</item><item>Similarly, don't feel compelled to annotate the return value of __init__ (where None is the only valid option).</item><item>If any other variable or a returned type should not be expressed, use Any.</item><item>You are not required to annotate all the functions in a module. At least annotate your public APIs. Use judgment to get to a good balance between safety and clarity on the one hand, and flexibility on the other. Annotate code that is prone to type-related errors (previous bugs or complexity). Annotate code that is hard to understand. Annotate code as it becomes stable from a types perspective. In many cases, you can annotate all the functions in mature code without losing too much flexibility.</item></list><paragraph>Familiarize yourself with type hints.</paragraph><paragraph>Annotating self or cls is generally not necessary. Self can be used if it is necessary for proper type information, e.g.</paragraph><code language="python">from typing import Self

class BaseClass:
  @classmethod
  def create(cls) -> Self:
    ...

  def difference(self, other: Self) -> float:
    ...
</code><paragraph>Similarly, don't feel compelled to annotate the return value of __init__ (where None is the only valid option).</paragraph><paragraph>If any other variable or a returned type should not be expressed, use Any.</paragraph><paragraph>You are not required to annotate all the functions in a module.</paragraph><list type="ul"><item>At least annotate your public APIs.</item><item>Use judgment to get to a good balance between safety and clarity on the one hand, and flexibility on the other.</item><item>Annotate code that is prone to type-related errors (previous bugs or complexity).</item><item>Annotate code that is hard to understand.</item><item>Annotate code as it becomes stable from a types perspective. In many cases, you can annotate all the functions in mature code without losing too much flexibility.</item></list><heading level="4">3.19.2 Line Breaking</heading><paragraph>Try to follow the existing indentation rules.</paragraph><paragraph>After annotating, many function signatures will become "one parameter per line". To ensure the return type is also given its own line, a comma can be placed after the last parameter.</paragraph><code language="python">def my_method(
    self,
    first_var: int,
    second_var: Foo,
    third_var: Bar | None,
) -> int:
  ...
</code><paragraph>Always prefer breaking between variables, and not, for example, between variable names and type annotations. However, if everything fits on the same line, go for it.</paragraph><code language="python">def my_method(self, first_var: int) -> int:
  ...
</code><paragraph>If the combination of the function name, the last parameter, and the return type is too long, indent by 4 in a new line. When using line breaks, prefer putting each parameter and the return type on their own lines and aligning the closing parenthesis with the def:</paragraph><code language="python">Yes:
def my_method(
    self,
    other_arg: MyLongType | None,
) -> tuple[MyLongType1, MyLongType1]:
  ...
</code><paragraph>Optionally, the return type may be put on the same line as the last parameter:</paragraph><code language="python">Okay:
def my_method(
    self,
    first_var: int,
    second_var: int) -> dict[OtherLongType, MyLongType]:
  ...
</code><paragraph>pylint allows you to move the closing parenthesis to a new line and align with the opening one, but this is less readable.</paragraph><code language="python">No:
def my_method(self,
              other_arg: MyLongType | None,
             ) -> dict[OtherLongType, MyLongType]:
  ...
</code><paragraph>As in the examples above, prefer not to break types. However, sometimes they are too long to be on a single line (try to keep sub-types unbroken).</paragraph><code language="python">def my_method(
    self,
    first_var: tuple[list[MyLongType1],
                     list[MyLongType2]],
    second_var: list[dict[
        MyLongType3, MyLongType4]],
) -> None:
  ...
</code><paragraph>If a single name and type is too long, consider using an alias for the type. The last resort is to break after the colon and indent by 4.</paragraph><code language="python">Yes:
def my_function(
    long_variable_name:
        long_module_name.LongTypeName,
) -> None:
  ...
</code><code language="python">No:
def my_function(
    long_variable_name: long_module_name.
        LongTypeName,
) -> None:
  ...
</code><heading level="4">3.19.3 Forward Declarations</heading><paragraph>If you need to use a class name (from the same module) that is not yet defined – for example, if you need the class name inside the declaration of that class, or if you use a class that is defined later in the code – either use from __future__ import annotations or use a string for the class name.</paragraph><code language="python">Yes:
from __future__ import annotations

class MyClass:
  def __init__(self, stack: Sequence[MyClass], item: OtherClass) -> None:

class OtherClass:
  ...
</code><code language="python">Yes:
class MyClass:
  def __init__(self, stack: Sequence['MyClass'], item: 'OtherClass') -> None:

class OtherClass:
  ...
</code><heading level="4">3.19.4 Default Values</heading><paragraph>As per PEP-008, use spaces around the = only for arguments that have both a type annotation and a default value.</paragraph><code language="python">Yes:
def func(a: int = 0) -> int:
  ...
</code><code language="python">No:
def func(a:int=0) -> int:
  ...
</code><heading level="4">3.19.5 NoneType</heading><paragraph>In the Python type system, NoneType is a "first class" type, and for typing purposes, None is an alias for NoneType. If an argument can be None, it has to be declared! You can use | union type expressions (recommended in new Python 3.10+ code), or the older Optional and Union syntaxes.</paragraph><paragraph>Use explicit X | None instead of implicit. Earlier versions of type checkers allowed a: str = None to be interpreted as a: str | None = None, but that is no longer the preferred behavior.</paragraph><code language="python">Yes:
def modern_or_union(a: str | int | None, b: str | None = None) -> str:
  ...
def union_optional(a: Union[str, int, None], b: Optional[str] = None) -> str:
  ...
</code><code language="python">No:
def nullable_union(a: Union[None, str]) -> str:
  ...
def implicit_optional(a: str = None) -> str:
  ...
</code><heading level="4">3.19.6 Type Aliases</heading><paragraph>You can declare aliases of complex types. The name of an alias should be CapWorded. If the alias is used only in this module, it should be _Private.</paragraph><paragraph>Note that the : TypeAlias annotation is only supported in versions 3.10+.</paragraph><code language="python">from typing import TypeAlias

_LossAndGradient: TypeAlias = tuple[tf.Tensor, tf.Tensor]
ComplexTFMap: TypeAlias = Mapping[str, _LossAndGradient]
</code><heading level="4">3.19.7 Ignoring Types</heading><paragraph>You can disable type checking on a line with the special comment # type: ignore.</paragraph><paragraph>pytype has a disable option for specific errors (similar to lint):</paragraph><code language="code"># pytype: disable=attribute-error
</code><heading level="4">3.19.8 Typing Variables</heading><code language="code">a: Foo = SomeUndecoratedFunction()
</code><code language="code">a = SomeUndecoratedFunction()  # type: Foo
</code><heading level="4">3.19.9 Tuples vs Lists</heading><paragraph>Typed lists can only contain objects of a single type. Typed tuples can either have a single repeated type or a set number of elements with different types. The latter is commonly used as the return type from a function.</paragraph><code language="code">a: list[int] = [1, 2, 3]
b: tuple[int, ...] = (1, 2, 3)
c: tuple[int, str, float] = (1, "2", 3.5)
</code><heading level="4">3.19.10 Type variables</heading><paragraph>The Python type system has generics. A type variable, such as TypeVar and ParamSpec, is a common way to use them.</paragraph><paragraph>Example:</paragraph><code language="python">from collections.abc import Callable
from typing import ParamSpec, TypeVar
_P = ParamSpec("_P")
_T = TypeVar("_T")
...
def next(l: list[_T]) -> _T:
  return l.pop()

def print_when_called(f: Callable[_P, _T]) -> Callable[_P, _T]:
  def inner(*args: _P.args, **kwargs: _P.kwargs) -> _T:
    print("Function was called")
    return f(*args, **kwargs)
  return inner
</code><paragraph>A TypeVar can be constrained:</paragraph><code language="python">AddableType = TypeVar("AddableType", int, float, str)
def add(a: AddableType, b: AddableType) -> AddableType:
  return a + b
</code><paragraph>A common predefined type variable in the typing module is AnyStr. Use it for multiple annotations that can be bytes or str and must all be the same type.</paragraph><code language="python">from typing import AnyStr
def check_length(x: AnyStr) -> AnyStr:
  if len(x) <= 42:
    return x
  raise ValueError()
</code><paragraph>A type variable must have a descriptive name, unless it meets all of the following criteria:</paragraph><list type="ul"><item>not externally visible</item><item>not constrained</item></list><code language="code">Yes:
  _T = TypeVar("_T")
  _P = ParamSpec("_P")
  AddableType = TypeVar("AddableType", int, float, str)
  AnyFunction = TypeVar("AnyFunction", bound=Callable)
</code><code language="code">No:
  T = TypeVar("T")
  P = ParamSpec("P")
  _T = TypeVar("_T", int, float, str)
  _F = TypeVar("_F", bound=Callable)
</code><heading level="4">3.19.11 String types</heading><paragraph>Do not use typing.Text in new code. It's only for Python 2/3 compatibility.</paragraph><paragraph>Use str for string/text data. For code that deals with binary data, use bytes.</paragraph><code language="python">def deals_with_text_data(x: str) -> str:
  ...
def deals_with_binary_data(x: bytes) -> bytes:
  ...
</code><paragraph>If all the string types of a function are always the same, for example if the return type is the same as the argument type in the code above, use AnyStr.</paragraph><heading level="4">3.19.12 Imports For Typing</heading><paragraph>For symbols (including types, functions, and constants) from the typing or collections.abc modules used to support static analysis and type checking, always import the symbol itself. This keeps common annotations more concise and matches typing practices used around the world. You are explicitly allowed to import multiple specific symbols on one line from the typing and collections.abc modules. For example:</paragraph><code language="python">from collections.abc import Mapping, Sequence
from typing import Any, Generic, cast, TYPE_CHECKING
</code><paragraph>Given that this way of importing adds items to the local namespace, names in typing or collections.abc should be treated similarly to keywords, and not be defined in your Python code, typed or not. If there is a collision between a type and an existing name in a module, import it using import x as y.</paragraph><code language="python">from typing import Any as AnyType
</code><paragraph>When annotating function signatures, prefer abstract container types like collections.abc.Sequence over concrete types like list. If you need to use a concrete type (for example, a tuple of typed elements), prefer built-in types like tuple over the parametric type aliases from the typing module (e.g., typing.Tuple).</paragraph><code language="python">from typing import List, Tuple

def transform_coordinates(original: List[Tuple[float, float]]) ->
    List[Tuple[float, float]]:
  ...
</code><code language="python">from collections.abc import Sequence

def transform_coordinates(original: Sequence[tuple[float, float]]) ->
    Sequence[tuple[float, float]]:
  ...
</code><heading level="4">3.19.13 Conditional Imports</heading><paragraph>Use conditional imports only in exceptional cases where the additional imports needed for type checking must be avoided at runtime. This pattern is discouraged; alternatives such as refactoring the code to allow top-level imports should be preferred.</paragraph><paragraph>Imports that are needed only for type annotations can be placed within an if TYPE_CHECKING: block.</paragraph><list type="ul"><item>Conditionally imported types need to be referenced as strings, to be forward compatible with Python 3.6 where the annotation expressions are actually evaluated.</item><item>Only entities that are used solely for typing should be defined here; this includes aliases. Otherwise it will be a runtime error, as the module will not be imported at runtime.</item><item>The block should be right after all the normal imports.</item><item>There should be no empty lines in the typing imports list.</item><item>Sort this list as if it were a regular imports list. import typing if typing.TYPE_CHECKING: import sketch def f(x: "sketch.Sketch"): ...</item></list><code language="python">import typing
if typing.TYPE_CHECKING:
  import sketch
def f(x: "sketch.Sketch"): ...
</code><heading level="4">3.19.14 Circular Dependencies</heading><paragraph>Circular dependencies that are caused by typing are code smells. Such code is a good candidate for refactoring. Although technically it is possible to keep circular dependencies, various build systems will not let you do so because each module has to depend on the other.</paragraph><paragraph>Replace modules that create circular dependency imports with Any. Set an alias with a meaningful name, and use the real type name from this module (any attribute of Any is Any). Alias definitions should be separated from the last import by one line.</paragraph><code language="python">from typing import Any

some_mod = Any  # some_mod.py imports this module.
...

def my_method(self, var: "some_mod.SomeType") -> None:
  ...
</code><heading level="4">3.19.15 Generics</heading><paragraph>When annotating, prefer to specify type parameters for generic types in a parameter list; otherwise, the generics' parameters will be assumed to be Any.</paragraph><code language="python"># Yes:
def get_names(employee_ids: Sequence[int]) -> Mapping[int, str]:
  ...
</code><code language="python"># No:
# This is interpreted as get_names(employee_ids: Sequence[Any]) -> Mapping[Any, Any]
def get_names(employee_ids: Sequence) -> Mapping:
  ...
</code><paragraph>If the best type parameter for a generic is Any, make it explicit, but remember that in many cases TypeVar might be more appropriate:</paragraph><code language="python"># No:
def get_names(employee_ids: Sequence[Any]) -> Mapping[Any, str]:
  """Returns a mapping from employee ID to employee name for given IDs."""
</code><code language="python"># Yes:
_T = TypeVar('_T')
def get_names(employee_ids: Sequence[_T]) -> Mapping[_T, str]:
  """Returns a mapping from employee ID to employee name for given IDs."""
</code><heading level="2">4 Parting Words</heading><paragraph>BE CONSISTENT.</paragraph><paragraph>If you're editing code, take a few minutes to look at the code around you and determine its style. If they use _idx suffixes in index variable names, you should too. If their comments have little boxes of hash marks around them, make your comments have little boxes of hash marks around them too.</paragraph><paragraph>The point of having style guidelines is to have a common vocabulary of coding so people can concentrate on what you're saying rather than on how you're saying it. We present global style rules here so people know the vocabulary, but local style is also important. If code you add to a file looks drastically different from the existing code around it, it throws readers out of their rhythm when they go to read it.</paragraph><paragraph>However, there are limits to consistency. It applies more heavily locally and on choices unspecified by the global style. Consistency should not generally be used as a justification to do things in an old style without considering the benefits of the new style, or the tendency of the codebase to converge on newer styles over time.</paragraph></content>
</page>
<page url="https://google.github.io/styleguide/Rguide.html">
<title>Google's R Style Guide | styleguide</title>
<content><heading level="1">Google's R Style Guide</heading><paragraph>R is a high-level programming language used primarily for statistical computing and graphics. The goal of the R Programming Style Guide is to make our R code easier to read, share, and verify.</paragraph><paragraph>The Google R Style Guide is a fork of the Tidyverse Style Guide by Hadley Wickham license. Google modifications were developed in collaboration with the internal R user community. The rest of this document explains Google's primary differences with the Tidyverse guide, and why these differences exist.</paragraph><heading level="2">Syntax</heading><heading level="3">Naming conventions</heading><paragraph>Google prefers identifying functions with BigCamelCase to clearly distinguish them from other objects.</paragraph><code language="javascript"># Good
DoNothing <- function() {
  return(invisible(NULL))
}
</code><paragraph>The names of private functions should begin with a dot. This helps communicate both the origin of the function and its intended use.</paragraph><code language="javascript"># Good
.DoNothingPrivately <- function() {
  return(invisible(NULL))
}
</code><paragraph>We previously recommended naming objects with dot.case. We're moving away from that, as it creates confusion with S3 methods.</paragraph><heading level="3">Don't use attach()</heading><paragraph>The possibilities for creating errors when using attach() are numerous.</paragraph><heading level="2">Pipes</heading><heading level="3">Right-hand assignment</heading><paragraph>We do not support using right-hand assignment.</paragraph><code language="code"># Bad
iris %>%
  dplyr::summarize(max_petal = max(Petal.Width)) -> results
</code><paragraph>This convention differs substantially from practices in other languages and makes it harder to see in code where an object is defined. E.g. searching for foo <- is easier than searching for foo <- and -> foo (possibly split over lines).</paragraph><heading level="3">Use explicit returns</heading><paragraph>Do not rely on R's implicit return feature. It is better to be clear about your intent to return() an object.</paragraph><code language="javascript"># Good
AddValues <- function(x, y) {
  return(x + y)
}

# Bad
AddValues <- function(x, y) {
  x + y
}
</code><heading level="3">Qualifying namespaces</heading><paragraph>Users should explicitly qualify namespaces for all external functions.</paragraph><paragraph>We discourage using the @import Roxygen tag to bring in all functions into a NAMESPACE. Google has a very big R codebase, and importing all functions creates too much risk for name collisions.</paragraph><paragraph>While there is a small performance penalty for using ::, it makes it easier to understand dependencies in your code. There are some exceptions to this rule.</paragraph><list type="ul"><item>Infix functions (%name%) always need to be imported.</item><item>Certain rlang pronouns, notably .data, need to be imported.</item><item>Functions from default R packages, including datasets, utils, grDevices, graphics, stats and methods. If needed, you can @import the full package.</item></list><paragraph>When importing functions, place the @importFrom tag in the Roxygen header above the function where the external dependency is used.</paragraph><heading level="2">Documentation</heading><heading level="3">Package-level documentation</heading><paragraph>All packages should have a package documentation file, in a packagename-package.R file.</paragraph></content>
</page>
<page url="https://google.github.io/styleguide/shellguide.html">
<title>styleguide | Style guides for Google-originated open-source projects</title>
<content><heading level="1">Shell Style Guide</heading><paragraph>Authored, revised and maintained by many Googlers.</paragraph><heading level="2">Table of Contents</heading><heading level="2">Background</heading><heading level="3">Which Shell to Use</heading><paragraph>Bash is the only shell scripting language permitted for executables.</paragraph><paragraph>Executables must start with #!/bin/bash and minimal flags. Use set to set shell options so that calling your script as bash script_name does not break its functionality.</paragraph><paragraph>Restricting all executable shell scripts to bash gives us a consistent shell language that's installed on all our machines. In particular, this means there is generally no need to strive for POSIX-compatibility or otherwise avoid "bashisms".</paragraph><paragraph>The only exception to the above is where you're forced to by whatever you're coding for. For example some legacy operating systems or constrained execution environments may require plain Bourne shell for certain scripts.</paragraph><heading level="3">When to use Shell</heading><paragraph>Shell should only be used for small utilities or simple wrapper scripts.</paragraph><paragraph>While shell scripting isn't a development language, it is used for writing various utility scripts throughout Google. This style guide is more a recognition of its use rather than a suggestion that it be used for widespread deployment.</paragraph><paragraph>Some guidelines:</paragraph><list type="ul"><item>If you're mostly calling other utilities and are doing relatively little data manipulation, shell is an acceptable choice for the task.</item><item>If performance matters, use something other than shell.</item><item>If you are writing a script that is more than 100 lines long, or that uses non-straightforward control flow logic, you should rewrite it in a more structured language now. Bear in mind that scripts grow. Rewrite your script early to avoid a more time-consuming rewrite at a later date.</item><item>When assessing the complexity of your code (e.g. to decide whether to switch languages) consider whether the code is easily maintainable by people other than its author.</item></list><heading level="2">Shell Files and Interpreter Invocation</heading><heading level="3">File Extensions</heading><paragraph>Executables should have a .sh extension or no extension.</paragraph><list type="ul"><item>If the executable will have a build rule that renames the source file then prefer to use a .sh extension. This enables you to use the recommended naming convention, with a source file like foo.sh and a build rule named foo.</item><item>If the executable will be added directly to the user's PATH, then prefer to use no extension. It is not necessary to know what language a program is written in when executing it and shell doesn't require an extension so we prefer not to use one for executables that will be directly invoked by users. At the same time, consider whether it is preferable to deploy the output of a build rule rather than deploying the source file directly.</item><item>If neither of the above apply, then either choice is acceptable.</item></list><paragraph>Libraries must have a .sh extension and should not be executable.</paragraph><heading level="3">SUID/SGID</heading><paragraph>SUID and SGID are forbidden on shell scripts.</paragraph><paragraph>There are too many security issues with shell that make it nearly impossible to secure sufficiently to allow SUID/SGID. While bash does make it difficult to run SUID, it's still possible on some platforms which is why we're being explicit about banning it.</paragraph><paragraph>Use sudo to provide elevated access if you need it.</paragraph><heading level="2">Environment</heading><heading level="3">STDOUT vs STDERR</heading><paragraph>All error messages should go to STDERR.</paragraph><paragraph>This makes it easier to separate normal status from actual issues.</paragraph><paragraph>A function to print out error messages along with other status information is recommended.</paragraph><code language="javascript">err() {
  echo "[$(date +'%Y-%m-%dT%H:%M:%S%z')]: $*" >&2
}

if ! do_something; then
  err "Unable to do_something"
  exit 1
fi
</code><paragraph>Start each file with a description of its contents.</paragraph><paragraph>Every file must have a top-level comment including a brief overview of its contents. A copyright notice and author information are optional.</paragraph><paragraph>Example:</paragraph><code language="code">#!/bin/bash
#
# Perform hot backups of Oracle databases.
</code><paragraph>Any function that is not both obvious and short must have a function header comment. Any function in a library must have a function header comment regardless of length or complexity.</paragraph><paragraph>It should be possible for someone else to learn how to use your program or to use a function in your library by reading the comments (and self-help, if provided) without reading the code.</paragraph><paragraph>All function header comments should describe the intended API behaviour using:</paragraph><list type="ul"><item>Description of the function.</item><item>Globals: List of global variables used and modified.</item><item>Arguments: Arguments taken.</item><item>Outputs: Output to STDOUT or STDERR.</item><item>Returns: Returned values other than the default exit status of the last command run.</item></list><paragraph>Example:</paragraph><code language="javascript">#######################################
# Cleanup files from the backup directory.
# Globals:
#   BACKUP_DIR
#   ORACLE_SID
# Arguments:
#   None
#######################################
function cleanup() {
  …
}

#######################################
# Get configuration directory.
# Globals:
#   SOMEDIR
# Arguments:
#   None
# Outputs:
#   Writes location to stdout
#######################################
function get_dir() {
  echo "${SOMEDIR}"
}

#######################################
# Delete a file in a sophisticated manner.
# Arguments:
#   File to delete, a path.
# Returns:
#   0 if thing was deleted, non-zero on error.
#######################################
function del_thing() {
  rm "$1"
}
</code><paragraph>Comment tricky, non-obvious, interesting or important parts of your code.</paragraph><paragraph>This follows general Google coding comment practice. Don't comment everything. If there's a complex algorithm or you're doing something out of the ordinary, put a short comment in.</paragraph><paragraph>Use TODO comments for code that is temporary, a short-term solution, or good-enough but not perfect.</paragraph><paragraph>This matches the convention in the C++ Guide.</paragraph><paragraph>TODOs should include the string TODO in all caps, followed by the name, e-mail address, or other identifier of the person with the best context about the problem referenced by the TODO. The main purpose is to have a consistent TODO that can be searched to find out how to get more details upon request. A TODO is not a commitment that the person referenced will fix the problem. Thus when you create a TODO, it is almost always your name that is given.</paragraph><paragraph>Examples:</paragraph><code language="code"># TODO(mrmonkey): Handle the unlikely edge cases (bug ####)
</code><heading level="2">Formatting</heading><paragraph>While you should follow the style that's already there for files that you're modifying, the following are required for any new code.</paragraph><heading level="3">Indentation</heading><paragraph>Indent 2 spaces. No tabs.</paragraph><paragraph>Use blank lines between blocks to improve readability. Indentation is two spaces. Whatever you do, don't use tabs. For existing files, stay faithful to the existing indentation.</paragraph><paragraph>Exception: The only exception for using tabs is for the body of <<- tab-indented here-document.</paragraph><heading level="3">Line Length and Long Strings</heading><paragraph>Maximum line length is 80 characters.</paragraph><paragraph>If you have to write literal strings that are longer than 80 characters, this should be done with a here document or an embedded newline if possible.</paragraph><paragraph>Words that are longer than 80 chars and can't sensibly be split are ok, but where possible these items should be on a line of their own, or factored into a variable. Examples include file paths and URLs, particularly where string-matching them (such as grep) is valuable for maintenance.</paragraph><code language="code"># DO use 'here document's
cat <<END
I am an exceptionally long
string.
END

# Embedded newlines are ok too
long_string="I am an exceptionally
long string."

long_file="/i/am/an/exceptionally/loooooooooooooooooooooooooooooooooooooooooooooooooooong_file"

long_string_with_long_file="i am including an exceptionally \
/very/long/file\
 in this long string."

# Long file converted into a shorter variable name with cleaner line breaking.
long_string_alt="i am an including an exceptionally ${long_file} in this long\
 string"
</code><code language="code"># Just because a line contains an exception doesn't mean the rest of the
# line shouldn't be wrapped like usual.

bad_long_string_with_long_file="i am including an exceptionally /very/long/file in this long string."
</code><heading level="3">Pipelines</heading><paragraph>Pipelines should be split one per line if they don't all fit on one line.</paragraph><paragraph>If a pipeline all fits on one line, it should be on one line.</paragraph><paragraph>If not, it should be split at one pipe segment per line with the pipe on the newline and a 2 space indent for the next section of the pipe. \ should be consistently used to indicate line continuation. This applies to a chain of commands combined using | as well as to logical compounds using || and &&.</paragraph><code language="code"># All fits on one line
command1 | command2

# Long commands
command1 \
  | command2 \
  | command3 \
  | command4
</code><paragraph>This helps readability when distinguishing a pipeline from a regular long command continuation, particularly if the line is using both.</paragraph><paragraph>Comments will need to precede the whole pipeline. If the comment and pipeline are large and complex, then it is worth considering moving low level details of them aside by using a helper function.</paragraph><heading level="3">Control Flow</heading><paragraph>Put ; then and ; do on the same line as the if, for, or while.</paragraph><paragraph>Control flow statements in shell are a bit different, but we follow the same principles as with braces when declaring functions. That is: ; then and ; do should be on the same line as the if/for/while/until/select. else should be on its own line and closing statements (fi and done) should be on their own line vertically aligned with the opening statement.</paragraph><paragraph>Example:</paragraph><code language="code"># If inside a function remember to declare the loop variable as
# a local to avoid it leaking into the global environment:
local dir
for dir in "${dirs_to_cleanup[@]}"; do
  if [[ -d "${dir}/${SESSION_ID}" ]]; then
    log_date "Cleaning up old files in ${dir}/${SESSION_ID}"
    rm "${dir}/${SESSION_ID}/"* || error_message
  else
    mkdir -p "${dir}/${SESSION_ID}" || error_message
  fi
done
</code><paragraph>Although it is possible to omit in "$@" in for loops we recommend consistently including it for clarity.</paragraph><code language="code">for arg in "$@"; do
  echo "argument: ${arg}"
done
</code><heading level="3">Case statement</heading><list type="ul"><item>Indent alternatives by 2 spaces.</item><item>A one-line alternative needs a space after the close parenthesis of the pattern and before the ;;.</item><item>Long or multi-command alternatives should be split over multiple lines with the pattern, actions, and ;; on separate lines.</item></list><paragraph>The matching expressions are indented one level from the case and esac. Multiline actions are indented another level. In general, there is no need to quote match expressions. Pattern expressions should not be preceded by an open parenthesis. Avoid the ;& and ;;& notations.</paragraph><code language="code">case "${expression}" in
  a)
    variable="…"
    some_command "${variable}" "${other_expr}" …
    ;;
  absolute)
    actions="relative"
    another_command "${actions}" "${other_expr}" …
    ;;
  *)
    error "Unexpected expression '${expression}'"
    ;;
esac
</code><paragraph>Simple commands may be put on the same line as the pattern and ;; as long as the expression remains readable. This is often appropriate for single-letter option processing. When the actions don't fit on a single line, put the pattern on a line on its own, then the actions, then ;; also on a line of its own. When on the same line as the actions, use a space after the close parenthesis of the pattern and another before the ;;.</paragraph><code language="code">verbose='false'
aflag=''
bflag=''
files=''
while getopts 'abf:v' flag; do
  case "${flag}" in
    a) aflag='true' ;;
    b) bflag='true' ;;
    f) files="${OPTARG}" ;;
    v) verbose='true' ;;
    *) error "Unexpected option ${flag}" ;;
  esac
done
</code><heading level="3">Variable expansion</heading><paragraph>In order of precedence: Stay consistent with what you find; quote your variables; prefer "${var}" over "$var".</paragraph><paragraph>These are strongly recommended guidelines but not mandatory regulation. Nonetheless, the fact that it's a recommendation and not mandatory doesn't mean it should be taken lightly or downplayed.</paragraph><paragraph>They are listed in order of precedence.</paragraph><list type="ul"><item>Stay consistent with what you find for existing code.</item><item>Quote variables, see Quoting section below.</item><item>Don't brace-delimit single character shell specials / positional parameters, unless strictly necessary or avoiding deep confusion.</item></list><paragraph>Prefer brace-delimiting all other variables.</paragraph><code language="code"># Section of *recommended* cases.

# Preferred style for 'special' variables:
echo "Positional: $1" "$5" "$3"
echo "Specials: !=$!, -=$-, _=$_. ?=$?, #=$# *=$* @=$@ \$=$$ …"

# Braces necessary:
echo "many parameters: ${10}"

# Braces avoiding confusion:
# Output is "a0b0c0"
set -- a b c
echo "${1}0${2}0${3}0"

# Preferred style for other variables:
echo "PATH=${PATH}, PWD=${PWD}, mine=${some_var}"
while read -r f; do
  echo "file=${f}"
done < <(find /tmp)
</code><code language="code"># Section of *discouraged* cases

# Unquoted vars, unbraced vars, brace-delimited single letter
# shell specials.
echo a=$avar "b=$bvar" "PID=${$}" "${1}"

# Confusing use: this is expanded as "${1}0${2}0${3}0",
# not "${10}${20}${30}
set -- a b c
echo "$10$20$30"
</code><paragraph>NOTE: Using braces in ${var} is not a form of quoting. "Double quotes" must be used as well.</paragraph><heading level="3">Quoting</heading><list type="ul"><item>Always quote strings containing variables, command substitutions, spaces or shell meta characters, unless careful unquoted expansion is required or it's a shell-internal integer (see next point).</item><item>Use arrays for safe quoting of lists of elements, especially command-line flags. See Arrays below.</item><item>Optionally quote shell-internal, readonly special variables that are defined to be integers: $?, $#, $$, $!. Prefer quoting of "named" internal integer variables, e.g. PPID etc for consistency.</item><item>Prefer quoting strings that are "words" (as opposed to command options or path names).</item><item>Be aware of the quoting rules for pattern matches in [[ … ]]. See the Test, [ … ], and [[ … ]] section below.</item><item>Use "$@" unless you have a specific reason to use $*, such as simply appending the arguments to a string in a message or log.</item></list><code language="code"># 'Single' quotes indicate that no substitution is desired.
# "Double" quotes indicate that substitution is required/tolerated.

# Simple examples

# "quote command substitutions"
# Note that quotes nested inside "$()" don't need escaping.
flag="$(some_command and its args "$@" 'quoted separately')"

# "quote variables"
echo "${flag}"

# Use arrays with quoted expansion for lists.
declare -a FLAGS
FLAGS=( --foo --bar='baz' )
readonly FLAGS
mybinary "${FLAGS[@]}"

# It's ok to not quote internal integer variables.
if (( $# > 3 )); then
  echo "ppid=${PPID}"
fi

# "never quote literal integers"
value=32
# "quote command substitutions", even when you expect integers
number="$(generate_number)"

# "prefer quoting words", not compulsory
readonly USE_INTEGER='true'

# "quote shell meta characters"
echo 'Hello stranger, and well met. Earn lots of $$$'
echo "Process $$: Done making \$\$\$."

# "command options or path names"
# ($1 is assumed to contain a value here)
grep -li Hugo /dev/null "$1"

# Less simple examples
# "quote variables, unless proven false": ccs might be empty
git send-email --to "${reviewers}" ${ccs:+"--cc" "${ccs}"}

# Positional parameter precautions: $1 might be unset
# Single quotes leave regex as-is.
grep -cP '([Ss]pecial|\|?characters*)$' ${1:+"$1"}

# For passing on arguments,
# "$@" is right almost every time, and
# $* is wrong almost every time:
#
# * $* and $@ will split on spaces, clobbering up arguments
#   that contain spaces and dropping empty strings;
# * "$@" will retain arguments as-is, so no args
#   provided will result in no args being passed on;
#   This is in most cases what you want to use for passing
#   on arguments.
# * "$*" expands to one argument, with all args joined
#   by (usually) spaces,
#   so no args provided will result in one empty string
#   being passed on.
#
# Consult
# https://www.gnu.org/software/bash/manual/html_node/Special-Parameters.html and
# https://mywiki.wooledge.org/BashGuide/Arrays for more

(set -- 1 "2 two" "3 three tres"; echo $#; set -- "$*"; echo "$#, $@")
(set -- 1 "2 two" "3 three tres"; echo $#; set -- "$@"; echo "$#, $@")
</code><heading level="2">Features and Bugs</heading><heading level="3">ShellCheck</heading><paragraph>The ShellCheck project identifies common bugs and warnings for your shell scripts. It is recommended for all scripts, large or small.</paragraph><heading level="3">Command Substitution</heading><paragraph>Use $(command) instead of backticks.</paragraph><paragraph>Nested backticks require escaping the inner ones with \ . The $(command) format doesn't change when nested and is easier to read.</paragraph><paragraph>Example:</paragraph><code language="code"># This is preferred:
var="$(command "$(command1)")"
</code><code language="code"># This is not:
var="`command \`command1\``"
</code><heading level="3">Test, [ … ], and [[ … ]]</heading><paragraph>[[ … ]] is preferred over [ … ], test and /usr/bin/[.</paragraph><paragraph>[[ … ]] reduces errors as no pathname expansion or word splitting takes place between [[ and ]]. In addition, [[ … ]] allows for pattern and regular expression matching, while [ … ] does not.</paragraph><code language="code"># This ensures the string on the left is made up of characters in
# the alnum character class followed by the string name.
# Note that the RHS should not be quoted here.
if [[ "filename" =~ ^[[:alnum:]]+name ]]; then
  echo "Match"
fi

# This matches the exact pattern "f*" (Does not match in this case)
if [[ "filename" == "f*" ]]; then
  echo "Match"
fi
</code><code language="code"># This gives a "too many arguments" error as f* is expanded to the
# contents of the current directory. It might also trigger the
# "unexpected operator" error because `[` does not support `==`, only `=`.
if [ "filename" == f* ]; then
  echo "Match"
fi
</code><paragraph>For the gory details, see E14 in the Bash FAQ</paragraph><heading level="3">Testing Strings</heading><paragraph>Use quotes rather than filler characters where possible.</paragraph><paragraph>Bash is smart enough to deal with an empty string in a test. So, given that the code is much easier to read, use tests for empty/non-empty strings or empty strings rather than filler characters.</paragraph><code language="code"># Do this:
if [[ "${my_var}" == "some_string" ]]; then
  do_something
fi

# -z (string length is zero) and -n (string length is not zero) are
# preferred over testing for an empty string
if [[ -z "${my_var}" ]]; then
  do_something
fi

# This is OK (ensure quotes on the empty side), but not preferred:
if [[ "${my_var}" == "" ]]; then
  do_something
fi
</code><code language="code"># Not this:
if [[ "${my_var}X" == "some_stringX" ]]; then
  do_something
fi
</code><paragraph>To avoid confusion about what you're testing for, explicitly use -z or -n.</paragraph><code language="code"># Use this
if [[ -n "${my_var}" ]]; then
  do_something
fi
</code><code language="code"># Instead of this
if [[ "${my_var}" ]]; then
  do_something
fi
</code><paragraph>For clarity, use == for equality rather than = even though both work. The former encourages the use of [[ and the latter can be confused with an assignment. However, be careful when using < and > in [[ … ]] which performs a lexicographical comparison. Use (( … )) or -lt and -gt for numerical comparison.</paragraph><code language="code"># Use this
if [[ "${my_var}" == "val" ]]; then
  do_something
fi

if (( my_var > 3 )); then
  do_something
fi

if [[ "${my_var}" -gt 3 ]]; then
  do_something
fi
</code><code language="code"># Instead of this
if [[ "${my_var}" = "val" ]]; then
  do_something
fi

# Probably unintended lexicographical comparison.
if [[ "${my_var}" > 3 ]]; then
  # True for 4, false for 22.
  do_something
fi
</code><heading level="3">Wildcard Expansion of Filenames</heading><paragraph>Use an explicit path when doing wildcard expansion of filenames.</paragraph><paragraph>As filenames can begin with a -, it's a lot safer to expand wildcards with ./* instead of *.</paragraph><code language="code"># Here's the contents of the directory:
# -f  -r  somedir  somefile

# Incorrectly deletes almost everything in the directory by force
psa@bilby$ rm -v *
removed directory: `somedir'
removed `somefile'
</code><code language="code"># As opposed to:
psa@bilby$ rm -v ./*
removed `./-f'
removed `./-r'
rm: cannot remove `./somedir': Is a directory
removed `./somefile'
</code><heading level="3">Eval</heading><paragraph>eval should be avoided.</paragraph><paragraph>Eval munges the input when used for assignment to variables and can set variables without making it possible to check what those variables were.</paragraph><code language="code"># What does this set?
# Did it succeed? In part or whole?
eval $(set_my_variables)

# What happens if one of the returned values has a space in it?
variable="$(eval some_function)"
</code><heading level="3">Arrays</heading><paragraph>Bash arrays should be used to store lists of elements, to avoid quoting complications. This particularly applies to argument lists. Arrays should not be used to facilitate more complex data structures (see When to use Shell above).</paragraph><paragraph>Arrays store an ordered collection of strings, and can be safely expanded into individual elements for a command or loop.</paragraph><paragraph>Using a single string for multiple command arguments should be avoided, as it inevitably leads to authors using eval or trying to nest quotes inside the string, which does not give reliable or readable results and leads to needless complexity.</paragraph><code language="code"># An array is assigned using parentheses, and can be appended to
# with +=( … ).
declare -a flags
flags=(--foo --bar='baz')
flags+=(--greeting="Hello ${name}")
mybinary "${flags[@]}"
</code><code language="code"># Don’t use strings for sequences.
flags='--foo --bar=baz'
flags+=' --greeting="Hello world"'  # This won’t work as intended.
mybinary ${flags}
</code><code language="code"># Command expansions return single strings, not arrays. Avoid
# unquoted expansion in array assignments because it won’t
# work correctly if the command output contains special
# characters or whitespace.

# This expands the listing output into a string, then does special keyword
# expansion, and then whitespace splitting.  Only then is it turned into a
# list of words.  The ls command may also change behavior based on the user's
# active environment!
declare -a files=($(ls /directory))

# The get_arguments writes everything to STDOUT, but then goes through the
# same expansion process above before turning into a list of arguments.
mybinary $(get_arguments)
</code><heading level="4">Arrays Pros</heading><list type="ul"><item>Using Arrays allows lists of things without confusing quoting semantics. Conversely, not using arrays leads to misguided attempts to nest quoting inside a string.</item><item>Arrays make it possible to safely store sequences/lists of arbitrary strings, including strings containing whitespace.</item></list><heading level="4">Arrays Cons</heading><paragraph>Using arrays can risk a script's complexity growing.</paragraph><heading level="4">Arrays Decision</heading><paragraph>Arrays should be used to safely create and pass around lists. In particular, when building a set of command arguments, use arrays to avoid confusing quoting issues. Use quoted expansion – "${array[@]}" – to access arrays. However, if more advanced data manipulation is required, shell scripting should be avoided altogether; see above.</paragraph><heading level="3">Pipes to While</heading><paragraph>Use process substitution or the readarray builtin (bash4+) in preference to piping to while. Pipes create a subshell, so any variables modified within a pipeline do not propagate to the parent shell.</paragraph><paragraph>The implicit subshell in a pipe to while can introduce subtle bugs that are hard to track down.</paragraph><code language="code">last_line='NULL'
your_command | while read -r line; do
  if [[ -n "${line}" ]]; then
    last_line="${line}"
  fi
done

# This will always output 'NULL'!
echo "${last_line}"
</code><paragraph>Using process substitution also creates a subshell. However, it allows redirecting from a subshell to a while without putting the while (or any other command) in a subshell.</paragraph><code language="code">last_line='NULL'
while read line; do
  if [[ -n "${line}" ]]; then
    last_line="${line}"
  fi
done < <(your_command)

# This will output the last non-empty line from your_command
echo "${last_line}"
</code><paragraph>Alternatively, use the readarray builtin to read the file into an array, then loop over the array's contents. Notice that (for the same reason as above) you need to use a process substitution with readarray rather than a pipe, but with the advantage that the input generation for the loop is located before it, rather than after.</paragraph><code language="code">last_line='NULL'
readarray -t lines < <(your_command)
for line in "${lines[@]}"; do
  if [[ -n "${line}" ]]; then
    last_line="${line}"
  fi
done
echo "${last_line}"
</code><paragraph>Note: Be cautious using a for-loop to iterate over output, as in for var in $(...), as the output is split by whitespace, not by line. Sometimes you will know this is safe because the output can't contain any unexpected whitespace, but where this isn't obvious or doesn't improve readability (such as a long command inside $(...)), a while read loop or readarray is often safer and clearer.</paragraph><heading level="3">Arithmetic</heading><paragraph>Always use (( … )) or $(( … )) rather than let or $[ … ] or expr.</paragraph><paragraph>Never use the $[ … ] syntax, the expr command, or the let built-in.</paragraph><paragraph>< and > don't perform numerical comparison inside [[ … ]] expressions (they perform lexicographical comparisons instead; see Testing Strings). For preference, don't use [[ … ]] at all for numeric comparisons, use (( … )) instead.</paragraph><paragraph>It is recommended to avoid using (( … )) as a standalone statement, and otherwise be wary of its expression evaluating to zero</paragraph><list type="ul"><item>particularly with set -e enabled. For example, set -e; i=0; (( i++ )) will cause the shell to exit.</item></list><code language="code"># Simple calculation used as text - note the use of $(( … )) within
# a string.
echo "$(( 2 + 2 )) is 4"

# When performing arithmetic comparisons for testing
if (( a < b )); then
  …
fi

# Some calculation assigned to a variable.
(( i = 10 * j + 400 ))
</code><code language="javascript"># This form is non-portable and deprecated
i=$[2 * 10]

# Despite appearances, 'let' isn't one of the declarative keywords,
# so unquoted assignments are subject to globbing wordsplitting.
# For the sake of simplicity, avoid 'let' and use (( … ))
let i="2 + 2"

# The expr utility is an external program and not a shell builtin.
i=$( expr 4 + 4 )

# Quoting can be error prone when using expr too.
i=$( expr 4 '*' 4 )
</code><paragraph>Stylistic considerations aside, the shell's built-in arithmetic is many times faster than expr.</paragraph><paragraph>When using variables, the ${var} (and $var) forms are not required within $(( … )). The shell knows to look up var for you, and omitting the ${…} leads to cleaner code. This is slightly contrary to the previous rule about always using braces, so this is a recommendation only.</paragraph><code language="code"># N.B.: Remember to declare your variables as integers when
# possible, and to prefer local variables over globals.
local -i hundred="$(( 10 * 10 ))"
declare -i five="$(( 10 / 2 ))"

# Increment the variable "i" by three.
# Note that:
#  - We do not write ${i} or $i.
#  - We put a space after the (( and before the )).
(( i += 3 ))

# To decrement the variable "i" by five:
(( i -= 5 ))

# Do some complicated computations.
# Note that normal arithmetic operator precedence is observed.
hr=2
min=5
sec=30
echo "$(( hr * 3600 + min * 60 + sec ))" # prints 7530 as expected
</code><heading level="2">Aliases</heading><paragraph>Although commonly seen in .bashrc files, aliases should be avoided in scripts. As the Bash manual notes:</paragraph><paragraph>For almost every purpose, shell functions are preferred over aliases.</paragraph><paragraph>Aliases are cumbersome to work with because they require carefully quoting and escaping their contents, and mistakes can be hard to notice.</paragraph><code language="code"># this evaluates $RANDOM once when the alias is defined,
# so the echo'ed string will be the same on each invocation
alias random_name="echo some_prefix_${RANDOM}"
</code><paragraph>Functions provide a superset of alias' functionality and should always be preferred. .</paragraph><code language="javascript">random_name() {
  echo "some_prefix_${RANDOM}"
}

# Note that unlike aliases function's arguments are accessed via $@
fancy_ls() {
  ls -lh "$@"
}
</code><heading level="2">Naming Conventions</heading><heading level="3">Function Names</heading><paragraph>Lower-case, with underscores to separate words. Separate libraries with ::. Parentheses are required after the function name. The keyword function is optional, but must be used consistently throughout a project.</paragraph><paragraph>If you're writing single functions, use lowercase and separate words with underscore. If you're writing a package, separate package names with ::. However, functions intended for interactive use may choose to avoid colons as it can confuse bash auto-completion.</paragraph><paragraph>Braces must be on the same line as the function name (as with other languages at Google) and no space between the function name and the parenthesis.</paragraph><code language="javascript"># Single function
my_func() {
  …
}

# Part of a package
mypackage::my_func() {
  …
}
</code><paragraph>The function keyword is extraneous when "()" is present after the function name, but enhances quick identification of functions.</paragraph><heading level="3">Variable Names</heading><paragraph>Same as for function names.</paragraph><paragraph>Variables names for loops should be similarly named for any variable you're looping through.</paragraph><code language="code">for zone in "${zones[@]}"; do
  something_with "${zone}"
done
</code><heading level="3">Constants, Environment Variables, and readonly Variables</heading><paragraph>Constants and anything exported to the environment should be capitalized, separated with underscores, and declared at the top of the file.</paragraph><code language="code"># Constant
readonly PATH_TO_FILES='/some/path'

# Both constant and exported to the environment
declare -xr ORACLE_SID='PROD'
</code><paragraph>For the sake of clarity readonly or export is recommended vs. the equivalent declare commands. You can do one after the other, like:</paragraph><code language="javascript"># Constant
readonly PATH_TO_FILES='/some/path'
export PATH_TO_FILES
</code><paragraph>It's OK to set a constant at runtime or in a conditional, but it should be made readonly immediately afterwards.</paragraph><code language="code">ZIP_VERSION="$(dpkg --status zip | sed -n 's/^Version: //p')"
if [[ -z "${ZIP_VERSION}" ]]; then
  ZIP_VERSION="$(pacman -Q --info zip | sed -n 's/^Version *: //p')"
fi
if [[ -z "${ZIP_VERSION}" ]]; then
  handle_error_and_quit
fi
readonly ZIP_VERSION
</code><heading level="3">Source Filenames</heading><paragraph>Lowercase, with underscores to separate words if desired.</paragraph><paragraph>This is for consistency with other code styles in Google: maketemplate or make_template but not make-template.</paragraph><heading level="3">Use Local Variables</heading><paragraph>Declare function-specific variables with local.</paragraph><paragraph>Ensure that local variables are only seen inside a function and its children by using local when declaring them. This avoids polluting the global namespace and inadvertently setting variables that may have significance outside the function.</paragraph><paragraph>Declaration and assignment must be separate statements when the assignment value is provided by a command substitution; as the local builtin does not propagate the exit code from the command substitution.</paragraph><code language="javascript">my_func2() {
  local name="$1"

  # Separate lines for declaration and assignment:
  local my_var
  my_var="$(my_func)"
  (( $? == 0 )) || return

  …
}
</code><code language="javascript">my_func2() {
  # DO NOT do this:
  # $? will always be zero, as it contains the exit code of 'local', not my_func
  local my_var="$(my_func)"
  (( $? == 0 )) || return

  …
}
</code><heading level="3">Function Location</heading><paragraph>Put all functions together in the file just below constants. Don't hide executable code between functions. Doing so makes the code difficult to follow and results in nasty surprises when debugging.</paragraph><paragraph>If you've got functions, put them all together near the top of the file. Only includes, set statements and setting constants may be done before declaring functions.</paragraph><heading level="3">main</heading><paragraph>A function called main is required for scripts long enough to contain at least one other function.</paragraph><paragraph>In order to easily find the start of the program, put the main program in a function called main as the bottom-most function. This provides consistency with the rest of the code base as well as allowing you to define more variables as local (which can't be done if the main code is not a function). The last non-comment line in the file should be a call to main:</paragraph><paragraph>Obviously, for short scripts where it's just a linear flow, main is overkill and so is not required.</paragraph><heading level="2">Calling Commands</heading><heading level="3">Checking Return Values</heading><paragraph>Always check return values and give informative return values.</paragraph><paragraph>For unpiped commands, use $? or check directly via an if statement to keep it simple.</paragraph><paragraph>Example:</paragraph><code language="code">if ! mv "${file_list[@]}" "${dest_dir}/"; then
  echo "Unable to move ${file_list[*]} to ${dest_dir}" >&2
  exit 1
fi

# Or
mv "${file_list[@]}" "${dest_dir}/"
if (( $? != 0 )); then
  echo "Unable to move ${file_list[*]} to ${dest_dir}" >&2
  exit 1
fi
</code><paragraph>Bash also has the PIPESTATUS variable that allows checking of the return code from all parts of a pipe. If it's only necessary to check success or failure of the whole pipe, then the following is acceptable:</paragraph><code language="code">tar -cf - ./* | ( cd "${dir}" && tar -xf - )
if (( PIPESTATUS[0] != 0 || PIPESTATUS[1] != 0 )); then
  echo "Unable to tar files to ${dir}" >&2
fi
</code><paragraph>However, as PIPESTATUS will be overwritten as soon as you do any other command, if you need to act differently on errors based on where it happened in the pipe, you'll need to assign PIPESTATUS to another variable immediately after running the command (don't forget that [ is a command and will wipe out PIPESTATUS).</paragraph><code language="code">tar -cf - ./* | ( cd "${DIR}" && tar -xf - )
return_codes=( "${PIPESTATUS[@]}" )
if (( return_codes[0] != 0 )); then
  do_something
fi
if (( return_codes[1] != 0 )); then
  do_something_else
fi
</code><heading level="3">Builtin Commands vs. External Commands</heading><paragraph>Given the choice between invoking a shell builtin and invoking a separate process, choose the builtin.</paragraph><paragraph>We prefer the use of builtins such as the Parameter Expansion functionality provided by bash as it's more efficient, robust, and portable (especially when compared to things like sed). See also the =~ operator.</paragraph><paragraph>Examples:</paragraph><code language="code"># Prefer this:
addition="$(( X + Y ))"
substitution="${string/#foo/bar}"
if [[ "${string}" =~ foo:(\d+) ]]; then
  extraction="${BASH_REMATCH[1]}"
fi
</code><code language="code"># Instead of this:
addition="$(expr "${X}" + "${Y}")"
substitution="$(echo "${string}" | sed -e 's/^foo/bar/')"
extraction="$(echo "${string}" | sed -e 's/foo:\([0-9]\)/\1/')"
</code><heading level="2">When in Doubt: Be Consistent</heading><paragraph>Using one style consistently through our codebase lets us focus on other (more important) issues. Consistency also allows for automation. In many cases, rules that are attributed to "Be Consistent" boil down to "Just pick one and stop worrying about it"; the potential value of allowing flexibility on these points is outweighed by the cost of having people argue over them.</paragraph><paragraph>However, there are limits to consistency. It is a good tie breaker when there is no clear technical argument, nor a long-term direction. Consistency should not generally be used as a justification to do things in an old style without considering the benefits of the new style, or the tendency of the codebase to converge on newer styles over time.</paragraph></content>
</page>
<page url="https://google.github.io/styleguide/tsguide.html">
<title>Google TypeScript Style Guide</title>
<content><heading level="1">Google TypeScript Style Guide</heading><paragraph>This guide is based on the internal Google TypeScript style guide, but it has been slightly adjusted to remove Google-internal sections. Google's internal environment has different constraints on TypeScript than you might find outside of Google. The advice here is specifically useful for people authoring code they intend to import into Google, but otherwise may not apply in your external environment.</paragraph><paragraph>There is no automatic deployment process for this version as it's pushed on-demand by volunteers.</paragraph><heading level="2">Introduction</heading><heading level="3">Terminology notes</heading><paragraph>This Style Guide uses RFC 2119 terminology when using the phrases must, must not, should, should not, and may. The terms prefer and avoid correspond to should and should not, respectively. Imperative and declarative statements are prescriptive and correspond to must.</paragraph><heading level="3">Guide notes</heading><paragraph>All examples given are non-normative and serve only to illustrate the normative language of the style guide. That is, while the examples are in Google Style, they may not illustrate the only stylish way to represent the code. Optional formatting choices made in examples must not be enforced as rules.</paragraph><heading level="2">Source file basics</heading><heading level="3">File encoding: UTF-8</heading><paragraph>Source files are encoded in UTF-8.</paragraph><heading level="4">Whitespace characters</heading><paragraph>Aside from the line terminator sequence, the ASCII horizontal space character (0x20) is the only whitespace character that appears anywhere in a source file. This implies that all other whitespace characters in string literals are escaped.</paragraph><heading level="4">Special escape sequences</heading><paragraph>For any character that has a special escape sequence (\', \", \\, \b, \f, \n, \r, \t, \v), that sequence is used rather than the corresponding numeric escape (e.g \x0a, \u000a, or \u{a}). Legacy octal escapes are never used.</paragraph><heading level="4">Non-ASCII characters</heading><paragraph>For the remaining non-ASCII characters, use the actual Unicode character (e.g. ∞). For non-printable characters, the equivalent hex or Unicode escapes (e.g. \u221e) can be used along with an explanatory comment.</paragraph><code language="javascript">// Perfectly clear, even without a comment.
const units = 'μs';

// Use escapes for non-printable characters.
const output = '\ufeff' + content;  // byte order mark
</code><code language="javascript">// Hard to read and prone to mistakes, even with the comment.
const units = '\u03bcs'; // Greek letter mu, 's'

// The reader has no idea what this is.
const output = '\ufeff' + content;
</code><heading level="2">Source file structure</heading><paragraph>Files consist of the following, in order:</paragraph><list type="ol"><item>Copyright information, if present</item><item>JSDoc with @fileoverview, if present</item><item>Imports, if present</item><item>The file's implementation</item></list><paragraph>Exactly one blank line separates each section that is present.</paragraph><heading level="3">Copyright information</heading><paragraph>If license or copyright information is necessary in a file, add it in a JSDoc at the top of the file.</paragraph><heading level="3">@fileoverview JSDoc</heading><paragraph>A file may have a top-level @fileoverview JSDoc. If present, it may provide a description of the file's content, its uses, or information about its dependencies. Wrapped lines are not indented.</paragraph><paragraph>Example:</paragraph><code language="code">/**
 * @fileoverview Description of file. Lorem ipsum dolor sit amet, consectetur
 * adipiscing elit, sed do eiusmod tempor incididunt.
 */
</code><heading level="3">Imports</heading><paragraph>There are four variants of import statements in ES6 and TypeScript:</paragraph><table><thead><tr><th>Import type</th><th>Example</th><th>Use for</th></tr></thead><tbody><tr><td>module[module_import]</td><td>import * as foo from '...';</td><td>TypeScript imports</td></tr><tr><td>named[destructuring_import]</td><td>import {SomeThing} from '...';</td><td>TypeScript imports</td></tr><tr><td>default</td><td>import SomeThing from '...';</td><td>Only for other external code that requires them</td></tr><tr><td>side-effect</td><td>import '...';</td><td>Only to import libraries for their side-effects on load (such as custom elements)</td></tr></tbody></table><code language="javascript">// Good: choose between two options as appropriate (see below).
import * as ng from '@angular/core';
import {Foo} from './foo';

// Only when needed: default imports.
import Button from 'Button';

// Sometimes needed to import libraries for their side effects:
import 'jasmine';
import '@polymer/paper-button';
</code><heading level="4">Import paths</heading><paragraph>TypeScript code must use paths to import other TypeScript code. Paths may be relative, i.e. starting with . or .., or rooted at the base directory, e.g. root/path/to/file.</paragraph><paragraph>Code should use relative imports (./foo) rather than absolute imports path/to/foo when referring to files within the same (logical) project as this allows to move the project around without introducing changes in these imports.</paragraph><paragraph>Consider limiting the number of parent steps (../../../) as those can make module and path structures hard to understand.</paragraph><code language="javascript">import {Symbol1} from 'path/from/root';
import {Symbol2} from '../parent/file';
import {Symbol3} from './sibling';
</code><heading level="4">Namespace versus named imports</heading><paragraph>Both namespace and named imports can be used.</paragraph><paragraph>Prefer named imports for symbols used frequently in a file or for symbols that have clear names, for example Jasmine's describe and it. Named imports can be aliased to clearer names as needed with as.</paragraph><paragraph>Prefer namespace imports when using many different symbols from large APIs. A namespace import, despite using the * character, is not comparable to a wildcard import as seen in other languages. Instead, namespace imports give a name to all the exports of a module, and each exported symbol from the module becomes a property on the module name. Namespace imports can aid readability for exported symbols that have common names like Model or Controller without the need to declare aliases.</paragraph><code language="javascript">// Bad: overlong import statement of needlessly namespaced names.
import {Item as TableviewItem, Header as TableviewHeader, Row as TableviewRow,
  Model as TableviewModel, Renderer as TableviewRenderer} from './tableview';

let item: TableviewItem|undefined;
</code><code language="javascript">// Better: use the module for namespacing.
import * as tableview from './tableview';

let item: tableview.Item|undefined;
</code><code language="javascript">import * as testing from './testing';

// Bad: The module name does not improve readability.
testing.describe('foo', () => {
  testing.it('bar', () => {
    testing.expect(null).toBeNull();
    testing.expect(undefined).toBeUndefined();
  });
});
</code><code language="javascript">// Better: give local names for these common functions.
import {describe, it, expect} from './testing';

describe('foo', () => {
  it('bar', () => {
    expect(null).toBeNull();
    expect(undefined).toBeUndefined();
  });
});
</code><heading level="5">Special case: Apps JSPB protos</heading><paragraph>Apps JSPB protos must use named imports, even when it leads to long import lines.</paragraph><paragraph>This rule exists to aid in build performance and dead code elimination since often .proto files contain many messages that are not all needed together. By leveraging destructured imports the build system can create finer grained dependencies on Apps JSPB messages while preserving the ergonomics of path based imports.</paragraph><code language="javascript">// Good: import the exact set of symbols you need from the proto file.
import {Foo, Bar} from './foo.proto';

function copyFooBar(foo: Foo, bar: Bar) {...}
</code><heading level="4">Renaming imports</heading><paragraph>Code should fix name collisions by using a namespace import or renaming the exports themselves. Code may rename imports (import {SomeThing as SomeOtherThing}) if needed.</paragraph><paragraph>Three examples where renaming can be helpful:</paragraph><list type="ol"><item>If it's necessary to avoid collisions with other imported symbols.</item><item>If the imported symbol name is generated.</item><item>If importing symbols whose names are unclear by themselves, renaming can improve code clarity. For example, when using RxJS the from function might be more readable when renamed to observableFrom.</item></list><heading level="3">Exports</heading><paragraph>Use named exports in all code:</paragraph><code language="javascript">// Use named exports:
export class Foo { ... }
</code><paragraph>Do not use default exports. This ensures that all imports follow a uniform pattern.</paragraph><code language="javascript">// Do not use default exports:
export default class Foo { ... } // BAD!
</code><paragraph>Why?</paragraph><paragraph>Default exports provide no canonical name, which makes central maintenance difficult with relatively little benefit to code owners, including potentially decreased readability:</paragraph><code language="javascript">import Foo from './bar';  // Legal.
import Bar from './bar';  // Also legal.
</code><paragraph>Named exports have the benefit of erroring when import statements try to import something that hasn't been declared. In foo.ts:</paragraph><code language="javascript">const foo = 'blah';
export default foo;
</code><paragraph>And in bar.ts:</paragraph><code language="javascript">import {fizz} from './foo';
</code><paragraph>Results in error TS2614: Module '"./foo"' has no exported member 'fizz'. While bar.ts:</paragraph><code language="javascript">import fizz from './foo';
</code><paragraph>Results in fizz === foo, which is probably unexpected and difficult to debug.</paragraph><paragraph>Additionally, default exports encourage people to put everything into one big object to namespace it all together:</paragraph><code language="javascript">export default class Foo {
  static SOME_CONSTANT = ...
  static someHelpfulFunction() { ... }
  ...
}
</code><paragraph>With the above pattern, we have file scope, which can be used as a namespace. We also have a perhaps needless second scope (the class Foo) that can be ambiguously used as both a type and a value in other files.</paragraph><paragraph>Instead, prefer use of file scope for namespacing, as well as named exports:</paragraph><code language="javascript">export const SOME_CONSTANT = ...
export function someHelpfulFunction()
export class Foo {
  // only class stuff here
}
</code><heading level="4">Export visibility</heading><paragraph>TypeScript does not support restricting the visibility for exported symbols. Only export symbols that are used outside of the module. Generally minimize the exported API surface of modules.</paragraph><heading level="4">Mutable exports</heading><paragraph>Regardless of technical support, mutable exports can create hard to understand and debug code, in particular with re-exports across multiple modules. One way to paraphrase this style point is that export let is not allowed.</paragraph><code language="javascript">export let foo = 3;
// In pure ES6, foo is mutable and importers will observe the value change after a second.
// In TS, if foo is re-exported by a second file, importers will not see the value change.
window.setTimeout(() => {
  foo = 4;
}, 1000 /* ms */);
</code><paragraph>If one needs to support externally accessible and mutable bindings, they should instead use explicit getter functions.</paragraph><code language="javascript">let foo = 3;
window.setTimeout(() => {
  foo = 4;
}, 1000 /* ms */);
// Use an explicit getter to access the mutable export.
export function getFoo() { return foo; };
</code><paragraph>For the common pattern of conditionally exporting either of two values, first do the conditional check, then the export. Make sure that all exports are final after the module's body has executed.</paragraph><code language="javascript">function pickApi() {
  if (useOtherApi()) return OtherApi;
  return RegularApi;
}
export const SomeApi = pickApi();
</code><heading level="4">Container classes</heading><paragraph>Do not create container classes with static methods or properties for the sake of namespacing.</paragraph><code language="javascript">export class Container {
  static FOO = 1;
  static bar() { return 1; }
}
</code><paragraph>Instead, export individual constants and functions:</paragraph><code language="javascript">export const FOO = 1;
export function bar() { return 1; }
</code><heading level="3">Import and export type</heading><heading level="4">Import type</heading><paragraph>You may use import type {...} when you use the imported symbol only as a type. Use regular imports for values:</paragraph><code language="javascript">import type {Foo} from './foo';
import {Bar} from './foo';

import {type Foo, Bar} from './foo';
</code><paragraph>Why?</paragraph><paragraph>The TypeScript compiler automatically handles the distinction and does not insert runtime loads for type references. So why annotate type imports?</paragraph><paragraph>The TypeScript compiler can run in 2 modes:</paragraph><list type="ul"><item>In development mode, we typically want quick iteration loops. The compiler transpiles to JavaScript without full type information. This is much faster, but requires import type in certain cases.</item><item>In production mode, we want correctness. The compiler type checks everything and ensures import type is used correctly.</item></list><paragraph>Note: If you need to force a runtime load for side effects, use import '...';. See</paragraph><heading level="4">Export type</heading><paragraph>Use export type when re-exporting a type, e.g.:</paragraph><code language="javascript">export type {AnInterface} from './foo';
</code><paragraph>Why?</paragraph><paragraph>export type is useful to allow type re-exports in file-by-file transpilation. See isolatedModules docs.</paragraph><paragraph>export type might also seem useful to avoid ever exporting a value symbol for an API. However it does not give guarantees, either: downstream code might still import an API through a different path. A better way to split & guarantee type vs value usages of an API is to actually split the symbols into e.g. UserService and AjaxUserService. This is less error prone and also better communicates intent.</paragraph><heading level="4">Use modules not namespaces</heading><paragraph>TypeScript supports two methods to organize code: namespaces and modules, but namespaces are disallowed. That is, your code must refer to code in other files using imports and exports of the form import {foo} from 'bar';</paragraph><paragraph>Your code must not use the namespace Foo { ... } construct. namespaces may only be used when required to interface with external, third party code. To semantically namespace your code, use separate files.</paragraph><paragraph>Code must not use require (as in import x = require('...');) for imports. Use ES6 module syntax.</paragraph><code language="javascript">// Bad: do not use namespaces:
namespace Rocket {
  function launch() { ... }
}

// Bad: do not use <reference>
/// <reference path="..."/>

// Bad: do not use require()
import x = require('mydep');
</code><paragraph>NB: TypeScript namespaces used to be called internal modules and used to use the module keyword in the form module Foo { ... }. Don't use that either. Always use ES6 imports.</paragraph><heading level="2">Language features</heading><paragraph>This section delineates which features may or may not be used, and any additional constraints on their use.</paragraph><paragraph>Language features which are not discussed in this style guide may be used with no recommendations of their usage.</paragraph><heading level="3">Local variable declarations</heading><heading level="4">Use const and let</heading><paragraph>Always use const or let to declare variables. Use const by default, unless a variable needs to be reassigned. Never use var.</paragraph><code language="javascript">const foo = otherValue;  // Use if "foo" never changes.
let bar = someValue;     // Use if "bar" is ever assigned into later on.
</code><paragraph>const and let are block scoped, like variables in most other languages. var in JavaScript is function scoped, which can cause difficult to understand bugs. Don't use it.</paragraph><code language="javascript">var foo = someValue;     // Don't use - var scoping is complex and causes bugs.
</code><paragraph>Variables must not be used before their declaration.</paragraph><heading level="4">One variable per declaration</heading><paragraph>Every local variable declaration declares only one variable: declarations such as let a = 1, b = 2; are not used.</paragraph><heading level="3">Array literals</heading><heading level="4">Do not use the Array constructor</heading><paragraph>Do not use the Array() constructor, with or without new. It has confusing and contradictory usage:</paragraph><code language="javascript">const a = new Array(2); // [undefined, undefined]
const b = new Array(2, 3); // [2, 3];
</code><paragraph>Instead, always use bracket notation to initialize arrays, or from to initialize an Array with a certain size:</paragraph><code language="javascript">const a = [2];
const b = [2, 3];

// Equivalent to Array(2):
const c = [];
c.length = 2;

// [0, 0, 0, 0, 0]
Array.from<number>({length: 5}).fill(0);
</code><heading level="4">Do not define properties on arrays</heading><paragraph>Do not define or use non-numeric properties on an array (other than length). Use a Map (or Object) instead.</paragraph><heading level="4">Using spread syntax</heading><paragraph>Using spread syntax [...foo]; is a convenient shorthand for shallow-copying or concatenating iterables.</paragraph><code language="javascript">const foo = [
  1,
];

const foo2 = [
  ...foo,
  6,
  7,
];

const foo3 = [
  5,
  ...foo,
];

foo2[1] === 6;
foo3[1] === 1;
</code><paragraph>When using spread syntax, the value being spread must match what is being created. When creating an array, only spread iterables. Primitives (including null and undefined) must not be spread.</paragraph><code language="javascript">const foo = [7];
const bar = [5, ...(shouldUseFoo && foo)]; // might be undefined

// Creates {0: 'a', 1: 'b', 2: 'c'} but has no length
const fooStrings = ['a', 'b', 'c'];
const ids = {...fooStrings};
</code><code language="javascript">const foo = shouldUseFoo ? [7] : [];
const bar = [5, ...foo];
const fooStrings = ['a', 'b', 'c'];
const ids = [...fooStrings, 'd', 'e'];
</code><heading level="4">Array destructuring</heading><paragraph>Array literals may be used on the left-hand side of an assignment to perform destructuring (such as when unpacking multiple values from a single array or iterable). A final rest element may be included (with no space between the ... and the variable name). Elements should be omitted if they are unused.</paragraph><code language="javascript">const [a, b, c, ...rest] = generateResults();
let [, b,, d] = someArray;
</code><paragraph>Destructuring may also be used for function parameters. Always specify [] as the default value if a destructured array parameter is optional, and provide default values on the left hand side:</paragraph><code language="javascript">function destructured([a = 4, b = 2] = []) { … }
</code><paragraph>Disallowed:</paragraph><code language="javascript">function badDestructuring([a, b] = [4, 2]) { … }
</code><paragraph>Tip: For (un)packing multiple values into a function's parameter or return, prefer object destructuring to array destructuring when possible, as it allows naming the individual elements and specifying a different type for each.</paragraph><heading level="3">Object literals</heading><heading level="4">Do not use the Object constructor</heading><paragraph>The Object constructor is disallowed. Use an object literal ({} or {a: 0, b: 1, c: 2}) instead.</paragraph><heading level="4">Iterating objects</heading><paragraph>Iterating objects with for (... in ...) is error prone. It will include enumerable properties from the prototype chain.</paragraph><paragraph>Do not use unfiltered for (... in ...) statements:</paragraph><code language="javascript">for (const x in someObj) {
  // x could come from some parent prototype!
}
</code><paragraph>Either filter values explicitly with an if statement, or use for (... of Object.keys(...)).</paragraph><code language="javascript">for (const x in someObj) {
  if (!someObj.hasOwnProperty(x)) continue;
  // now x was definitely defined on someObj
}
for (const x of Object.keys(someObj)) { // note: for _of_!
  // now x was definitely defined on someObj
}
for (const [key, value] of Object.entries(someObj)) { // note: for _of_!
  // now key was definitely defined on someObj
}
</code><heading level="4">Using spread syntax</heading><paragraph>Using spread syntax {...bar} is a convenient shorthand for creating a shallow copy of an object. When using spread syntax in object initialization, later values replace earlier values at the same key.</paragraph><code language="javascript">const foo = {
  num: 1,
};

const foo2 = {
  ...foo,
  num: 5,
};

const foo3 = {
  num: 5,
  ...foo,
}

foo2.num === 5;
foo3.num === 1;

</code><paragraph>When using spread syntax, the value being spread must match what is being created. That is, when creating an object, only objects may be spread; arrays and primitives (including null and undefined) must not be spread. Avoid spreading objects that have prototypes other than the Object prototype (e.g. class definitions, class instances, functions) as the behavior is unintuitive (only enumerable non-prototype properties are shallow-copied).</paragraph><code language="javascript">const foo = {num: 7};
const bar = {num: 5, ...(shouldUseFoo && foo)}; // might be undefined

// Creates {0: 'a', 1: 'b', 2: 'c'} but has no length
const fooStrings = ['a', 'b', 'c'];
const ids = {...fooStrings};
</code><code language="javascript">const foo = shouldUseFoo ? {num: 7} : {};
const bar = {num: 5, ...foo};
</code><heading level="4">Computed property names</heading><paragraph>Computed property names (e.g. {['key' + foo()]: 42}) are allowed, and are considered dict-style (quoted) keys (i.e., must not be mixed with non-quoted keys) unless the computed property is a symbol (e.g. [Symbol.iterator]).</paragraph><heading level="4">Object destructuring</heading><paragraph>Object destructuring patterns may be used on the left-hand side of an assignment to perform destructuring and unpack multiple values from a single object.</paragraph><paragraph>Destructured objects may also be used as function parameters, but should be kept as simple as possible: a single level of unquoted shorthand properties. Deeper levels of nesting and computed properties may not be used in parameter destructuring. Specify any default values in the left-hand-side of the destructured parameter ({str = 'some default'} = {}, rather than {str} = {str: 'some default'}), and if a destructured object is itself optional, it must default to {}.</paragraph><paragraph>Example:</paragraph><code language="javascript">interface Options {
  /** The number of times to do something. */
  num?: number;

  /** A string to do stuff to. */
  str?: string;
}

function destructured({num, str = 'default'}: Options = {}) {}
</code><paragraph>Disallowed:</paragraph><code language="javascript">function nestedTooDeeply({x: {num, str}}: {x: Options}) {}
function nontrivialDefault({num, str}: Options = {num: 42, str: 'default'}) {}
</code><heading level="3">Classes</heading><heading level="4">Class declarations</heading><paragraph>Class declarations must not be terminated with semicolons:</paragraph><code language="javascript">class Foo {
}
</code><code language="javascript">class Foo {
}; // Unnecessary semicolon
</code><paragraph>In contrast, statements that contain class expressions must be terminated with a semicolon:</paragraph><code language="javascript">export const Baz = class extends Bar {
  method(): number {
    return this.x;
  }
}; // Semicolon here as this is a statement, not a declaration
</code><code language="javascript">exports const Baz = class extends Bar {
  method(): number {
    return this.x;
  }
}
</code><paragraph>It is neither encouraged nor discouraged to have blank lines separating class declaration braces from other class content:</paragraph><code language="javascript">// No spaces around braces - fine.
class Baz {
  method(): number {
    return this.x;
  }
}

// A single space around both braces - also fine.
class Foo {

  method(): number {
    return this.x;
  }

}
</code><heading level="4">Class method declarations</heading><paragraph>Class method declarations must not use a semicolon to separate individual method declarations:</paragraph><code language="javascript">class Foo {
  doThing() {
    console.log("A");
  }
}
</code><code language="javascript">class Foo {
  doThing() {
    console.log("A");
  }; // <-- unnecessary
}
</code><paragraph>Method declarations should be separated from surrounding code by a single blank line:</paragraph><code language="javascript">class Foo {
  doThing() {
    console.log("A");
  }

  getOtherThing(): number {
    return 4;
  }
}
</code><code language="javascript">class Foo {
  doThing() {
    console.log("A");
  }
  getOtherThing(): number {
    return 4;
  }
}
</code><heading level="5">Overriding toString</heading><paragraph>The toString method may be overridden, but must always succeed and never have visible side effects.</paragraph><paragraph>Tip: Beware, in particular, of calling other methods from toString, since exceptional conditions could lead to infinite loops.</paragraph><heading level="4">Static methods</heading><heading level="5">Avoid private static methods</heading><paragraph>Where it does not interfere with readability, prefer module-local functions over private static methods.</paragraph><heading level="5">Do not rely on dynamic dispatch</heading><paragraph>Code should not rely on dynamic dispatch of static methods. Static methods should only be called on the base class itself (which defines it directly). Static methods should not be called on variables containing a dynamic instance that may be either the constructor or a subclass constructor (and must be defined with @nocollapse if this is done), and must not be called directly on a subclass that doesn't define the method itself.</paragraph><paragraph>Disallowed:</paragraph><code language="javascript">// Context for the examples below (this class is okay by itself)
class Base {
  /** @nocollapse */ static foo() {}
}
class Sub extends Base {}

// Discouraged: don't call static methods dynamically
function callFoo(cls: typeof Base) {
  cls.foo();
}

// Disallowed: don't call static methods on subclasses that don't define it themselves
Sub.foo();

// Disallowed: don't access this in static methods.
class MyClass {
  static foo() {
    return this.staticField;
  }
}
MyClass.staticField = 1;
</code><heading level="5">Avoid static this references</heading><paragraph>Code must not use this in a static context.</paragraph><paragraph>JavaScript allows accessing static fields through this. Different from other languages, static fields are also inherited.</paragraph><code language="javascript">class ShoeStore {
  static storage: Storage = ...;

  static isAvailable(s: Shoe) {
    // Bad: do not use `this` in a static method.
    return this.storage.has(s.id);
  }
}

class EmptyShoeStore extends ShoeStore {
  static storage: Storage = EMPTY_STORE;  // overrides storage from ShoeStore
}
</code><paragraph>Why?</paragraph><paragraph>This code is generally surprising: authors might not expect that static fields can be accessed through the this pointer, and might be surprised to find that they can be overridden - this feature is not commonly used.</paragraph><paragraph>This code also encourages an anti-pattern of having substantial static state, which causes problems with testability.</paragraph><heading level="4">Constructors</heading><paragraph>Constructor calls must use parentheses, even when no arguments are passed:</paragraph><code language="javascript">const x = new Foo;
</code><code language="javascript">const x = new Foo();
</code><paragraph>Omitting parentheses can lead to subtle mistakes. These two lines are not equivalent:</paragraph><code language="code">new Foo().Bar();
new Foo.Bar();
</code><paragraph>It is unnecessary to provide an empty constructor or one that simply delegates into its parent class because ES2015 provides a default class constructor if one is not specified. However constructors with parameter properties, visibility modifiers or parameter decorators should not be omitted even if the body of the constructor is empty.</paragraph><code language="javascript">class UnnecessaryConstructor {
  constructor() {}
}
</code><code language="javascript">class UnnecessaryConstructorOverride extends Base {
    constructor(value: number) {
      super(value);
    }
}
</code><code language="javascript">class DefaultConstructor {
}

class ParameterProperties {
  constructor(private myService) {}
}

class ParameterDecorators {
  constructor(@SideEffectDecorator myService) {}
}

class NoInstantiation {
  private constructor() {}
}
</code><paragraph>The constructor should be separated from surrounding code both above and below by a single blank line:</paragraph><code language="javascript">class Foo {
  myField = 10;

  constructor(private readonly ctorParam) {}

  doThing() {
    console.log(ctorParam.getThing() + myField);
  }
}
</code><code language="javascript">class Foo {
  myField = 10;
  constructor(private readonly ctorParam) {}
  doThing() {
    console.log(ctorParam.getThing() + myField);
  }
}
</code><heading level="4">Class members</heading><heading level="5">No #private fields</heading><paragraph>Do not use private fields (also known as private identifiers):</paragraph><code language="javascript">class Clazz {
  #ident = 1;
}
</code><paragraph>Instead, use TypeScript's visibility annotations:</paragraph><code language="javascript">class Clazz {
  private ident = 1;
}
</code><paragraph>Why?</paragraph><paragraph>Private identifiers cause substantial emit size and performance regressions when down-leveled by TypeScript, and are unsupported before ES2015. They can only be downleveled to ES2015, not lower. At the same time, they do not offer substantial benefits when static type checking is used to enforce visibility.</paragraph><heading level="5">Use readonly</heading><paragraph>Mark properties that are never reassigned outside of the constructor with the readonly modifier (these need not be deeply immutable).</paragraph><heading level="5">Parameter properties</heading><paragraph>Rather than plumbing an obvious initializer through to a class member, use a TypeScript parameter property.</paragraph><code language="javascript">class Foo {
  private readonly barService: BarService;

  constructor(barService: BarService) {
    this.barService = barService;
  }
}
</code><code language="javascript">class Foo {
  constructor(private readonly barService: BarService) {}
}
</code><paragraph>If the parameter property needs documentation, use an @param JSDoc tag.</paragraph><heading level="5">Field initializers</heading><paragraph>If a class member is not a parameter, initialize it where it's declared, which sometimes lets you drop the constructor entirely.</paragraph><code language="javascript">class Foo {
  private readonly userList: string[];

  constructor() {
    this.userList = [];
  }
}
</code><code language="javascript">class Foo {
  private readonly userList: string[] = [];
}
</code><paragraph>Tip: Properties should never be added to or removed from an instance after the constructor is finished, since it significantly hinders VMs' ability to optimize classes' shape. Optional fields that may be filled in later should be explicitly initialized to undefined to prevent later shape changes.</paragraph><heading level="5">Properties used outside of class lexical scope</heading><paragraph>Properties used from outside the lexical scope of their containing class, such as an Angular component's properties used from a template, must not use private visibility, as they are used outside of the lexical scope of their containing class.</paragraph><paragraph>Use either protected or public as appropriate to the property in question. Angular and AngularJS template properties should use protected, but Polymer should use public.</paragraph><paragraph>TypeScript code must not use obj['foo'] to bypass the visibility of a property.</paragraph><paragraph>Why?</paragraph><paragraph>When a property is private, you are declaring to both automated systems and humans that the property accesses are scoped to the methods of the declaring class, and they will rely on that. For example, a check for unused code will flag a private property that appears to be unused, even if some other file manages to bypass the visibility restriction.</paragraph><paragraph>Though it might appear that obj['foo'] can bypass visibility in the TypeScript compiler, this pattern can be broken by rearranging the build rules, and also violates optimization compatibility.</paragraph><heading level="5">Getters and setters</heading><paragraph>Getters and setters, also known as accessors, for class members may be used. The getter method must be a pure function (i.e., result is consistent and has no side effects: getters must not change observable state). They are also useful as a means of restricting the visibility of internal or verbose implementation details (shown below).</paragraph><code language="javascript">class Foo {
  constructor(private readonly someService: SomeService) {}

  get someMember(): string {
    return this.someService.someVariable;
  }

  set someMember(newValue: string) {
    this.someService.someVariable = newValue;
  }
}
</code><code language="javascript">class Foo {
  nextId = 0;
  get next() {
    return this.nextId++; // Bad: getter changes observable state
  }
}
</code><paragraph>If an accessor is used to hide a class property, the hidden property may be prefixed or suffixed with any whole word, like internal or wrapped. When using these private properties, access the value through the accessor whenever possible. At least one accessor for a property must be non-trivial: do not define pass-through accessors only for the purpose of hiding a property. Instead, make the property public (or consider making it readonly rather than just defining a getter with no setter).</paragraph><code language="javascript">class Foo {
  private wrappedBar = '';
  get bar() {
    return this.wrappedBar || 'bar';
  }

  set bar(wrapped: string) {
    this.wrappedBar = wrapped.trim();
  }
}
</code><code language="javascript">class Bar {
  private barInternal = '';
  // Neither of these accessors have logic, so just make bar public.
  get bar() {
    return this.barInternal;
  }

  set bar(value: string) {
    this.barInternal = value;
  }
}
</code><paragraph>Getters and setters must not be defined using Object.defineProperty, since this interferes with property renaming.</paragraph><heading level="5">Computed properties</heading><paragraph>Computed properties may only be used in classes when the property is a symbol. Dict-style properties (that is, quoted or computed non-symbol keys) are not allowed (see rationale for not mixing key types. A [Symbol.iterator] method should be defined for any classes that are logically iterable. Beyond this, Symbol should be used sparingly.</paragraph><paragraph>Tip: be careful of using any other built-in symbols (e.g. Symbol.isConcatSpreadable) as they are not polyfilled by the compiler and will therefore not work in older browsers.</paragraph><heading level="4">Visibility</heading><paragraph>Restricting visibility of properties, methods, and entire types helps with keeping code decoupled.</paragraph><list type="ul"><item>Limit symbol visibility as much as possible.</item><item>Consider converting private methods to non-exported functions within the same file but outside of any class, and moving private properties into a separate, non-exported class.</item><item>TypeScript symbols are public by default. Never use the public modifier except when declaring non-readonly public parameter properties (in constructors).</item></list><code language="javascript">class Foo {
  public bar = new Bar();  // BAD: public modifier not needed

  constructor(public readonly baz: Baz) {}  // BAD: readonly implies it's a property which defaults to public
}
</code><code language="javascript">class Foo {
  bar = new Bar();  // GOOD: public modifier not needed

  constructor(public baz: Baz) {}  // public modifier allowed
}
</code><paragraph>See also export visibility.</paragraph><heading level="4">Disallowed class patterns</heading><heading level="5">Do not manipulate prototypes directly</heading><paragraph>The class keyword allows clearer and more readable class definitions than defining prototype properties. Ordinary implementation code has no business manipulating these objects. Mixins and modifying the prototypes of builtin objects are explicitly forbidden.</paragraph><paragraph>Exception: Framework code (such as Polymer, or Angular) may need to use prototypes, and should not resort to even-worse workarounds to avoid doing so.</paragraph><heading level="3">Functions</heading><heading level="4">Terminology</heading><paragraph>There are many different types of functions, with subtle distinctions between them. This guide uses the following terminology, which aligns with MDN:</paragraph><list type="ul"><item>function declaration: a declaration (i.e. not an expression) using the function keyword</item><item>function expression: an expression, typically used in an assignment or passed as a parameter, using the function keyword</item><item>arrow function: an expression using the => syntax</item><item>block body: right hand side of an arrow function with braces</item><item>concise body: right hand side of an arrow function without braces</item></list><paragraph>Methods and classes/constructors are not covered in this section.</paragraph><heading level="4">Prefer function declarations for named functions</heading><paragraph>Prefer function declarations over arrow functions or function expressions when defining named functions.</paragraph><code language="javascript">function foo() {
  return 42;
}
</code><code language="javascript">const foo = () => 42;
</code><paragraph>Arrow functions may be used, for example, when an explicit type annotation is required.</paragraph><code language="javascript">interface SearchFunction {
  (source: string, subString: string): boolean;
}

const fooSearch: SearchFunction = (source, subString) => { ... };
</code><heading level="4">Nested functions</heading><paragraph>Functions nested within other methods or functions may use function declarations or arrow functions, as appropriate. In method bodies in particular, arrow functions are preferred because they have access to the outer this.</paragraph><heading level="4">Do not use function expressions</heading><paragraph>Do not use function expressions. Use arrow functions instead.</paragraph><code language="javascript">bar(() => { this.doSomething(); })
</code><code language="code">bar(function() { ... })
</code><paragraph>Exception: Function expressions may be used only if code has to dynamically rebind this (but this is discouraged), or for generator functions (which do not have an arrow syntax).</paragraph><heading level="4">Arrow function bodies</heading><paragraph>Use arrow functions with concise bodies (i.e. expressions) or block bodies as appropriate.</paragraph><code language="javascript">// Top level functions use function declarations.
function someFunction() {
  // Block bodies are fine:
  const receipts = books.map((b: Book) => {
    const receipt = payMoney(b.price);
    recordTransaction(receipt);
    return receipt;
  });

  // Concise bodies are fine, too, if the return value is used:
  const longThings = myValues.filter(v => v.length > 1000).map(v => String(v));

  function payMoney(amount: number) {
    // function declarations are fine, but must not access `this`.
  }

  // Nested arrow functions may be assigned to a const.
  const computeTax = (amount: number) => amount * 0.12;
}
</code><paragraph>Only use a concise body if the return value of the function is actually used. The block body makes sure the return type is void then and prevents potential side effects.</paragraph><code language="javascript">// BAD: use a block body if the return value of the function is not used.
myPromise.then(v => console.log(v));
// BAD: this typechecks, but the return value still leaks.
let f: () => void;
f = () => 1;
</code><code language="javascript">// GOOD: return value is unused, use a block body.
myPromise.then(v => {
  console.log(v);
});
// GOOD: code may use blocks for readability.
const transformed = [1, 2, 3].map(v => {
  const intermediate = someComplicatedExpr(v);
  const more = acrossManyLines(intermediate);
  return worthWrapping(more);
});
// GOOD: explicit `void` ensures no leaked return value
myPromise.then(v => void console.log(v));
</code><paragraph>Tip: The void operator can be used to ensure an arrow function with an expression body returns undefined when the result is unused.</paragraph><heading level="4">Rebinding this</heading><paragraph>Function expressions and function declarations must not use this unless they specifically exist to rebind the this pointer. Rebinding this can in most cases be avoided by using arrow functions or explicit parameters.</paragraph><code language="javascript">function clickHandler() {
  // Bad: what's `this` in this context?
  this.textContent = 'Hello';
}
// Bad: the `this` pointer reference is implicitly set to document.body.
document.body.onclick = clickHandler;
</code><code language="javascript">// Good: explicitly reference the object from an arrow function.
document.body.onclick = () => { document.body.textContent = 'hello'; };
// Alternatively: take an explicit parameter
const setTextFn = (e: HTMLElement) => { e.textContent = 'hello'; };
document.body.onclick = setTextFn.bind(null, document.body);
</code><paragraph>Prefer arrow functions over other approaches to binding this, such as f.bind(this), goog.bind(f, this), or const self = this.</paragraph><heading level="4">Prefer passing arrow functions as callbacks</heading><paragraph>Callbacks can be invoked with unexpected arguments that can pass a type check but still result in logical errors.</paragraph><paragraph>Avoid passing a named callback to a higher-order function, unless you are sure of the stability of both functions' call signatures. Beware, in particular, of less-commonly-used optional parameters.</paragraph><code language="javascript">// BAD: Arguments are not explicitly passed, leading to unintended behavior
// when the optional `radix` argument gets the array indices 0, 1, and 2.
const numbers = ['11', '5', '10'].map(parseInt);
// > [11, NaN, 2];
</code><paragraph>Instead, prefer passing an arrow-function that explicitly forwards parameters to the named callback.</paragraph><code language="javascript">// GOOD: Arguments are explicitly passed to the callback
const numbers = ['11', '5', '3'].map((n) => parseInt(n));
// > [11, 5, 3]

// GOOD: Function is locally defined and is designed to be used as a callback
function dayFilter(element: string|null|undefined) {
  return element != null && element.endsWith('day');
}

const days = ['tuesday', undefined, 'juice', 'wednesday'].filter(dayFilter);
</code><heading level="4">Arrow functions as properties</heading><paragraph>Classes usually should not contain properties initialized to arrow functions. Arrow function properties require the calling function to understand that the callee's this is already bound, which increases confusion about what this is, and call sites and references using such handlers look broken (i.e. require non-local knowledge to determine that they are correct). Code should always use arrow functions to call instance methods (const handler = (x) => { this.listener(x); };), and should not obtain or pass references to instance methods (const handler = this.listener; handler(x);).</paragraph><paragraph>Note: in some specific situations, e.g. when binding functions in a template, arrow functions as properties are useful and create much more readable code. Use judgement with this rule. Also, see the Event Handlers section below.</paragraph><code language="javascript">class DelayHandler {
  constructor() {
    // Problem: `this` is not preserved in the callback. `this` in the callback
    // will not be an instance of DelayHandler.
    setTimeout(this.patienceTracker, 5000);
  }
  private patienceTracker() {
    this.waitedPatiently = true;
  }
}
</code><code language="javascript">// Arrow functions usually should not be properties.
class DelayHandler {
  constructor() {
    // Bad: this code looks like it forgot to bind `this`.
    setTimeout(this.patienceTracker, 5000);
  }
  private patienceTracker = () => {
    this.waitedPatiently = true;
  }
}
</code><code language="javascript">// Explicitly manage `this` at call time.
class DelayHandler {
  constructor() {
    // Use anonymous functions if possible.
    setTimeout(() => {
      this.patienceTracker();
    }, 5000);
  }
  private patienceTracker() {
    this.waitedPatiently = true;
  }
}
</code><heading level="4">Event handlers</heading><paragraph>Event handlers may use arrow functions when there is no need to uninstall the handler (for example, if the event is emitted by the class itself). If the handler requires uninstallation, arrow function properties are the right approach, because they automatically capture this and provide a stable reference to uninstall.</paragraph><code language="javascript">// Event handlers may be anonymous functions or arrow function properties.
class Component {
  onAttached() {
    // The event is emitted by this class, no need to uninstall.
    this.addEventListener('click', () => {
      this.listener();
    });
    // this.listener is a stable reference, we can uninstall it later.
    window.addEventListener('onbeforeunload', this.listener);
  }
  onDetached() {
    // The event is emitted by window. If we don't uninstall, this.listener will
    // keep a reference to `this` because it's bound, causing a memory leak.
    window.removeEventListener('onbeforeunload', this.listener);
  }
  // An arrow function stored in a property is bound to `this` automatically.
  private listener = () => {
    confirm('Do you want to exit the page?');
  }
}
</code><paragraph>Do not use bind in the expression that installs an event handler, because it creates a temporary reference that can't be uninstalled.</paragraph><code language="javascript">// Binding listeners creates a temporary reference that prevents uninstalling.
class Component {
  onAttached() {
    // This creates a temporary reference that we won't be able to uninstall
    window.addEventListener('onbeforeunload', this.listener.bind(this));
  }
  onDetached() {
    // This bind creates a different reference, so this line does nothing.
    window.removeEventListener('onbeforeunload', this.listener.bind(this));
  }
  private listener() {
    confirm('Do you want to exit the page?');
  }
}
</code><heading level="4">Parameter initializers</heading><paragraph>Optional function parameters may be given a default initializer to use when the argument is omitted. Initializers must not have any observable side effects. Initializers should be kept as simple as possible.</paragraph><code language="javascript">function process(name: string, extraContext: string[] = []) {}
function activate(index = 0) {}
</code><code language="javascript">// BAD: side effect of incrementing the counter
let globalCounter = 0;
function newId(index = globalCounter++) {}

// BAD: exposes shared mutable state, which can introduce unintended coupling
// between function calls
class Foo {
  private readonly defaultPaths: string[];
  frobnicate(paths = defaultPaths) {}
}
</code><paragraph>Use default parameters sparingly. Prefer destructuring to create readable APIs when there are more than a small handful of optional parameters that do not have a natural order.</paragraph><heading level="4">Prefer rest and spread when appropriate</heading><paragraph>Use a rest parameter instead of accessing arguments. Never name a local variable or parameter arguments, which confusingly shadows the built-in name.</paragraph><code language="javascript">function variadic(array: string[], ...numbers: number[]) {}
</code><paragraph>Use function spread syntax instead of Function.prototype.apply.</paragraph><heading level="4">Formatting functions</heading><paragraph>Blank lines at the start or end of the function body are not allowed.</paragraph><paragraph>A single blank line may be used within function bodies sparingly to create logical groupings of statements.</paragraph><paragraph>Generators should attach the * to the function and yield keywords, as in function* foo() and yield* iter, rather than function *foo() or yield *iter.</paragraph><paragraph>Parentheses around the left-hand side of a single-argument arrow function are recommended but not required.</paragraph><paragraph>Do not put a space after the ... in rest or spread syntax.</paragraph><code language="javascript">function myFunction(...elements: number[]) {}
myFunction(...array, ...iterable, ...generator());
</code><heading level="3">this</heading><paragraph>Only use this in class constructors and methods, functions that have an explicit this type declared (e.g. function func(this: ThisType, ...)), or in arrow functions defined in a scope where this may be used.</paragraph><paragraph>Never use this to refer to the global object, the context of an eval, the target of an event, or unnecessarily call()ed or apply()ed functions.</paragraph><code language="code">this.alert('Hello');
</code><heading level="3">Interfaces</heading><heading level="3">Primitive literals</heading><heading level="4">String literals</heading><heading level="5">Use single quotes</heading><paragraph>Ordinary string literals are delimited with single quotes ('), rather than double quotes (").</paragraph><paragraph>Tip: if a string contains a single quote character, consider using a template string to avoid having to escape the quote.</paragraph><heading level="5">No line continuations</heading><paragraph>Do not use line continuations (that is, ending a line inside a string literal with a backslash) in either ordinary or template string literals. Even though ES5 allows this, it can lead to tricky errors if any trailing whitespace comes after the slash, and is less obvious to readers.</paragraph><paragraph>Disallowed:</paragraph><code language="javascript">const LONG_STRING = 'This is a very very very very very very very long string. \
    It inadvertently contains long stretches of spaces due to how the \
    continued lines are indented.';
</code><paragraph>Instead, write</paragraph><code language="javascript">const LONG_STRING = 'This is a very very very very very very long string. ' +
    'It does not contain long stretches of spaces because it uses ' +
    'concatenated strings.';
const SINGLE_STRING =
    'http://it.is.also/acceptable_to_use_a_single_long_string_when_breaking_would_hinder_search_discoverability';
</code><heading level="5">Template literals</heading><paragraph>Use template literals (delimited with `) over complex string concatenation, particularly if multiple string literals are involved. Template literals may span multiple lines.</paragraph><paragraph>If a template literal spans multiple lines, it does not need to follow the indentation of the enclosing block, though it may if the added whitespace does not matter.</paragraph><paragraph>Example:</paragraph><code language="javascript">function arithmetic(a: number, b: number) {
  return `Here is a table of arithmetic operations:
${a} + ${b} = ${a + b}
${a} - ${b} = ${a - b}
${a} * ${b} = ${a * b}
${a} / ${b} = ${a / b}`;
}
</code><heading level="4">Number literals</heading><paragraph>Numbers may be specified in decimal, hex, octal, or binary. Use exactly 0x, 0o, and 0b prefixes, with lowercase letters, for hex, octal, and binary, respectively. Never include a leading zero unless it is immediately followed by x, o, or b.</paragraph><heading level="4">Type coercion</heading><paragraph>TypeScript code may use the String() and Boolean() (note: no new!) functions, string template literals, or !! to coerce types.</paragraph><code language="javascript">const bool = Boolean(false);
const str = String(aNumber);
const bool2 = !!str;
const str2 = `result: ${bool2}`;
</code><paragraph>Values of enum types (including unions of enum types and other types) must not be converted to booleans with Boolean() or !!, and must instead be compared explicitly with comparison operators.</paragraph><code language="javascript">enum SupportLevel {
  NONE,
  BASIC,
  ADVANCED,
}

const level: SupportLevel = ...;
let enabled = Boolean(level);

const maybeLevel: SupportLevel|undefined = ...;
enabled = !!maybeLevel;
</code><code language="javascript">enum SupportLevel {
  NONE,
  BASIC,
  ADVANCED,
}

const level: SupportLevel = ...;
let enabled = level !== SupportLevel.NONE;

const maybeLevel: SupportLevel|undefined = ...;
enabled = level !== undefined && level !== SupportLevel.NONE;
</code><paragraph>Why?</paragraph><paragraph>For most purposes, it doesn't matter what number or string value an enum name is mapped to at runtime, because values of enum types are referred to by name in source code. Consequently, engineers are accustomed to not thinking about this, and so situations where it does matter are undesirable because they will be surprising. Such is the case with conversion of enums to booleans; in particular, by default, the first declared enum value is falsy (because it is 0) while the others are truthy, which is likely to be unexpected. Readers of code that uses an enum value may not even know whether it's the first declared value or not.</paragraph><paragraph>Using string concatenation to cast to string is discouraged, as we check that operands to the plus operator are of matching types.</paragraph><paragraph>Code must use Number() to parse numeric values, and must check its return for NaN values explicitly, unless failing to parse is impossible from context.</paragraph><paragraph>Note: Number(''), Number(' '), and Number('\t') would return 0 instead of NaN. Number('Infinity') and Number('-Infinity') would return Infinity and -Infinity respectively. Additionally, exponential notation such as Number('1e+309') and Number('-1e+309') can overflow into Infinity. These cases may require special handling.</paragraph><code language="javascript">const aNumber = Number('123');
if (!isFinite(aNumber)) throw new Error(...);
</code><paragraph>Code must not use unary plus (+) to coerce strings to numbers. Parsing numbers can fail, has surprising corner cases, and can be a code smell (parsing at the wrong layer). A unary plus is too easy to miss in code reviews given this.</paragraph><code language="javascript">const x = +y;
</code><paragraph>Code also must not use parseInt or parseFloat to parse numbers, except for non-base-10 strings (see below). Both of those functions ignore trailing characters in the string, which can shadow error conditions (e.g. parsing 12 dwarves as 12).</paragraph><code language="javascript">const n = parseInt(someString, 10);  // Error prone,
const f = parseFloat(someString);    // regardless of passing a radix.
</code><paragraph>Code that requires parsing with a radix must check that its input contains only appropriate digits for that radix before calling into parseInt;</paragraph><code language="javascript">if (!/^[a-fA-F0-9]+$/.test(someString)) throw new Error(...);
// Needed to parse hexadecimal.
// tslint:disable-next-line:ban
const n = parseInt(someString, 16);  // Only allowed for radix != 10
</code><paragraph>Use Number() followed by Math.floor or Math.trunc (where available) to parse integer numbers:</paragraph><code language="javascript">let f = Number(someString);
if (isNaN(f)) handleError();
f = Math.floor(f);
</code><heading level="5">Implicit coercion</heading><paragraph>Do not use explicit boolean coercions in conditional clauses that have implicit boolean coercion. Those are the conditions in an if, for and while statements.</paragraph><code language="javascript">const foo: MyInterface|null = ...;
if (!!foo) {...}
while (!!foo) {...}
</code><code language="javascript">const foo: MyInterface|null = ...;
if (foo) {...}
while (foo) {...}
</code><paragraph>As with explicit conversions, values of enum types (including unions of enum types and other types) must not be implicitly coerced to booleans, and must instead be compared explicitly with comparison operators.</paragraph><code language="javascript">enum SupportLevel {
  NONE,
  BASIC,
  ADVANCED,
}

const level: SupportLevel = ...;
if (level) {...}

const maybeLevel: SupportLevel|undefined = ...;
if (level) {...}
</code><code language="javascript">enum SupportLevel {
  NONE,
  BASIC,
  ADVANCED,
}

const level: SupportLevel = ...;
if (level !== SupportLevel.NONE) {...}

const maybeLevel: SupportLevel|undefined = ...;
if (level !== undefined && level !== SupportLevel.NONE) {...}
</code><paragraph>Other types of values may be either implicitly coerced to booleans or compared explicitly with comparison operators:</paragraph><code language="code">// Explicitly comparing > 0 is OK:
if (arr.length > 0) {...}
// so is relying on boolean coercion:
if (arr.length) {...}
</code><heading level="3">Control structures</heading><heading level="4">Control flow statements and blocks</heading><paragraph>Control flow statements (if, else, for, do, while, etc) always use braced blocks for the containing code, even if the body contains only a single statement. The first statement of a non-empty block must begin on its own line.</paragraph><code language="javascript">for (let i = 0; i < x; i++) {
  doSomethingWith(i);
}

if (x) {
  doSomethingWithALongMethodNameThatForcesANewLine(x);
}
</code><code language="code">if (x)
  doSomethingWithALongMethodNameThatForcesANewLine(x);

for (let i = 0; i < x; i++) doSomethingWith(i);
</code><paragraph>Exception: if statements fitting on one line may elide the block.</paragraph><code language="code">if (x) x.doFoo();
</code><heading level="5">Assignment in control statements</heading><paragraph>Prefer to avoid assignment of variables inside control statements. Assignment can be easily mistaken for equality checks inside control statements.</paragraph><code language="javascript">if (x = someFunction()) {
  // Assignment easily mistaken with equality check
  // ...
}
</code><code language="javascript">x = someFunction();
if (x) {
  // ...
}
</code><paragraph>In cases where assignment inside the control statement is preferred, enclose the assignment in additional parenthesis to indicate it is intentional.</paragraph><code language="javascript">while ((x = someFunction())) {
  // Double parenthesis shows assignment is intentional
  // ...
}

</code><heading level="5">Iterating containers</heading><paragraph>Prefer for (... of someArr) to iterate over arrays. Array.prototype.forEach and vanilla for loops are also allowed:</paragraph><code language="javascript">for (const x of someArr) {
  // x is a value of someArr.
}

for (let i = 0; i < someArr.length; i++) {
  // Explicitly count if the index is needed, otherwise use the for/of form.
  const x = someArr[i];
  // ...
}
for (const [i, x] of someArr.entries()) {
  // Alternative version of the above.
}
</code><paragraph>for-in loops may only be used on dict-style objects (see below for more info). Do not use for (... in ...) to iterate over arrays as it will counterintuitively give the array's indices (as strings!), not values:</paragraph><code language="javascript">for (const x in someArray) {
  // x is the index!
}
</code><paragraph>Object.prototype.hasOwnProperty should be used in for-in loops to exclude unwanted prototype properties. Prefer for-of with Object.keys, Object.values, or Object.entries over for-in when possible.</paragraph><code language="javascript">for (const key in obj) {
  if (!obj.hasOwnProperty(key)) continue;
  doWork(key, obj[key]);
}
for (const key of Object.keys(obj)) {
  doWork(key, obj[key]);
}
for (const value of Object.values(obj)) {
  doWorkValOnly(value);
}
for (const [key, value] of Object.entries(obj)) {
  doWork(key, value);
}
</code><heading level="4">Grouping parentheses</heading><paragraph>Optional grouping parentheses are omitted only when the author and reviewer agree that there is no reasonable chance that the code will be misinterpreted without them, nor would they have made the code easier to read. It is not reasonable to assume that every reader has the entire operator precedence table memorized.</paragraph><paragraph>Do not use unnecessary parentheses around the entire expression following delete, typeof, void, return, throw, case, in, of, or yield.</paragraph><heading level="4">Exception handling</heading><paragraph>Exceptions are an important part of the language and should be used whenever exceptional cases occur.</paragraph><paragraph>Custom exceptions provide a great way to convey additional error information from functions. They should be defined and used wherever the native Error type is insufficient.</paragraph><paragraph>Prefer throwing exceptions over ad-hoc error-handling approaches (such as passing an error container reference type, or returning an object with an error property).</paragraph><heading level="5">Instantiate errors using new</heading><paragraph>Always use new Error() when instantiating exceptions, instead of just calling Error(). Both forms create a new Error instance, but using new is more consistent with how other objects are instantiated.</paragraph><code language="code">throw new Error('Foo is not a valid bar.');
</code><code language="code">throw Error('Foo is not a valid bar.');
</code><heading level="5">Only throw errors</heading><paragraph>JavaScript (and thus TypeScript) allow throwing or rejecting a Promise with arbitrary values. However if the thrown or rejected value is not an Error, it does not populate stack trace information, making debugging hard. This treatment extends to Promise rejection values as Promise.reject(obj) is equivalent to throw obj; in async functions.</paragraph><code language="javascript">// bad: does not get a stack trace.
throw 'oh noes!';
// For promises
new Promise((resolve, reject) => void reject('oh noes!'));
Promise.reject();
Promise.reject('oh noes!');
</code><paragraph>Instead, only throw (subclasses of) Error:</paragraph><code language="javascript">// Throw only Errors
throw new Error('oh noes!');
// ... or subtypes of Error.
class MyError extends Error {}
throw new MyError('my oh noes!');
// For promises
new Promise((resolve) => resolve()); // No reject is OK.
new Promise((resolve, reject) => void reject(new Error('oh noes!')));
Promise.reject(new Error('oh noes!'));
</code><heading level="5">Catching and rethrowing</heading><paragraph>When catching errors, code should assume that all thrown errors are instances of Error.</paragraph><code language="javascript">function assertIsError(e: unknown): asserts e is Error {
  if (!(e instanceof Error)) throw new Error("e is not an Error");
}

try {
  doSomething();
} catch (e: unknown) {
  // All thrown errors must be Error subtypes. Do not handle
  // other possible values unless you know they are thrown.
  assertIsError(e);
  displayError(e.message);
  // or rethrow:
  throw e;
}
</code><paragraph>Exception handlers must not defensively handle non-Error types unless the called API is conclusively known to throw non-Errors in violation of the above rule. In that case, a comment should be included to specifically identify where the non-Errors originate.</paragraph><code language="javascript">try {
  badApiThrowingStrings();
} catch (e: unknown) {
  // Note: bad API throws strings instead of errors.
  if (typeof e === 'string') { ... }
}
</code><paragraph>Why?</paragraph><paragraph>Avoid overly defensive programming. Repeating the same defenses against a problem that will not exist in most code leads to boiler-plate code that is not useful.</paragraph><heading level="5">Empty catch blocks</heading><paragraph>It is very rarely correct to do nothing in response to a caught exception. When it truly is appropriate to take no action whatsoever in a catch block, the reason this is justified is explained in a comment.</paragraph><code language="javascript">  try {
    return handleNumericResponse(response);
  } catch (e: unknown) {
    // Response is not numeric. Continue to handle as text.
  }
  return handleTextResponse(response);
</code><paragraph>Disallowed:</paragraph><code language="javascript">  try {
    shouldFail();
    fail('expected an error');
  } catch (expected: unknown) {
  }
</code><paragraph>Tip: Unlike in some other languages, patterns like the above simply don't work since this will catch the error thrown by fail. Use assertThrows() instead.</paragraph><heading level="4">Switch statements</heading><paragraph>All switch statements must contain a default statement group, even if it contains no code. The default statement group must be last.</paragraph><code language="javascript">switch (x) {
  case Y:
    doSomethingElse();
    break;
  default:
    // nothing to do.
}
</code><paragraph>Within a switch block, each statement group either terminates abruptly with a break, a return statement, or by throwing an exception. Non-empty statement groups (case ...) must not fall through (enforced by the compiler):</paragraph><code language="javascript">switch (x) {
  case X:
    doSomething();
    // fall through - not allowed!
  case Y:
    // ...
}
</code><paragraph>Empty statement groups are allowed to fall through:</paragraph><code language="javascript">switch (x) {
  case X:
  case Y:
    doSomething();
    break;
  default: // nothing to do.
}
</code><heading level="4">Equality checks</heading><paragraph>Always use triple equals (===) and not equals (!==). The double equality operators cause error prone type coercions that are hard to understand and slower to implement for JavaScript Virtual Machines. See also the JavaScript equality table.</paragraph><code language="javascript">if (foo == 'bar' || baz != bam) {
  // Hard to understand behaviour due to type coercion.
}
</code><code language="javascript">if (foo === 'bar' || baz !== bam) {
  // All good here.
}
</code><paragraph>Exception: Comparisons to the literal null value may use the == and != operators to cover both null and undefined values.</paragraph><code language="javascript">if (foo == null) {
  // Will trigger when foo is null or undefined.
}
</code><heading level="4">Type and non-nullability assertions</heading><paragraph>Type assertions (x as SomeType) and non-nullability assertions (y!) are unsafe. Both only silence the TypeScript compiler, but do not insert any runtime checks to match these assertions, so they can cause your program to crash at runtime.</paragraph><paragraph>Because of this, you should not use type and non-nullability assertions without an obvious or explicit reason for doing so.</paragraph><paragraph>Instead of the following:</paragraph><code language="code">(x as Foo).foo();

y!.bar();
</code><paragraph>When you want to assert a type or non-nullability the best answer is to explicitly write a runtime check that performs that check.</paragraph><code language="javascript">// assuming Foo is a class.
if (x instanceof Foo) {
  x.foo();
}

if (y) {
  y.bar();
}
</code><paragraph>Sometimes due to some local property of your code you can be sure that the assertion form is safe. In those situations, you should add clarification to explain why you are ok with the unsafe behavior:</paragraph><code language="code">// x is a Foo, because ...
(x as Foo).foo();

// y cannot be null, because ...
y!.bar();
</code><paragraph>If the reasoning behind a type or non-nullability assertion is obvious, the comments may not be necessary. For example, generated proto code is always nullable, but perhaps it is well-known in the context of the code that certain fields are always provided by the backend. Use your judgement.</paragraph><heading level="5">Type assertion syntax</heading><paragraph>Type assertions must use the as syntax (as opposed to the angle brackets syntax). This enforces parentheses around the assertion when accessing a member.</paragraph><code language="javascript">const x = (<Foo>z).length;
const y = <Foo>z.length;
</code><code language="javascript">// z must be Foo because ...
const x = (z as Foo).length;
</code><heading level="5">Double assertions</heading><paragraph>From the TypeScript handbook, TypeScript only allows type assertions which convert to a more specific or less specific version of a type. Adding a type assertion (x as Foo) which does not meet this criteria will give the error: Conversion of type 'X' to type 'Y' may be a mistake because neither type sufficiently overlaps with the other.</paragraph><paragraph>If you are sure an assertion is safe, you can perform a double assertion. This involves casting through unknown since it is less specific than all types.</paragraph><code language="code">// x is a Foo here, because...
(x as unknown as Foo).fooMethod();
</code><paragraph>Use unknown (instead of any or {}) as the intermediate type.</paragraph><heading level="5">Type assertions and object literals</heading><paragraph>Use type annotations (: Foo) instead of type assertions (as Foo) to specify the type of an object literal. This allows detecting refactoring bugs when the fields of an interface change over time.</paragraph><code language="javascript">interface Foo {
  bar: number;
  baz?: string;  // was "bam", but later renamed to "baz".
}

const foo = {
  bar: 123,
  bam: 'abc',  // no error!
} as Foo;

function func() {
  return {
    bar: 123,
    bam: 'abc',  // no error!
  } as Foo;
}
</code><code language="javascript">interface Foo {
  bar: number;
  baz?: string;
}

const foo: Foo = {
  bar: 123,
  bam: 'abc',  // complains about "bam" not being defined on Foo.
};

function func(): Foo {
  return {
    bar: 123,
    bam: 'abc',   // complains about "bam" not being defined on Foo.
  };
}
</code><heading level="4">Keep try blocks focused</heading><paragraph>Limit the amount of code inside a try block, if this can be done without hurting readability.</paragraph><code language="javascript">try {
  const result = methodThatMayThrow();
  use(result);
} catch (error: unknown) {
  // ...
}
</code><code language="javascript">let result;
try {
  result = methodThatMayThrow();
} catch (error: unknown) {
  // ...
}
use(result);
</code><paragraph>Moving the non-throwable lines out of the try/catch block helps the reader learn which method throws exceptions. Some inline calls that do not throw exceptions could stay inside because they might not be worth the extra complication of a temporary variable.</paragraph><paragraph>Exception: There may be performance issues if try blocks are inside a loop. Widening try blocks to cover a whole loop is ok.</paragraph><heading level="3">Decorators</heading><paragraph>Decorators are syntax with an @ prefix, like @MyDecorator.</paragraph><paragraph>Do not define new decorators. Only use the decorators defined by frameworks:</paragraph><list type="ul"><item>Angular (e.g. @Component, @NgModule, etc.)</item><item>Polymer (e.g. @property)</item></list><paragraph>Why?</paragraph><paragraph>We generally want to avoid decorators, because they were an experimental feature that have since diverged from the TC39 proposal and have known bugs that won't be fixed.</paragraph><paragraph>When using decorators, the decorator must immediately precede the symbol it decorates, with no empty lines between:</paragraph><code language="javascript">/** JSDoc comments go before decorators */
@Component({...})  // Note: no empty line after the decorator.
class MyComp {
  @Input() myField: string;  // Decorators on fields may be on the same line...

  @Input()
  myOtherField: string;  // ... or wrap.
}
</code><heading level="3">Disallowed features</heading><heading level="4">Wrapper objects for primitive types</heading><paragraph>TypeScript code must not instantiate the wrapper classes for the primitive types String, Boolean, and Number. Wrapper classes have surprising behavior, such as new Boolean(false) evaluating to true.</paragraph><code language="javascript">const s = new String('hello');
const b = new Boolean(false);
const n = new Number(5);
</code><paragraph>The wrappers may be called as functions for coercing (which is preferred over using + or concatenating the empty string) or creating symbols. See type coercion for more information.</paragraph><heading level="4">Automatic Semicolon Insertion</heading><paragraph>Do not rely on Automatic Semicolon Insertion (ASI). Explicitly end all statements using a semicolon. This prevents bugs due to incorrect semicolon insertions and ensures compatibility with tools with limited ASI support (e.g. clang-format).</paragraph><heading level="4">Const enums</heading><paragraph>Code must not use const enum; use plain enum instead.</paragraph><paragraph>Why?</paragraph><paragraph>TypeScript enums already cannot be mutated; const enum is a separate language feature related to optimization that makes the enum invisible to JavaScript users of the module.</paragraph><heading level="4">Debugger statements</heading><paragraph>Debugger statements must not be included in production code.</paragraph><code language="javascript">function debugMe() {
  debugger;
}
</code><heading level="4">with</heading><paragraph>Do not use the with keyword. It makes your code harder to understand and has been banned in strict mode since ES5.</paragraph><heading level="4">Dynamic code evaluation</heading><paragraph>Do not use eval or the Function(...string) constructor (except for code loaders). These features are potentially dangerous and simply do not work in environments using strict Content Security Policies.</paragraph><heading level="4">Non-standard features</heading><paragraph>Do not use non-standard ECMAScript or Web Platform features.</paragraph><paragraph>This includes:</paragraph><list type="ul"><item>Old features that have been marked deprecated or removed entirely from ECMAScript / the Web Platform (see MDN)</item><item>New ECMAScript features that are not yet standardized Avoid using features that are in current TC39 working draft or currently in the proposal process Use only ECMAScript features defined in the current ECMA-262 specification</item><item>Proposed but not-yet-complete web standards:</item><item>Non-standard language "extensions" (such as those provided by some external transpilers)</item></list><list type="ul"><item>Avoid using features that are in current TC39 working draft or currently in the proposal process</item><item>Use only ECMAScript features defined in the current ECMA-262 specification</item></list><paragraph>Projects targeting specific JavaScript runtimes, such as latest-Chrome-only, Chrome extensions, Node.JS, Electron, can obviously use those APIs. Use caution when considering an API surface that is proprietary and only implemented in some browsers; consider whether there is a common library that can abstract this API surface away for you.</paragraph><heading level="4">Modifying builtin objects</heading><paragraph>Never modify builtin types, either by adding methods to their constructors or to their prototypes. Avoid depending on libraries that do this.</paragraph><paragraph>Do not add symbols to the global object unless absolutely necessary (e.g. required by a third-party API).</paragraph><heading level="2">Naming</heading><heading level="3">Identifiers</heading><paragraph>Identifiers must use only ASCII letters, digits, underscores (for constants and structured test method names), and (rarely) the '$' sign.</paragraph><heading level="4">Naming style</heading><paragraph>TypeScript expresses information in types, so names should not be decorated with information that is included in the type. (See also Testing Blog for more about what not to include.)</paragraph><paragraph>Some concrete examples of this rule:</paragraph><list type="ul"><item>Do not use trailing or leading underscores for private properties or methods.</item><item>Do not use the opt_ prefix for optional parameters.</item><item>Do not mark interfaces specially (IMyInterface or MyFooInterface) unless it's idiomatic in its environment. When introducing an interface for a class, give it a name that expresses why the interface exists in the first place (e.g. class TodoItem and interface TodoItemStorage if the interface expresses the format used for storage/serialization in JSON).</item><item>Suffixing Observables with $ is a common external convention and can help resolve confusion regarding observable values vs concrete values. Judgement on whether this is a useful convention is left up to individual teams, but should be consistent within projects.</item></list><heading level="4">Descriptive names</heading><paragraph>Names must be descriptive and clear to a new reader. Do not use abbreviations that are ambiguous or unfamiliar to readers outside your project, and do not abbreviate by deleting letters within a word.</paragraph><list type="ul"><item>Exception: Variables that are in scope for 10 lines or fewer, including arguments that are not part of an exported API, may use short (e.g. single letter) variable names.</item></list><code language="code">// Good identifiers:
errorCount          // No abbreviation.
dnsConnectionIndex  // Most people know what "DNS" stands for.
referrerUrl         // Ditto for "URL".
customerId          // "Id" is both ubiquitous and unlikely to be misunderstood.
</code><code language="code">// Disallowed identifiers:
n                   // Meaningless.
nErr                // Ambiguous abbreviation.
nCompConns          // Ambiguous abbreviation.
wgcConnections      // Only your group knows what this stands for.
pcReader            // Lots of things can be abbreviated "pc".
cstmrId             // Deletes internal letters.
kSecondsPerDay      // Do not use Hungarian notation.
customerID          // Incorrect camelcase of "ID".
</code><heading level="4">Camel case</heading><paragraph>Treat abbreviations like acronyms in names as whole words, i.e. use loadHttpUrl, not loadHTTPURL, unless required by a platform name (e.g. XMLHttpRequest).</paragraph><heading level="4">Dollar sign</heading><paragraph>Identifiers should not generally use $, except when required by naming conventions for third party frameworks. See above for more on using $ with Observable values.</paragraph><heading level="3">Rules by identifier type</heading><paragraph>Most identifier names should follow the casing in the table below, based on the identifier's type.</paragraph><table><thead><tr><th>Style</th><th>Category</th></tr></thead><tbody><tr><td>UpperCamelCase</td><td>class / interface / type / enum / decorator / type parameters / component functions in TSX / JSXElement type parameter</td></tr><tr><td>lowerCamelCase</td><td>variable / parameter / function / method / property / module alias</td></tr><tr><td>CONSTANT_CASE</td><td>global constant values, including enum values. See Constants below.</td></tr><tr><td>#ident</td><td>private identifiers are never used.</td></tr></tbody></table><heading level="4">Type parameters</heading><paragraph>Type parameters, like in Array<T>, may use a single upper case character (T) or UpperCamelCase.</paragraph><heading level="4">Test names</heading><paragraph>Test method names inxUnit-style test frameworks may be structured with _ separators, e.g. testX_whenY_doesZ().</paragraph><heading level="4">_ prefix/suffix</heading><paragraph>Identifiers must not use _ as a prefix or suffix.</paragraph><paragraph>This also means that _ must not be used as an identifier by itself (e.g. to indicate a parameter is unused).</paragraph><paragraph>Tip: If you only need some of the elements from an array (or TypeScript tuple), you can insert extra commas in a destructuring statement to ignore in-between elements:</paragraph><code language="javascript">const [a, , b] = [1, 5, 10];  // a <- 1, b <- 10
</code><heading level="4">Imports</heading><paragraph>Module namespace imports are lowerCamelCase while files are snake_case, which means that imports correctly will not match in casing style, such as</paragraph><code language="javascript">import * as fooBar from './foo_bar';
</code><paragraph>Some libraries might commonly use a namespace import prefix that violates this naming scheme, but overbearingly common open source use makes the violating style more readable. The only libraries that currently fall under this exception are:</paragraph><heading level="4">Constants</heading><paragraph>Immutable: CONSTANT_CASE indicates that a value is intended to not be changed, and may be used for values that can technically be modified (i.e. values that are not deeply frozen) to indicate to users that they must not be modified.</paragraph><code language="javascript">const UNIT_SUFFIXES = {
  'milliseconds': 'ms',
  'seconds': 's',
};
// Even though per the rules of JavaScript UNIT_SUFFIXES is
// mutable, the uppercase shows users to not modify it.
</code><paragraph>A constant can also be a static readonly property of a class.</paragraph><code language="javascript">class Foo {
  private static readonly MY_SPECIAL_NUMBER = 5;

  bar() {
    return 2 * Foo.MY_SPECIAL_NUMBER;
  }
}
</code><paragraph>Global: Only symbols declared on the module level, static fields of module level classes, and values of module level enums, may use CONST_CASE. If a value can be instantiated more than once over the lifetime of the program (e.g. a local variable declared within a function, or a static field on a class nested in a function) then it must use lowerCamelCase.</paragraph><paragraph>If a value is an arrow function that implements an interface, then it may be declared lowerCamelCase.</paragraph><heading level="4">Aliases</heading><paragraph>When creating a local-scope alias of an existing symbol, use the format of the existing identifier. The local alias must match the existing naming and format of the source. For variables use const for your local aliases, and for class fields use the readonly attribute.</paragraph><paragraph>Note: If you're creating an alias just to expose it to a template in your framework of choice, remember to also apply the proper access modifiers.</paragraph><code language="javascript">const {BrewStateEnum} = SomeType;
const CAPACITY = 5;

class Teapot {
  readonly BrewStateEnum = BrewStateEnum;
  readonly CAPACITY = CAPACITY;
}
</code><heading level="2">Type system</heading><heading level="3">Type inference</heading><paragraph>Code may rely on type inference as implemented by the TypeScript compiler for all type expressions (variables, fields, return types, etc).</paragraph><code language="javascript">const x = 15;  // Type inferred.
</code><paragraph>Leave out type annotations for trivially inferred types: variables or parameters initialized to a string, number, boolean, RegExp literal or new expression.</paragraph><code language="javascript">const x: boolean = true;  // Bad: 'boolean' here does not aid readability
</code><code language="javascript">// Bad: 'Set' is trivially inferred from the initialization
const x: Set<string> = new Set();
</code><paragraph>Explicitly specifying types may be required to prevent generic type parameters from being inferred as unknown. For example, initializing generic types with no values (e.g. empty arrays, objects, Maps, or Sets).</paragraph><code language="javascript">const x = new Set<string>();
</code><paragraph>For more complex expressions, type annotations can help with readability of the program:</paragraph><code language="javascript">// Hard to reason about the type of 'value' without an annotation.
const value = await rpc.getSomeValue().transform();
</code><code language="javascript">// Can tell the type of 'value' at a glance.
const value: string[] = await rpc.getSomeValue().transform();
</code><paragraph>Whether an annotation is required is decided by the code reviewer.</paragraph><heading level="4">Return types</heading><paragraph>Whether to include return type annotations for functions and methods is up to the code author. Reviewers may ask for annotations to clarify complex return types that are hard to understand. Projects may have a local policy to always require return types, but this is not a general TypeScript style requirement.</paragraph><paragraph>There are two benefits to explicitly typing out the implicit return values of functions and methods:</paragraph><list type="ul"><item>More precise documentation to benefit readers of the code.</item><item>Surface potential type errors faster in the future if there are code changes that change the return type of the function.</item></list><heading level="3">Undefined and null</heading><paragraph>TypeScript supports undefined and null types. Nullable types can be constructed as a union type (string|null); similarly with undefined. There is no special syntax for unions of undefined and null.</paragraph><paragraph>TypeScript code can use either undefined or null to denote absence of a value, there is no general guidance to prefer one over the other. Many JavaScript APIs use undefined (e.g. Map.get), while many DOM and Google APIs use null (e.g. Element.getAttribute), so the appropriate absent value depends on the context.</paragraph><heading level="4">Nullable/undefined type aliases</heading><paragraph>Type aliases must not include |null or |undefined in a union type. Nullable aliases typically indicate that null values are being passed around through too many layers of an application, and this clouds the source of the original issue that resulted in null. They also make it unclear when specific values on a class or interface might be absent.</paragraph><paragraph>Instead, code must only add |null or |undefined when the alias is actually used. Code should deal with null values close to where they arise, using the above techniques.</paragraph><code language="javascript">// Bad
type CoffeeResponse = Latte|Americano|undefined;

class CoffeeService {
  getLatte(): CoffeeResponse { ... };
}
</code><code language="javascript">// Better
type CoffeeResponse = Latte|Americano;

class CoffeeService {
  getLatte(): CoffeeResponse|undefined { ... };
}
</code><heading level="4">Prefer optional over |undefined</heading><paragraph>In addition, TypeScript supports a special construct for optional parameters and fields, using ?:</paragraph><code language="javascript">interface CoffeeOrder {
  sugarCubes: number;
  milk?: Whole|LowFat|HalfHalf;
}

function pourCoffee(volume?: Milliliter) { ... }
</code><paragraph>Optional parameters implicitly include |undefined in their type. However, they are different in that they can be left out when constructing a value or calling a method. For example, {sugarCubes: 1} is a valid CoffeeOrder because milk is optional.</paragraph><paragraph>Use optional fields (on interfaces or classes) and parameters rather than a |undefined type.</paragraph><paragraph>For classes preferably avoid this pattern altogether and initialize as many fields as possible.</paragraph><code language="javascript">class MyClass {
  field = '';
}
</code><heading level="3">Use structural types</heading><paragraph>TypeScript's type system is structural, not nominal. That is, a value matches a type if it has at least all the properties the type requires and the properties' types match, recursively.</paragraph><paragraph>When providing a structural-based implementation, explicitly include the type at the declaration of the symbol (this allows more precise type checking and error reporting).</paragraph><code language="javascript">const foo: Foo = {
  a: 123,
  b: 'abc',
}
</code><code language="javascript">const badFoo = {
  a: 123,
  b: 'abc',
}
</code><paragraph>Use interfaces to define structural types, not classes</paragraph><code language="javascript">interface Foo {
  a: number;
  b: string;
}

const foo: Foo = {
  a: 123,
  b: 'abc',
}
</code><code language="javascript">class Foo {
  readonly a: number;
  readonly b: number;
}

const foo: Foo = {
  a: 123,
  b: 'abc',
}
</code><paragraph>Why?</paragraph><paragraph>The badFoo object above relies on type inference. Additional fields could be added to badFoo and the type is inferred based on the object itself.</paragraph><paragraph>When passing a badFoo to a function that takes a Foo, the error will be at the function call site, rather than at the object declaration site. This is also useful when changing the surface of an interface across broad codebases.</paragraph><code language="javascript">interface Animal {
  sound: string;
  name: string;
}

function makeSound(animal: Animal) {}

/**
 * 'cat' has an inferred type of '{sound: string}'
 */
const cat = {
  sound: 'meow',
};

/**
 * 'cat' does not meet the type contract required for the function, so the
 * TypeScript compiler errors here, which may be very far from where 'cat' is
 * defined.
 */
makeSound(cat);

/**
 * Horse has a structural type and the type error shows here rather than the
 * function call.  'horse' does not meet the type contract of 'Animal'.
 */
const horse: Animal = {
  sound: 'niegh',
};

const dog: Animal = {
  sound: 'bark',
  name: 'MrPickles',
};

makeSound(dog);
makeSound(horse);
</code><heading level="3">Prefer interfaces over type literal aliases</heading><paragraph>TypeScript supports type aliases for naming a type expression. This can be used to name primitives, unions, tuples, and any other types.</paragraph><paragraph>However, when declaring types for objects, use interfaces instead of a type alias for the object literal expression.</paragraph><code language="javascript">interface User {
  firstName: string;
  lastName: string;
}
</code><code language="javascript">type User = {
  firstName: string,
  lastName: string,
}
</code><paragraph>Why?</paragraph><paragraph>These forms are nearly equivalent, so under the principle of just choosing one out of two forms to prevent variation, we should choose one. Additionally, there are also interesting technical reasons to prefer interface. That page quotes the TypeScript team lead: Honestly, my take is that it should really just be interfaces for anything that they can model. There is no benefit to type aliases when there are so many issues around display/perf.</paragraph><heading level="3">Array<T> Type</heading><paragraph>For simple types (containing just alphanumeric characters and dot), use the syntax sugar for arrays, T[] or readonly T[], rather than the longer form Array<T> or ReadonlyArray<T>.</paragraph><paragraph>For multi-dimensional non-readonly arrays of simple types, use the syntax sugar form (T[][], T[][][], and so on) rather than the longer form.</paragraph><paragraph>For anything more complex, use the longer form Array<T>.</paragraph><paragraph>These rules apply at each level of nesting, i.e. a simple T[] nested in a more complex type would still be spelled as T[], using the syntax sugar.</paragraph><code language="javascript">let a: string[];
let b: readonly string[];
let c: ns.MyObj[];
let d: string[][];
let e: Array<{n: number, s: string}>;
let f: Array<string|number>;
let g: ReadonlyArray<string|number>;
let h: InjectionToken<string[]>;  // Use syntax sugar for nested types.
let i: ReadonlyArray<string[]>;
let j: Array<readonly string[]>;
</code><code language="javascript">let a: Array<string>;  // The syntax sugar is shorter.
let b: ReadonlyArray<string>;
let c: Array<ns.MyObj>;
let d: Array<string[]>;
let e: {n: number, s: string}[];  // The braces make it harder to read.
let f: (string|number)[];         // Likewise with parens.
let g: readonly (string | number)[];
let h: InjectionToken<Array<string>>;
let i: readonly string[][];
let j: (readonly string[])[];
</code><heading level="3">Indexable types / index signatures ({[key: string]: T})</heading><paragraph>In JavaScript, it's common to use an object as an associative array (aka map, hash, or dict). Such objects can be typed using an index signature ([k: string]: T) in TypeScript:</paragraph><code language="javascript">const fileSizes: {[fileName: string]: number} = {};
fileSizes['readme.txt'] = 541;
</code><paragraph>In TypeScript, provide a meaningful label for the key. (The label only exists for documentation; it's unused otherwise.)</paragraph><code language="javascript">const users: {[key: string]: number} = ...;
</code><code language="javascript">const users: {[userName: string]: number} = ...;
</code><paragraph>Rather than using one of these, consider using the ES6 Map and Set types instead. JavaScript objects have surprising undesirable behaviors and the ES6 types more explicitly convey your intent. Also, Maps can be keyed by—and Sets can contain—types other than string.</paragraph><paragraph>TypeScript's builtin Record<Keys, ValueType> type allows constructing types with a defined set of keys. This is distinct from associative arrays in that the keys are statically known. See advice on that below.</paragraph><heading level="3">Mapped and conditional types</heading><paragraph>TypeScript's mapped types and conditional types allow specifying new types based on other types. TypeScript's standard library includes several type operators based on these (Record, Partial, Readonly etc).</paragraph><paragraph>These type system features allow succinctly specifying types and constructing powerful yet type safe abstractions. They come with a number of drawbacks though:</paragraph><list type="ul"><item>Compared to explicitly specifying properties and type relations (e.g. using interfaces and extension, see below for an example), type operators require the reader to mentally evaluate the type expression. This can make programs substantially harder to read, in particular combined with type inference and expressions crossing file boundaries.</item><item>Mapped & conditional types' evaluation model, in particular when combined with type inference, is underspecified, not always well understood, and often subject to change in TypeScript compiler versions. Code can accidentally compile or seem to give the right results. This increases future support cost of code using type operators.</item><item>Mapped & conditional types are most powerful when deriving types from complex and/or inferred types. On the flip side, this is also when they are most prone to create hard to understand and maintain programs.</item><item>Some language tooling does not work well with these type system features. E.g. your IDE's find references (and thus rename property refactoring) will not find properties in a Pick<T, Keys> type, and Code Search won't hyperlink them.</item></list><paragraph>The style recommendation is:</paragraph><list type="ul"><item>Always use the simplest type construct that can possibly express your code.</item><item>A little bit of repetition or verbosity is often much cheaper than the long term cost of complex type expressions.</item><item>Mapped & conditional types may be used, subject to these considerations.</item></list><paragraph>For example, TypeScript's builtin Pick<T, Keys> type allows creating a new type by subsetting another type T, but simple interface extension can often be easier to understand.</paragraph><code language="javascript">interface User {
  shoeSize: number;
  favoriteIcecream: string;
  favoriteChocolate: string;
}

// FoodPreferences has favoriteIcecream and favoriteChocolate, but not shoeSize.
type FoodPreferences = Pick<User, 'favoriteIcecream'|'favoriteChocolate'>;
</code><paragraph>This is equivalent to spelling out the properties on FoodPreferences:</paragraph><code language="javascript">interface FoodPreferences {
  favoriteIcecream: string;
  favoriteChocolate: string;
}
</code><paragraph>To reduce duplication, User could extend FoodPreferences, or (possibly better) nest a field for food preferences:</paragraph><code language="javascript">interface FoodPreferences { /* as above */ }
interface User extends FoodPreferences {
  shoeSize: number;
  // also includes the preferences.
}
</code><paragraph>Using interfaces here makes the grouping of properties explicit, improves IDE support, allows better optimization, and arguably makes the code easier to understand.</paragraph><heading level="3">any Type</heading><paragraph>TypeScript's any type is a super and subtype of all other types, and allows dereferencing all properties. As such, any is dangerous - it can mask severe programming errors, and its use undermines the value of having static types in the first place.</paragraph><paragraph>Consider not to use any. In circumstances where you want to use any, consider one of:</paragraph><heading level="4">Providing a more specific type</heading><paragraph>Use interfaces , an inline object type, or a type alias:</paragraph><code language="javascript">// Use declared interfaces to represent server-side JSON.
declare interface MyUserJson {
  name: string;
  email: string;
}

// Use type aliases for types that are repetitive to write.
type MyType = number|string;

// Or use inline object types for complex returns.
function getTwoThings(): {something: number, other: string} {
  // ...
  return {something, other};
}

// Use a generic type, where otherwise a library would say `any` to represent
// they don't care what type the user is operating on (but note "Return type
// only generics" below).
function nicestElement<T>(items: T[]): T {
  // Find the nicest element in items.
  // Code can also put constraints on T, e.g. <T extends HTMLElement>.
}
</code><heading level="4">Using unknown over any</heading><paragraph>The any type allows assignment into any other type and dereferencing any property off it. Often this behaviour is not necessary or desirable, and code just needs to express that a type is unknown. Use the built-in type unknown in that situation — it expresses the concept and is much safer as it does not allow dereferencing arbitrary properties.</paragraph><code language="javascript">// Can assign any value (including null or undefined) into this but cannot
// use it without narrowing the type or casting.
const val: unknown = value;
</code><code language="javascript">const danger: any = value /* result of an arbitrary expression */;
danger.whoops();  // This access is completely unchecked!
</code><paragraph>To safely use unknown values, narrow the type using a type guard</paragraph><heading level="4">Suppressing any lint warnings</heading><paragraph>Sometimes using any is legitimate, for example in tests to construct a mock object. In such cases, add a comment that suppresses the lint warning, and document why it is legitimate.</paragraph><code language="javascript">// This test only needs a partial implementation of BookService, and if
// we overlooked something the test will fail in an obvious way.
// This is an intentionally unsafe partial mock
// tslint:disable-next-line:no-any
const mockBookService = ({get() { return mockBook; }} as any) as BookService;
// Shopping cart is not used in this test
// tslint:disable-next-line:no-any
const component = new MyComponent(mockBookService, /* unused ShoppingCart */ null as any);
</code><heading level="3">{} Type</heading><paragraph>The {} type, also known as an empty interface type, represents a interface with no properties. An empty interface type has no specified properties and therefore any non-nullish value is assignable to it.</paragraph><code language="javascript">let player: {};

player = {
  health: 50,
}; // Allowed.

console.log(player.health) // Property 'health' does not exist on type '{}'.
</code><code language="javascript">function takeAnything(obj:{}) {

}

takeAnything({});
takeAnything({ a: 1, b: 2 });
</code><paragraph>Google3 code should not use {} for most use cases. {} represents any non-nullish primitive or object type, which is rarely appropriate. Prefer one of the following more-descriptive types:</paragraph><list type="ul"><item>unknown can hold any value, including null or undefined, and is generally more appropriate for opaque values.</item><item>Record<string, T> is better for dictionary-like objects, and provides better type safety by being explicit about the type T of contained values (which may itself be unknown).</item><item>object excludes primitives as well, leaving only non-nullish functions and objects, but without any other assumptions about what properties may be available.</item></list><heading level="3">Tuple types</heading><paragraph>If you are tempted to create a Pair type, instead use a tuple type:</paragraph><code language="javascript">interface Pair {
  first: string;
  second: string;
}
function splitInHalf(input: string): Pair {
  ...
  return {first: x, second: y};
}
</code><code language="javascript">function splitInHalf(input: string): [string, string] {
  ...
  return [x, y];
}

// Use it like:
const [leftHalf, rightHalf] = splitInHalf('my string');
</code><paragraph>However, often it's clearer to provide meaningful names for the properties.</paragraph><paragraph>If declaring an interface is too heavyweight, you can use an inline object literal type:</paragraph><code language="javascript">function splitHostPort(address: string): {host: string, port: number} {
  ...
}

// Use it like:
const address = splitHostPort(userAddress);
use(address.port);

// You can also get tuple-like behavior using destructuring:
const {host, port} = splitHostPort(userAddress);
</code><heading level="3">Wrapper types</heading><paragraph>There are a few types related to JavaScript primitives that should not ever be used:</paragraph><list type="ul"><item>String, Boolean, and Number have slightly different meaning from the corresponding primitive types string, boolean, and number. Always use the lowercase version.</item><item>Object has similarities to both {} and object, but is slightly looser. Use {} for a type that include everything except null and undefined, or lowercase object to further exclude the other primitive types (the three mentioned above, plus symbol and bigint).</item></list><paragraph>Further, never invoke the wrapper types as constructors (with new).</paragraph><heading level="3">Return type only generics</heading><paragraph>Avoid creating APIs that have return type only generics. When working with existing APIs that have return type only generics always explicitly specify the generics.</paragraph><paragraph>Google style requires using a number of tools in specific ways, outlined here.</paragraph><heading level="3">TypeScript compiler</heading><paragraph>All TypeScript files must pass type checking using the standard tool chain.</paragraph><heading level="4">@ts-ignore</heading><paragraph>Do not use @ts-ignore nor the variants @ts-expect-error or @ts-nocheck.</paragraph><paragraph>Why?</paragraph><paragraph>They superficially seem to be an easy way to fix a compiler error, but in practice, a specific compiler error is often caused by a larger problem that can be fixed more directly.</paragraph><paragraph>For example, if you are using @ts-ignore to suppress a type error, then it's hard to predict what types the surrounding code will end up seeing. For many type errors, the advice in how to best use any is useful.</paragraph><paragraph>You may use @ts-expect-error in unit tests, though you generally should not. @ts-expect-error suppresses all errors. It's easy to accidentally over-match and suppress more serious errors. Consider one of:</paragraph><list type="ul"><item>When testing APIs that need to deal with unchecked values at runtime, add casts to the expected type or to any and add an explanatory comment. This limits error suppression to a single expression.</item><item>Suppress the lint warning and document why, similar to suppressing any lint warnings.</item></list><heading level="3">Conformance</heading><paragraph>Google TypeScript includes several conformance frameworks, tsetse and tsec.</paragraph><paragraph>These rules are commonly used to enforce critical restrictions (such as defining globals, which could break the codebase) and security patterns (such as using eval or assigning to innerHTML), or more loosely to improve code quality.</paragraph><paragraph>Google-style TypeScript must abide by any applicable global or framework-local conformance rules.</paragraph><paragraph>There are two types of comments, JSDoc (/** ... */) and non-JSDoc ordinary comments (// ... or /* ... */).</paragraph><list type="ul"><item>Use /** JSDoc */ comments for documentation, i.e. comments a user of the code should read.</item><item>Use // line comments for implementation comments, i.e. comments that only concern the implementation of the code itself.</item></list><paragraph>JSDoc comments are understood by tools (such as editors and documentation generators), while ordinary comments are only for other humans.</paragraph><paragraph>Multi-line comments are indented at the same level as the surrounding code. They must use multiple single-line comments (//-style), not block comment style (/* */).</paragraph><code language="code">// This is
// fine
</code><code language="code">/*
 * This should
 * use multiple
 * single-line comments
 */

/* This should use // */
</code><paragraph>Comments are not enclosed in boxes drawn with asterisks or other characters.</paragraph><heading level="3">JSDoc general form</heading><paragraph>The basic formatting of JSDoc comments is as seen in this example:</paragraph><code language="javascript">/**
 * Multiple lines of JSDoc text are written here,
 * wrapped normally.
 * @param arg A number to do something to.
 */
function doSomething(arg: number) { … }
</code><paragraph>or in this single-line example:</paragraph><code language="javascript">/** This short jsdoc describes the function. */
function doSomething(arg: number) { … }
</code><paragraph>If a single-line comment overflows into multiple lines, it must use the multi-line style with /** and */ on their own lines.</paragraph><paragraph>Many tools extract metadata from JSDoc comments to perform code validation and optimization. As such, these comments must be well-formed.</paragraph><heading level="3">Markdown</heading><paragraph>JSDoc is written in Markdown, though it may include HTML when necessary.</paragraph><paragraph>This means that tooling parsing JSDoc will ignore plain text formatting, so if you did this:</paragraph><code language="code">/**
 * Computes weight based on three factors:
 *   items sent
 *   items received
 *   last timestamp
 */
</code><paragraph>it will be rendered like this:</paragraph><code language="code">Computes weight based on three factors: items sent items received last timestamp
</code><paragraph>Instead, write a Markdown list:</paragraph><code language="code">/**
 * Computes weight based on three factors:
 *
 * - items sent
 * - items received
 * - last timestamp
 */
</code><paragraph>Google style allows a subset of JSDoc tags. Most tags must occupy their own line, with the tag at the beginning of the line.</paragraph><code language="javascript">/**
 * The "param" tag must occupy its own line and may not be combined.
 * @param left A description of the left param.
 * @param right A description of the right param.
 */
function add(left: number, right: number) { ... }
</code><code language="javascript">/**
 * The "param" tag must occupy its own line and may not be combined.
 * @param left @param right
 */
function add(left: number, right: number) { ... }
</code><heading level="3">Line wrapping</heading><paragraph>Line-wrapped block tags are indented four spaces. Wrapped description text may be lined up with the description on previous lines, but this horizontal alignment is discouraged.</paragraph><code language="javascript">/**
 * Illustrates line wrapping for long param/return descriptions.
 * @param foo This is a param with a particularly long description that just
 *     doesn't fit on one line.
 * @return This returns something that has a lengthy description too long to fit
 *     in one line.
 */
exports.method = function(foo) {
  return 5;
};
</code><paragraph>Do not indent when wrapping a @desc or @fileoverview description.</paragraph><heading level="3">Document all top-level exports of modules</heading><paragraph>Use /** JSDoc */ comments to communicate information to the users of your code. Avoid merely restating the property or parameter name. You should also document all properties and methods (exported/public or not) whose purpose is not immediately obvious from their name, as judged by your reviewer.</paragraph><paragraph>Exception: Symbols that are only exported to be consumed by tooling, such as @NgModule classes, do not require comments.</paragraph><paragraph>JSDoc comments for classes should provide the reader with enough information to know how and when to use the class, as well as any additional considerations necessary to correctly use the class. Textual descriptions may be omitted on the constructor.</paragraph><paragraph>Method, parameter, and return descriptions may be omitted if they are obvious from the rest of the method's JSDoc or from the method name and type signature.</paragraph><paragraph>Method descriptions begin with a verb phrase that describes what the method does. This phrase is not an imperative sentence, but instead is written in the third person, as if there is an implied This method ... before it.</paragraph><paragraph>A parameter property is a constructor parameter that is prefixed by one of the modifiers private, protected, public, or readonly. A parameter property declares both a parameter and an instance property, and implicitly assigns into it. For example, constructor(private readonly foo: Foo), declares that the constructor takes a parameter foo, but also declares a private readonly property foo, and assigns the parameter into that property before executing the remainder of the constructor.</paragraph><paragraph>To document these fields, use JSDoc's @param annotation. Editors display the description on constructor calls and property accesses.</paragraph><code language="javascript">/** This class demonstrates how parameter properties are documented. */
class ParamProps {
  /**
   * @param percolator The percolator used for brewing.
   * @param beans The beans to brew.
   */
  constructor(
    private readonly percolator: Percolator,
    private readonly beans: CoffeeBean[]) {}
}
</code><code language="javascript">/** This class demonstrates how ordinary fields are documented. */
class OrdinaryClass {
  /** The bean that will be used in the next call to brew(). */
  nextBean: CoffeeBean;

  constructor(initialBean: CoffeeBean) {
    this.nextBean = initialBean;
  }
}
</code><heading level="3">JSDoc type annotations</heading><paragraph>JSDoc type annotations are redundant in TypeScript source code. Do not declare types in @param or @return blocks, do not write @implements, @enum, @private, @override etc. on code that uses the implements, enum, private, override etc. keywords.</paragraph><paragraph>For non-exported symbols, sometimes the name and type of the function or parameter is enough. Code will usually benefit from more documentation than just variable names though!</paragraph><list type="ul"><item>Avoid comments that just restate the parameter name and type, e.g. /** @param fooBarService The Bar service for the Foo application. */</item><item>Because of this rule, @param and @return lines are only required when they add information, and may otherwise be omitted. /** * POSTs the request to start coffee brewing. * @param amountLitres The amount to brew. Must fit the pot size! */ brew(amountLitres: number, logger: Logger) { // ... }</item></list><paragraph>Avoid comments that just restate the parameter name and type, e.g.</paragraph><code language="code">/** @param fooBarService The Bar service for the Foo application. */
</code><paragraph>Because of this rule, @param and @return lines are only required when they add information, and may otherwise be omitted.</paragraph><code language="javascript">/**
 * POSTs the request to start coffee brewing.
 * @param amountLitres The amount to brew. Must fit the pot size!
 */
brew(amountLitres: number, logger: Logger) {
  // ...
}
</code><paragraph>"Parameter name" comments should be used whenever the method name and parameter value do not sufficiently convey the meaning of the parameter.</paragraph><paragraph>Before adding these comments, consider refactoring the method to instead accept an interface and destructure it to greatly improve call-site readability.</paragraph><paragraph>Parameter name comments go before the parameter value, and include the parameter name and a = suffix:</paragraph><code language="code">someFunction(obviousParam, /* shouldRender= */ true, /* name= */ 'hello');
</code><paragraph>Existing code may use a legacy parameter name comment style, which places these comments ~after~ the parameter value and omits the =. Continuing to use this style within the file for consistency is acceptable.</paragraph><code language="code">someFunction(obviousParam, true /* shouldRender */, 'hello' /* name */);
</code><heading level="3">Place documentation prior to decorators</heading><paragraph>When a class, method, or property have both decorators like @Component and JsDoc, please make sure to write the JsDoc before the decorator.</paragraph><list type="ul"><item>Do not write JsDoc between the Decorator and the decorated statement. @Component({ selector: 'foo', template: 'bar', }) /** Component that prints "bar". */ export class FooComponent {}</item><item>Write the JsDoc block before the Decorator. /** Component that prints "bar". */ @Component({ selector: 'foo', template: 'bar', }) export class FooComponent {}</item></list><paragraph>Do not write JsDoc between the Decorator and the decorated statement.</paragraph><code language="javascript">@Component({
  selector: 'foo',
  template: 'bar',
})
/** Component that prints "bar". */
export class FooComponent {}
</code><paragraph>Write the JsDoc block before the Decorator.</paragraph><code language="javascript">/** Component that prints "bar". */
@Component({
  selector: 'foo',
  template: 'bar',
})
export class FooComponent {}
</code><heading level="2">Policies</heading><heading level="3">Consistency</heading><paragraph>For any style question that isn't settled definitively by this specification, do what the other code in the same file is already doing (be consistent). If that doesn't resolve the question, consider emulating the other files in the same directory.</paragraph><paragraph>Brand new files must use Google Style, regardless of the style choices of other files in the same package. When adding new code to a file that is not in Google Style, reformatting the existing code first is recommended, subject to the advice below. If this reformatting is not done, then new code should be as consistent as possible with existing code in the same file, but must not violate the style guide.</paragraph><heading level="4">Reformatting existing code</heading><paragraph>You will occasionally encounter files in the codebase that are not in proper Google Style. These may have come from an acquisition, or may have been written before Google Style took a position on some issue, or may be in non-Google Style for any other reason.</paragraph><paragraph>When updating the style of existing code, follow these guidelines.</paragraph><list type="ol"><item>It is not required to change all existing code to meet current style guidelines. Reformatting existing code is a trade-off between code churn and consistency. Style rules evolve over time and these kinds of tweaks to maintain compliance would create unnecessary churn. However, if significant changes are being made to a file it is expected that the file will be in Google Style.</item><item>Be careful not to allow opportunistic style fixes to muddle the focus of a CL. If you find yourself making a lot of style changes that aren't critical to the central focus of a CL, promote those changes to a separate CL.</item></list><heading level="3">Deprecation</heading><paragraph>Mark deprecated methods, classes or interfaces with an @deprecated JSDoc annotation. A deprecation comment must include simple, clear directions for people to fix their call sites.</paragraph><heading level="3">Generated code: mostly exempt</heading><paragraph>Source code generated by the build process is not required to be in Google Style. However, any generated identifiers that will be referenced from hand-written source code must follow the naming requirements. As a special exception, such identifiers are allowed to contain underscores, which may help to avoid conflicts with hand-written identifiers.</paragraph><heading level="4">Style guide goals</heading><paragraph>In general, engineers usually know best about what's needed in their code, so if there are multiple options and the choice is situation dependent, we should let decisions be made locally. So the default answer should be leave it out.</paragraph><paragraph>The following points are the exceptions, which are the reasons we have some global rules. Evaluate your style guide proposal against the following:</paragraph><list type="ol"><item>Code should avoid patterns that are known to cause problems, especially for users new to the language.</item><item>Code across projects should be consistent across irrelevant variations. When there are two options that are equivalent in a superficial way, we should consider choosing one just so we don't divergently evolve for no reason and avoid pointless debates in code reviews. Examples: The capitalization style of names. x as T syntax vs the equivalent <T>x syntax (disallowed). Array<[number, number]> vs [number, number][].</item><item>Code should be maintainable in the long term. Code usually lives longer than the original author works on it, and the TypeScript team must keep all of Google working into the future. Examples: We use software to automate changes to code, so code is autoformatted so it's easy for software to meet whitespace rules. We require a single set of compiler flags, so a given TS library can be written assuming a specific set of flags, and users can always safely use a shared library. Code must import the libraries it uses (strict deps) so that a refactor in a dependency doesn't change the dependencies of its users. We ask users to write tests. Without tests we cannot have confidence that changes that we make to the language, don't break users.</item><item>Code reviewers should be focused on improving the quality of the code, not enforcing arbitrary rules. If it's possible to implement your rule as an automated check that is often a good sign. This also supports principle 3. If it really just doesn't matter that much -- if it's an obscure corner of the language or if it avoids a bug that is unlikely to occur -- it's probably worth leaving out.</item></list><paragraph>Code should avoid patterns that are known to cause problems, especially for users new to the language.</paragraph><paragraph>Code across projects should be consistent across irrelevant variations.</paragraph><paragraph>When there are two options that are equivalent in a superficial way, we should consider choosing one just so we don't divergently evolve for no reason and avoid pointless debates in code reviews.</paragraph><paragraph>Examples:</paragraph><list type="ul"><item>The capitalization style of names.</item><item>x as T syntax vs the equivalent <T>x syntax (disallowed).</item><item>Array<[number, number]> vs [number, number][].</item></list><paragraph>Code should be maintainable in the long term.</paragraph><paragraph>Code usually lives longer than the original author works on it, and the TypeScript team must keep all of Google working into the future.</paragraph><paragraph>Examples:</paragraph><list type="ul"><item>We use software to automate changes to code, so code is autoformatted so it's easy for software to meet whitespace rules.</item><item>We require a single set of compiler flags, so a given TS library can be written assuming a specific set of flags, and users can always safely use a shared library.</item><item>Code must import the libraries it uses (strict deps) so that a refactor in a dependency doesn't change the dependencies of its users.</item><item>We ask users to write tests. Without tests we cannot have confidence that changes that we make to the language, don't break users.</item></list><paragraph>Code reviewers should be focused on improving the quality of the code, not enforcing arbitrary rules.</paragraph><paragraph>If it's possible to implement your rule as an automated check that is often a good sign. This also supports principle 3.</paragraph><paragraph>If it really just doesn't matter that much -- if it's an obscure corner of the language or if it avoids a bug that is unlikely to occur -- it's probably worth leaving out.</paragraph></content>
</page>
<page url="https://google.github.io/swift/">
<title>Swift Style Guide</title>
<content><paragraph>This style guide is based on Apple's excellent Swift standard library style and also incorporates feedback from usage across multiple Swift projects within Google. It is a living document and the basis upon which the formatter is implemented.</paragraph><heading level="2">Table of Contents</heading><heading level="2">Source File Basics</heading><heading level="3">File Names</heading><paragraph>All Swift source files end with the extension .swift.</paragraph><paragraph>In general, the name of a source file best describes the primary entity that it contains. A file that primarily contains a single type has the name of that type. A file that extends an existing type with protocol conformance is named with a combination of the type name and the protocol name, joined with a plus (+) sign. For more complex situations, exercise your best judgment.</paragraph><paragraph>For example,</paragraph><list type="ul"><item>A file containing a single type MyType is named MyType.swift.</item><item>A file containing a type MyType and some top-level helper functions is also named MyType.swift. (The top-level helpers are not the primary entity.)</item><item>A file containing a single extension to a type MyType that adds conformance to a protocol MyProtocol is named MyType+MyProtocol.swift.</item><item>A file containing multiple extensions to a type MyType that add conformances, nested types, or other functionality to a type can be named more generally, as long as it is prefixed with MyType+; for example, MyType+Additions.swift.</item><item>A file containing related declarations that are not otherwise scoped under a common type or namespace (such as a collection of global mathematical functions) can be named descriptively; for example, Math.swift.</item></list><heading level="3">File Encoding</heading><paragraph>Source files are encoded in UTF-8.</paragraph><heading level="3">Whitespace Characters</heading><paragraph>Aside from the line terminator, the Unicode horizontal space character (U+0020) is the only whitespace character that appears anywhere in a source file. The implications are:</paragraph><list type="ul"><item>All other whitespace characters in string and character literals are represented by their corresponding escape sequence.</item><item>Tab characters are not used for indentation.</item></list><heading level="3">Special Escape Sequences</heading><paragraph>For any character that has a special escape sequence (\t, \n, \r, \", \', \\, and \0), that sequence is used rather than the equivalent Unicode (e.g., \u{000a}) escape sequence.</paragraph><heading level="3">Invisible Characters and Modifiers</heading><paragraph>Invisible characters, such as the zero width space and other control characters that do not affect the graphical representation of a string, are always written as Unicode escape sequences.</paragraph><paragraph>Control characters, combining characters, and variation selectors that do affect the graphical representation of a string are not escaped when they are attached to a character or characters that they modify. If such a Unicode scalar is present in isolation or is otherwise not modifying another character in the same string, it is written as a Unicode escape sequence.</paragraph><paragraph>The strings below are well-formed because the umlauts and variation selectors associate with neighboring characters in the string. The second example is in fact composed of five Unicode scalars, but they are unescaped because the specific combination is rendered as a single character.</paragraph><code language="javascript">let size = "Übergröße"
let shrug = "🤷🏿‍️"
</code><paragraph>In the example below, the umlaut and variation selector are in strings by themselves, so they are escaped.</paragraph><code language="javascript">let diaeresis = "\u{0308}"
let skinToneType6 = "\u{1F3FF}"
</code><paragraph>If the umlaut were included in the string literally, it would combine with the preceding quotation mark, impairing readability. Likewise, while most systems may render a standalone skin tone modifier as a block graphic, the example below is still forbidden because it is a modifier that is not modifying a character in the same string.</paragraph><code language="javascript">let diaeresis = "̈"
let skinToneType6 = "🏿"
</code><heading level="3">String Literals</heading><paragraph>Unicode escape sequences (\u{????}) and literal code points (for example, Ü) outside the 7-bit ASCII range are never mixed in the same string.</paragraph><paragraph>More specifically, string literals are either:</paragraph><list type="ul"><item>composed of a combination of Unicode code points written literally and/or single character escape sequences (such as \t, but not \u{????}), or</item><item>composed of 7-bit ASCII with any number of Unicode escape sequences and/or other escape sequences.</item></list><paragraph>The following example is correct because \n is allowed to be present among other Unicode code points.</paragraph><paragraph>The following example is allowed because it follows the rules above, but it is not preferred because the text is harder to read and understand compared to the string above.</paragraph><code language="javascript">let size = "\u{00DC}bergr\u{00F6}\u{00DF}e\n"
</code><paragraph>The example below is forbidden because it mixes code points outside the 7-bit ASCII range in both literal form and in escaped form.</paragraph><code language="javascript">let size = "Übergr\u{00F6}\u{00DF}e\n"
</code><paragraph>Aside: Never make your code less readable simply out of fear that some programs might not handle non-ASCII characters properly. If that should happen, those programs are broken and must be fixed.</paragraph><heading level="2">Source File Structure</heading><paragraph>Comments describing the contents of a source file are optional. They are discouraged for files that contain only a single abstraction (such as a class declaration)—in those cases, the documentation comment on the abstraction itself is sufficient and a file comment is only present if it provides additional useful information. File comments are allowed for files that contain multiple abstractions in order to document that grouping as a whole.</paragraph><heading level="3">Import Statements</heading><paragraph>A source file imports exactly the top-level modules that it needs; nothing more and nothing less. If a source file uses definitions from both UIKit and Foundation, it imports both explicitly; it does not rely on the fact that some Apple frameworks transitively import others as an implementation detail.</paragraph><paragraph>Imports of whole modules are preferred to imports of individual declarations or submodules.</paragraph><paragraph>There are a number of reasons to avoid importing individual members:</paragraph><list type="ul"><item>There is no automated tooling to resolve/organize imports.</item><item>Existing automated tooling (such as Xcode's migrator) are less likely to work well on code that imports individual members because they are considered corner cases.</item><item>The prevailing style in Swift (based on official examples and community code) is to import entire modules.</item></list><paragraph>Imports of individual declarations are permitted when importing the whole module would otherwise pollute the global namespace with top-level definitions (such as C interfaces). Use your best judgment in these situations.</paragraph><paragraph>Imports of submodules are permitted if the submodule exports functionality that is not available when importing the top-level module. For example, UIKit.UIGestureRecognizerSubclass must be imported explicitly to expose the methods that allow client code to subclass UIGestureRecognizer—those are not visible by importing UIKit alone.</paragraph><paragraph>Import statements are not line-wrapped.</paragraph><paragraph>Import statements are the first non-comment tokens in a source file. They are grouped in the following fashion, with the imports in each group ordered lexicographically and with exactly one blank line between each group:</paragraph><list type="ol"><item>Module/submodule imports not under test</item><item>Individual declaration imports (class, enum, func, struct, var)</item><item>Modules imported with @testable (only present in test sources)</item></list><code language="python">import CoreLocation
import MyThirdPartyModule
import SpriteKit
import UIKit

import func Darwin.C.isatty

@testable import MyModuleUnderTest
</code><heading level="3">Type, Variable, and Function Declarations</heading><paragraph>In general, most source files contain only one top-level type, especially when the type declaration is large. Exceptions are allowed when it makes sense to include multiple related types in a single file. For example,</paragraph><list type="ul"><item>A class and its delegate protocol may be defined in the same file.</item><item>A type and its small related helper types may be defined in the same file. This can be useful when using fileprivate to restrict certain functionality of the type and/or its helpers to only that file and not the rest of the module.</item></list><paragraph>The order of types, variables, and functions in a source file, and the order of the members of those types, can have a great effect on readability. However, there is no single correct recipe for how to do it; different files and different types may order their contents in different ways.</paragraph><paragraph>What is important is that each file and type uses some logical order, which its maintainer could explain if asked. For example, new methods are not just habitually added to the end of the type, as that would yield "chronological by date added" ordering, which is not a logical ordering.</paragraph><paragraph>When deciding on the logical order of members, it can be helpful for readers and future writers (including yourself) to use // MARK: comments to provide descriptions for that grouping. These comments are also interpreted by Xcode and provide bookmarks in the source window's navigation bar. (Likewise, // MARK: - , written with a hyphen before the description, causes Xcode to insert a divider before the menu item.) For example,</paragraph><code language="python">class MovieRatingViewController: UITableViewController {

  // MARK: - View controller lifecycle methods

  override func viewDidLoad() {
    // ...
  }

  override func viewWillAppear(_ animated: Bool) {
    // ...
  }

  // MARK: - Movie rating manipulation methods

  @objc private func ratingStarWasTapped(_ sender: UIButton?) {
    // ...
  }

  @objc private func criticReviewWasTapped(_ sender: UIButton?) {
    // ...
  }
}
</code><heading level="3">Overloaded Declarations</heading><paragraph>When a type has multiple initializers or subscripts, or a file/type has multiple functions with the same base name (though perhaps with different argument labels), and when these overloads appear in the same type or extension scope, they appear sequentially with no other code in between.</paragraph><heading level="3">Extensions</heading><paragraph>Extensions can be used to organize functionality of a type across multiple "units." As with member order, the organizational structure/grouping you choose can have a great effect on readability; you must use some logical organizational structure that you could explain to a reviewer if asked.</paragraph><heading level="2">General Formatting</heading><heading level="3">Column Limit</heading><paragraph>Swift code has a column limit of 100 characters. Except as noted below, any line that would exceed this limit must be line-wrapped as described in Line-Wrapping.</paragraph><paragraph>Exceptions:</paragraph><list type="ol"><item>Lines where obeying the column limit is not possible without breaking a meaningful unit of text that should not be broken (for example, a long URL in a comment).</item><item>import statements.</item><item>Code generated by another tool.</item></list><heading level="3">Braces</heading><paragraph>In general, braces follow Kernighan and Ritchie (K&R) style for non-empty blocks with exceptions for Swift-specific constructs and rules:</paragraph><list type="ul"><item>There is no line break before the opening brace ({), unless required by application of the rules in Line-Wrapping.</item><item>There is a line break after the opening brace ({), except in closures, where the signature of the closure is placed on the same line as the curly brace, if it fits, and a line break follows the in keyword. where it may be omitted as described in One Statement Per Line. empty blocks may be written as {}.</item><item>There is a line break before the closing brace (}), except where it may be omitted as described in One Statement Per Line, or it completes an empty block.</item><item>There is a line break after the closing brace (}), if and only if that brace terminates a statement or the body of a declaration. For example, an else block is written } else { with both braces on the same line.</item></list><list type="ul"><item>in closures, where the signature of the closure is placed on the same line as the curly brace, if it fits, and a line break follows the in keyword.</item><item>where it may be omitted as described in One Statement Per Line.</item><item>empty blocks may be written as {}.</item></list><heading level="3">Semicolons</heading><paragraph>Semicolons (;) are not used, either to terminate or separate statements.</paragraph><paragraph>In other words, the only location where a semicolon may appear is inside a string literal or a comment.</paragraph><code language="javascript">func printSum(_ a: Int, _ b: Int) {
  let sum = a + b
  print(sum)
}
</code><code language="javascript">func printSum(_ a: Int, _ b: Int) {
  let sum = a + b;
  print(sum);
}
</code><heading level="3">One Statement Per Line</heading><paragraph>There is at most one statement per line, and each statement is followed by a line break, except when the line ends with a block that also contains zero or one statements.</paragraph><code language="javascript">guard let value = value else { return 0 }

defer { file.close() }

switch someEnum {
case .first: return 5
case .second: return 10
case .third: return 20
}

let squares = numbers.map { $0 * $0 }

var someProperty: Int {
  get { return otherObject.property }
  set { otherObject.property = newValue }
}

var someProperty: Int { return otherObject.somethingElse() }

required init?(coder aDecoder: NSCoder) { fatalError("no coder") }
</code><paragraph>Wrapping the body of a single-statement block onto its own line is always allowed. Exercise best judgment when deciding whether to place a conditional statement and its body on the same line. For example, single line conditionals work well for early-return and basic cleanup tasks, but less so when the body contains a function call with significant logic. When in doubt, write it as a multi-line statement.</paragraph><heading level="3">Line-Wrapping</heading><paragraph>Terminology note: Line-wrapping is the activity of dividing code into multiple lines that might otherwise legally occupy a single line.</paragraph><paragraph>For the purposes of Google Swift style, many declarations (such as type declarations and function declarations) and other expressions (like function calls) can be partitioned into breakable units that are separated by unbreakable delimiting token sequences.</paragraph><paragraph>As an example, consider the following complex function declaration, which needs to be line-wrapped:</paragraph><code language="javascript">public func index<Elements: Collection, Element>(of element: Element, in collection: Elements) -> Elements.Index? where Elements.Element == Element, Element: Equatable {
  // ...
}
</code><paragraph>This declaration is split as follows (scroll horizontally if necessary to see the full example). Unbreakable token sequences are indicated in orange; breakable sequences are indicated in blue.</paragraph><code language="javascript">
public func index<Elements: Collection, Element>(of element: Element, in collection: Elements) ->Elements.Index?whereElements.Element == Element, Element: Equatable{
  // ...
}
</code><list type="ol"><item>The unbreakable token sequence up through the open angle bracket (<) that begins the generic argument list.</item><item>The breakable list of generic arguments.</item><item>The unbreakable token sequence (>() that separates the generic arguments from the formal arguments.</item><item>The breakable comma-delimited list of formal arguments.</item><item>The unbreakable token-sequence from the closing parenthesis ()) up through the arrow (->) that precedes the return type.</item><item>The breakable return type.</item><item>The unbreakable where keyword that begins the generic constraints list.</item><item>The breakable comma-delimited list of generic constraints.</item></list><paragraph>Using these concepts, the cardinal rules of Google Swift style for line-wrapping are:</paragraph><list type="ol"><item>If the entire declaration, statement, or expression fits on one line, then do that.</item><item>Comma-delimited lists are only laid out in one direction: horizontally or vertically. In other words, all elements must fit on the same line, or each element must be on its own line. A horizontally-oriented list does not contain any line breaks, even before the first element or after the last element. Except in control flow statements, a vertically-oriented list contains a line break before the first element and after each element.</item><item>A continuation line starting with an unbreakable token sequence is indented at the same level as the original line.</item><item>A continuation line that is part of a vertically-oriented comma-delimited list is indented exactly +2 from the original line.</item><item>When an open curly brace ({) follows a line-wrapped declaration or expression, it is on the same line as the final continuation line unless that line is indented at +2 from the original line. In that case, the brace is placed on its own line, to avoid the continuation lines from blending visually with the body of the subsequent block. public func index<Elements: Collection, Element>( of element: Element, in collection: Elements ) -> Elements.Index? where Elements.Element == Element, Element: Equatable { // GOOD. for current in elements { // ... } } public func index<Elements: Collection, Element>( of element: Element, in collection: Elements ) -> Elements.Index? where Elements.Element == Element, Element: Equatable { // AVOID. for current in elements { // ... } }</item></list><paragraph>When an open curly brace ({) follows a line-wrapped declaration or expression, it is on the same line as the final continuation line unless that line is indented at +2 from the original line. In that case, the brace is placed on its own line, to avoid the continuation lines from blending visually with the body of the subsequent block.</paragraph><code language="javascript">public func index<Elements: Collection, Element>(
  of element: Element,
  in collection: Elements
) -> Elements.Index?
where
  Elements.Element == Element,
  Element: Equatable
{  // GOOD.
  for current in elements {
    // ...
  }
}
</code><code language="javascript">public func index<Elements: Collection, Element>(
  of element: Element,
  in collection: Elements
) -> Elements.Index?
where
  Elements.Element == Element,
  Element: Equatable {  // AVOID.
  for current in elements {
    // ...
  }
}
</code><paragraph>For declarations that contain a where clause followed by generic constraints, additional rules apply:</paragraph><list type="ol"><item>If the generic constraint list exceeds the column limit when placed on the same line as the return type, then a line break is first inserted before the where keyword and the where keyword is indented at the same level as the original line.</item><item>If the generic constraint list still exceeds the column limit after inserting the line break above, then the constraint list is oriented vertically with a line break after the where keyword and a line break after the final constraint.</item></list><paragraph>Concrete examples of this are shown in the relevant subsections below.</paragraph><paragraph>This line-wrapping style ensures that the different parts of a declaration are quickly and easily identifiable to the reader by using indentation and line breaks, while also preserving the same indentation level for those parts throughout the file. Specifically, it prevents the zig-zag effect that would be present if the arguments are indented based on opening parentheses, as is common in other languages:</paragraph><code language="javascript">public func index<Elements: Collection, Element>(of element: Element,  // AVOID.
                                                 in collection: Elements) -> Elements.Index?
    where Elements.Element == Element, Element: Equatable {
  doSomething()
}
</code><heading level="4">Function Declarations</heading><code language="javascript">
modifiers func name(formal arguments){

modifiers func name(formal arguments) ->result{

modifiers func name<generic arguments>(formal arguments) throws ->result{

modifiers func name<generic arguments>(formal arguments) throws ->resultwheregeneric constraints{
</code><paragraph>Applying the rules above from left to right gives us the following line-wrapping:</paragraph><code language="javascript">public func index<Elements: Collection, Element>(
  of element: Element,
  in collection: Elements
) -> Elements.Index? where Elements.Element == Element, Element: Equatable {
  for current in elements {
    // ...
  }
}
</code><paragraph>Function declarations in protocols that are terminated with a closing parenthesis ()) may place the parenthesis on the same line as the final argument or on its own line.</paragraph><code language="javascript">public protocol ContrivedExampleDelegate {
  func contrivedExample(
    _ contrivedExample: ContrivedExample,
    willDoSomethingTo someValue: SomeValue)
}

public protocol ContrivedExampleDelegate {
  func contrivedExample(
    _ contrivedExample: ContrivedExample,
    willDoSomethingTo someValue: SomeValue
  )
}
</code><paragraph>If types are complex and/or deeply nested, individual elements in the arguments/constraints lists and/or the return type may also need to be wrapped. In these rare cases, the same line-wrapping rules apply to those parts as apply to the declaration itself.</paragraph><code language="javascript">public func performanceTrackingIndex<Elements: Collection, Element>(
  of element: Element,
  in collection: Elements
) -> (
  Element.Index?,
  PerformanceTrackingIndexStatistics.Timings,
  PerformanceTrackingIndexStatistics.SpaceUsed
) {
  // ...
}
</code><paragraph>However, typealiases or some other means are often a better way to simplify complex declarations whenever possible.</paragraph><heading level="4">Type and Extension Declarations</heading><paragraph>The examples below apply equally to class, struct, enum, extension, and protocol (with the obvious exception that all but the first do not have superclasses in their inheritance list, but they are otherwise structurally similar).</paragraph><code language="python">
modifiers class Name{

modifiers class Name:superclass and protocols{

modifiers class Name<generic arguments>:superclass and protocols{

modifiers class Name<generic arguments>:superclass and protocolswheregeneric constraints{
</code><code language="python">class MyClass:
  MySuperclass,
  MyProtocol,
  SomeoneElsesProtocol,
  SomeFrameworkProtocol
{
  // ...
}

class MyContainer<Element>:
  MyContainerSuperclass,
  MyContainerProtocol,
  SomeoneElsesContainerProtocol,
  SomeFrameworkContainerProtocol
{
  // ...
}

class MyContainer<BaseCollection>:
  MyContainerSuperclass,
  MyContainerProtocol,
  SomeoneElsesContainerProtocol,
  SomeFrameworkContainerProtocol
where BaseCollection: Collection {
  // ...
}

class MyContainer<BaseCollection>:
  MyContainerSuperclass,
  MyContainerProtocol,
  SomeoneElsesContainerProtocol,
  SomeFrameworkContainerProtocol
where
  BaseCollection: Collection,
  BaseCollection.Element: Equatable,
  BaseCollection.Element: SomeOtherProtocolOnlyUsedToForceLineWrapping
{
  // ...
}
</code><heading level="4">Function Calls</heading><paragraph>When a function call is line-wrapped, each argument is written on its own line, indented +2 from the original line.</paragraph><paragraph>As with function declarations, if the function call terminates its enclosing statement and ends with a closing parenthesis ()) (that is, it has no trailing closure), then the parenthesis may be placed either on the same line as the final argument or on its own line.</paragraph><code language="javascript">let index = index(
  of: veryLongElementVariableName,
  in: aCollectionOfElementsThatAlsoHappensToHaveALongName)

let index = index(
  of: veryLongElementVariableName,
  in: aCollectionOfElementsThatAlsoHappensToHaveALongName
)
</code><paragraph>If the function call ends with a trailing closure and the closure's signature must be wrapped, then place it on its own line and wrap the argument list in parentheses to distinguish it from the body of the closure below it.</paragraph><code language="javascript">someAsynchronousAction.execute(withDelay: howManySeconds, context: actionContext) {
  (context, completion) in
  doSomething(withContext: context)
  completion()
}
</code><heading level="4">Control Flow Statements</heading><paragraph>When a control flow statement (such as if, guard, while, or for) is wrapped, the first continuation line is indented to the same position as the token following the control flow keyword. Additional continuation lines are indented at that same position if they are syntactically parallel elements, or in +2 increments from that position if they are syntactically nested.</paragraph><paragraph>The open brace ({) preceding the body of the control flow statement can either be placed on the same line as the last continuation line or on the next line, at the same indentation level as the beginning of the statement. For guard statements, the else { must be kept together, either on the same line or on the next line.</paragraph><code language="javascript">if aBooleanValueReturnedByAVeryLongOptionalThing() &&
   aDifferentBooleanValueReturnedByAVeryLongOptionalThing() &&
   yetAnotherBooleanValueThatContributesToTheWrapping() {
  doSomething()
}

if aBooleanValueReturnedByAVeryLongOptionalThing() &&
   aDifferentBooleanValueReturnedByAVeryLongOptionalThing() &&
   yetAnotherBooleanValueThatContributesToTheWrapping()
{
  doSomething()
}

if let value = aValueReturnedByAVeryLongOptionalThing(),
   let value2 = aDifferentValueReturnedByAVeryLongOptionalThing() {
  doSomething()
}

if let value = aValueReturnedByAVeryLongOptionalThing(),
   let value2 = aDifferentValueReturnedByAVeryLongOptionalThingThatForcesTheBraceToBeWrapped()
{
  doSomething()
}

guard let value = aValueReturnedByAVeryLongOptionalThing(),
      let value2 = aDifferentValueReturnedByAVeryLongOptionalThing() else {
  doSomething()
}

guard let value = aValueReturnedByAVeryLongOptionalThing(),
      let value2 = aDifferentValueReturnedByAVeryLongOptionalThing()
else {
  doSomething()
}

for element in collection
    where element.happensToHaveAVeryLongPropertyNameThatYouNeedToCheck {
  doSomething()
}
</code><heading level="4">Other Expressions</heading><paragraph>When line-wrapping other expressions that are not function calls (as described above), the second line (the one immediately following the first break) is indented exactly +2 from the original line.</paragraph><paragraph>When there are multiple continuation lines, indentation may be varied in increments of +2 as needed. In general, two continuation lines use the same indentation level if and only if they begin with syntactically parallel elements. However, if there are many continuation lines caused by long wrapped expressions, consider splitting them into multiple statements using temporary variables when possible.</paragraph><code language="javascript">let result = anExpression + thatIsMadeUpOf * aLargeNumber +
  ofTerms / andTherefore % mustBeWrapped + (
    andWeWill - keepMakingItLonger * soThatWeHave / aContrivedExample)
</code><code language="javascript">let result = anExpression + thatIsMadeUpOf * aLargeNumber +
    ofTerms / andTherefore % mustBeWrapped + (
        andWeWill - keepMakingItLonger * soThatWeHave / aContrivedExample)
</code><heading level="3">Horizontal Whitespace</heading><paragraph>Terminology note: In this section, horizontal whitespace refers to interior space. These rules are never interpreted as requiring or forbidding additional space at the start of a line.</paragraph><paragraph>Beyond where required by the language or other style rules, and apart from literals and comments, a single Unicode space also appears in the following places only:</paragraph><list type="ol"><item>Separating any reserved word starting a conditional or switch statement (such as if, guard, while, or switch) from the expression that follows it if that expression starts with an open parenthesis ((). if (x == 0 && y == 0) || z == 0 { // ... } if(x == 0 && y == 0) || z == 0 { // ... }</item><item>Before any closing curly brace (}) that follows code on the same line, before any open curly brace ({), and after any open curly brace ({) that is followed by code on the same line. let nonNegativeCubes = numbers.map { $0 * $0 * $0 }.filter { $0 >= 0 } let nonNegativeCubes = numbers.map { $0 * $0 * $0 } .filter { $0 >= 0 } let nonNegativeCubes = numbers.map{$0 * $0 * $0}.filter{$0 >= 0}</item><item>On both sides of any binary or ternary operator, including the "operator-like" symbols described below, with exceptions noted at the end: The = sign used in assignment, initialization of variables/properties, and default arguments in functions. var x = 5 func sum(_ numbers: [Int], initialValue: Int = 0) { // ... } var x=5 func sum(_ numbers: [Int], initialValue: Int=0) { // ... } The ampersand (&) in a protocol composition type. func sayHappyBirthday(to person: NameProviding & AgeProviding) { // ... } func sayHappyBirthday(to person: NameProviding&AgeProviding) { // ... } The operator symbol in a function declaring/implementing that operator. static func == (lhs: MyType, rhs: MyType) -> Bool { // ... } static func ==(lhs: MyType, rhs: MyType) -> Bool { // ... } The arrow (->) preceding the return type of a function. func sum(_ numbers: [Int]) -> Int { // ... } func sum(_ numbers: [Int])->Int { // ... } Exception: There is no space on either side of the dot (.) used to reference value and type members. let width = view.bounds.width let width = view . bounds . width Exception: There is no space on either side of the ..< or ... operators used in range expressions. for number in 1...5 { // ... } let substring = string[index..<string.endIndex] for number in 1 ... 5 { // ... } let substring = string[index ..< string.endIndex]</item><item>After, but not before, the comma (,) in parameter lists and in tuple/array/dictionary literals. let numbers = [1,2,3] let numbers = [1 ,2 ,3] let numbers = [1 , 2 , 3]</item><item>After, but not before, the colon (:) in Superclass/protocol conformance lists and generic constraints. struct HashTable: Collection { // ... } struct AnyEquatable<Wrapped: Equatable>: Equatable { // ... } struct HashTable : Collection { // ... } struct AnyEquatable<Wrapped : Equatable> : Equatable { // ... } Function argument labels and tuple element labels. let tuple: (x: Int, y: Int) func sum(_ numbers: [Int]) { // ... } let tuple: (x:Int, y:Int) let tuple: (x : Int, y : Int) func sum(_ numbers:[Int]) { // ... } func sum(_ numbers : [Int]) { // ... } Variable/property declarations with explicit types. let number:Int = 5 let number : Int = 5 Shorthand dictionary type names. var nameAgeMap: [String: Int] = [] var nameAgeMap: [String:Int] = [] var nameAgeMap: [String : Int] = [] Dictionary literals. let nameAgeMap = ["Ed": 40, "Timmy": 9] let nameAgeMap = ["Ed":40, "Timmy":9] let nameAgeMap = ["Ed" : 40, "Timmy" : 9]</item><item>At least two spaces before and exactly one space after the double slash (//) that begins an end-of-line comment. let initialFactor = 2 // Warm up the modulator. let initialFactor = 2 // Warm up the modulator.</item><item>Outside, but not inside, the brackets of an array or dictionary literals and the parentheses of a tuple literal. let numbers = [ 1, 2, 3 ]</item></list><paragraph>Separating any reserved word starting a conditional or switch statement (such as if, guard, while, or switch) from the expression that follows it if that expression starts with an open parenthesis (().</paragraph><code language="javascript">if (x == 0 && y == 0) || z == 0 {
  // ...
}
</code><code language="javascript">if(x == 0 && y == 0) || z == 0 {
  // ...
}
</code><paragraph>Before any closing curly brace (}) that follows code on the same line, before any open curly brace ({), and after any open curly brace ({) that is followed by code on the same line.</paragraph><code language="javascript">let nonNegativeCubes = numbers.map { $0 * $0 * $0 }.filter { $0 >= 0 }
</code><code language="javascript">let nonNegativeCubes = numbers.map { $0 * $0 * $0 } .filter { $0 >= 0 }
let nonNegativeCubes = numbers.map{$0 * $0 * $0}.filter{$0 >= 0}
</code><paragraph>On both sides of any binary or ternary operator, including the "operator-like" symbols described below, with exceptions noted at the end:</paragraph><list type="ol"><item>The = sign used in assignment, initialization of variables/properties, and default arguments in functions. var x = 5 func sum(_ numbers: [Int], initialValue: Int = 0) { // ... } var x=5 func sum(_ numbers: [Int], initialValue: Int=0) { // ... }</item><item>The ampersand (&) in a protocol composition type. func sayHappyBirthday(to person: NameProviding & AgeProviding) { // ... } func sayHappyBirthday(to person: NameProviding&AgeProviding) { // ... }</item><item>The operator symbol in a function declaring/implementing that operator. static func == (lhs: MyType, rhs: MyType) -> Bool { // ... } static func ==(lhs: MyType, rhs: MyType) -> Bool { // ... }</item><item>The arrow (->) preceding the return type of a function. func sum(_ numbers: [Int]) -> Int { // ... } func sum(_ numbers: [Int])->Int { // ... }</item><item>Exception: There is no space on either side of the dot (.) used to reference value and type members. let width = view.bounds.width let width = view . bounds . width</item><item>Exception: There is no space on either side of the ..< or ... operators used in range expressions. for number in 1...5 { // ... } let substring = string[index..<string.endIndex] for number in 1 ... 5 { // ... } let substring = string[index ..< string.endIndex]</item></list><paragraph>The = sign used in assignment, initialization of variables/properties, and default arguments in functions.</paragraph><code language="javascript">var x = 5

func sum(_ numbers: [Int], initialValue: Int = 0) {
  // ...
}
</code><code language="javascript">var x=5

func sum(_ numbers: [Int], initialValue: Int=0) {
  // ...
}
</code><paragraph>The ampersand (&) in a protocol composition type.</paragraph><code language="javascript">func sayHappyBirthday(to person: NameProviding & AgeProviding) {
  // ...
}
</code><code language="javascript">func sayHappyBirthday(to person: NameProviding&AgeProviding) {
  // ...
}
</code><paragraph>The operator symbol in a function declaring/implementing that operator.</paragraph><code language="javascript">static func == (lhs: MyType, rhs: MyType) -> Bool {
  // ...
}
</code><code language="javascript">static func ==(lhs: MyType, rhs: MyType) -> Bool {
  // ...
}
</code><paragraph>The arrow (->) preceding the return type of a function.</paragraph><code language="javascript">func sum(_ numbers: [Int]) -> Int {
  // ...
}
</code><code language="javascript">func sum(_ numbers: [Int])->Int {
  // ...
}
</code><paragraph>Exception: There is no space on either side of the dot (.) used to reference value and type members.</paragraph><code language="javascript">let width = view.bounds.width
</code><code language="javascript">let width = view . bounds . width
</code><paragraph>Exception: There is no space on either side of the ..< or ... operators used in range expressions.</paragraph><code language="javascript">for number in 1...5 {
  // ...
}

let substring = string[index..<string.endIndex]
</code><code language="javascript">for number in 1 ... 5 {
  // ...
}

let substring = string[index ..< string.endIndex]
</code><paragraph>After, but not before, the comma (,) in parameter lists and in tuple/array/dictionary literals.</paragraph><code language="javascript">let numbers = [1,2,3]
let numbers = [1 ,2 ,3]
let numbers = [1 , 2 , 3]
</code><paragraph>After, but not before, the colon (:) in</paragraph><list type="ol"><item>Superclass/protocol conformance lists and generic constraints. struct HashTable: Collection { // ... } struct AnyEquatable<Wrapped: Equatable>: Equatable { // ... } struct HashTable : Collection { // ... } struct AnyEquatable<Wrapped : Equatable> : Equatable { // ... }</item><item>Function argument labels and tuple element labels. let tuple: (x: Int, y: Int) func sum(_ numbers: [Int]) { // ... } let tuple: (x:Int, y:Int) let tuple: (x : Int, y : Int) func sum(_ numbers:[Int]) { // ... } func sum(_ numbers : [Int]) { // ... }</item><item>Variable/property declarations with explicit types. let number:Int = 5 let number : Int = 5</item><item>Shorthand dictionary type names. var nameAgeMap: [String: Int] = [] var nameAgeMap: [String:Int] = [] var nameAgeMap: [String : Int] = []</item><item>Dictionary literals. let nameAgeMap = ["Ed": 40, "Timmy": 9] let nameAgeMap = ["Ed":40, "Timmy":9] let nameAgeMap = ["Ed" : 40, "Timmy" : 9]</item></list><paragraph>Superclass/protocol conformance lists and generic constraints.</paragraph><code language="javascript">struct HashTable: Collection {
  // ...
}

struct AnyEquatable<Wrapped: Equatable>: Equatable {
  // ...
}
</code><code language="javascript">struct HashTable : Collection {
  // ...
}

struct AnyEquatable<Wrapped : Equatable> : Equatable {
  // ...
}
</code><paragraph>Function argument labels and tuple element labels.</paragraph><code language="javascript">let tuple: (x: Int, y: Int)

func sum(_ numbers: [Int]) {
  // ...
}
</code><code language="javascript">let tuple: (x:Int, y:Int)
let tuple: (x : Int, y : Int)

func sum(_ numbers:[Int]) {
  // ...
}

func sum(_ numbers : [Int]) {
  // ...
}
</code><paragraph>Variable/property declarations with explicit types.</paragraph><code language="javascript">let number:Int = 5
let number : Int = 5
</code><paragraph>Shorthand dictionary type names.</paragraph><code language="javascript">var nameAgeMap: [String: Int] = []
</code><code language="javascript">var nameAgeMap: [String:Int] = []
var nameAgeMap: [String : Int] = []
</code><paragraph>Dictionary literals.</paragraph><code language="javascript">let nameAgeMap = ["Ed": 40, "Timmy": 9]
</code><code language="javascript">let nameAgeMap = ["Ed":40, "Timmy":9]
let nameAgeMap = ["Ed" : 40, "Timmy" : 9]
</code><paragraph>At least two spaces before and exactly one space after the double slash (//) that begins an end-of-line comment.</paragraph><code language="javascript">let initialFactor = 2  // Warm up the modulator.
</code><code language="javascript">let initialFactor = 2 //    Warm up the modulator.
</code><paragraph>Outside, but not inside, the brackets of an array or dictionary literals and the parentheses of a tuple literal.</paragraph><code language="javascript">let numbers = [ 1, 2, 3 ]
</code><heading level="3">Horizontal Alignment</heading><paragraph>Terminology note: Horizontal alignment is the practice of adding a variable number of additional spaces in your code with the goal of making certain tokens appear directly below certain other tokens on previous lines.</paragraph><paragraph>Horizontal alignment is forbidden except when writing obviously tabular data where omitting the alignment would be harmful to readability. In other cases (for example, lining up the types of stored property declarations in a struct or class), horizontal alignment is an invitation for maintenance problems if a new member is introduced that requires every other member to be realigned.</paragraph><code language="javascript">struct DataPoint {
  var value: Int
  var primaryColor: UIColor
}
</code><code language="javascript">struct DataPoint {
  var value:        Int
  var primaryColor: UIColor
}
</code><heading level="3">Vertical Whitespace</heading><paragraph>A single blank line appears in the following locations:</paragraph><list type="ol"><item>Between consecutive members of a type: properties, initializers, methods, enum cases, and nested types, except that: A blank line is optional between two consecutive stored properties or two enum cases whose declarations fit entirely on a single line. Such blank lines can be used to create logical groupings of these declarations. A blank line is optional between two extremely closely related properties that do not otherwise meet the criterion above; for example, a private stored property and a related public computed property.</item><item>Only as needed between statements to organize code into logical subsections.</item><item>Optionally before the first member or after the last member of a type (neither is encouraged nor discouraged).</item><item>Anywhere explicitly required by other sections of this document.</item></list><paragraph>Between consecutive members of a type: properties, initializers, methods, enum cases, and nested types, except that:</paragraph><list type="ol"><item>A blank line is optional between two consecutive stored properties or two enum cases whose declarations fit entirely on a single line. Such blank lines can be used to create logical groupings of these declarations.</item><item>A blank line is optional between two extremely closely related properties that do not otherwise meet the criterion above; for example, a private stored property and a related public computed property.</item></list><paragraph>Multiple blank lines are permitted, but never required (nor encouraged). If you do use multiple consecutive blank lines, do so consistently throughout your code base.</paragraph><heading level="3">Parentheses</heading><paragraph>Parentheses are not used around the top-most expression that follows an if, guard, while, or switch keyword.</paragraph><code language="javascript">if x == 0 {
  print("x is zero")
}

if (x == 0 || y == 1) && z == 2 {
  print("...")
}
</code><code language="javascript">if (x == 0) {
  print("x is zero")
}

if ((x == 0 || y == 1) && z == 2) {
  print("...")
}
</code><paragraph>Optional grouping parentheses are omitted only when the author and the reviewer agree that there is no reasonable chance that the code will be misinterpreted without them, nor that they would have made the code easier to read. It is not reasonable to assume that every reader has the entire Swift operator precedence table memorized.</paragraph><heading level="2">Formatting Specific Constructs</heading><paragraph>Non-documentation comments always use the double-slash format (//), never the C-style block format (/* ... */).</paragraph><heading level="3">Properties</heading><paragraph>Local variables are declared close to the point at which they are first used (within reason) to minimize their scope.</paragraph><paragraph>With the exception of tuple destructuring, every let or var statement (whether a property or a local variable) declares exactly one variable.</paragraph><code language="javascript">var a = 5
var b = 10

let (quotient, remainder) = divide(100, 9)
</code><heading level="3">Switch Statements</heading><paragraph>Case statements are indented at the same level as the switch statement to which they belong; the statements inside the case blocks are then indented +2 spaces from that level.</paragraph><code language="javascript">switch order {
case .ascending:
  print("Ascending")
case .descending:
  print("Descending")
case .same:
  print("Same")
}
</code><code language="javascript">switch order {
  case .ascending:
    print("Ascending")
  case .descending:
    print("Descending")
  case .same:
    print("Same")
}
</code><code language="javascript">switch order {
case .ascending:
print("Ascending")
case .descending:
print("Descending")
case .same:
print("Same")
}
</code><heading level="3">Enum Cases</heading><paragraph>In general, there is only one case per line in an enum. The comma-delimited form may be used only when none of the cases have associated values or raw values, all cases fit on a single line, and the cases do not need further documentation because their meanings are obvious from their names.</paragraph><code language="javascript">public enum Token {
  case comma
  case semicolon
  case identifier
}

public enum Token {
  case comma, semicolon, identifier
}

public enum Token {
  case comma
  case semicolon
  case identifier(String)
}
</code><code language="javascript">public enum Token {
  case comma, semicolon, identifier(String)
}
</code><paragraph>When all cases of an enum must be indirect, the enum itself is declared indirect and the keyword is omitted on the individual cases.</paragraph><code language="javascript">public indirect enum DependencyGraphNode {
  case userDefined(dependencies: [DependencyGraphNode])
  case synthesized(dependencies: [DependencyGraphNode])
}
</code><code language="javascript">public enum DependencyGraphNode {
  indirect case userDefined(dependencies: [DependencyGraphNode])
  indirect case synthesized(dependencies: [DependencyGraphNode])
}
</code><paragraph>When an enum case does not have associated values, empty parentheses are never present.</paragraph><code language="javascript">public enum BinaryTree<Element> {
  indirect case node(element: Element, left: BinaryTree, right: BinaryTree)
  case empty  // GOOD.
}
</code><code language="javascript">public enum BinaryTree<Element> {
  indirect case node(element: Element, left: BinaryTree, right: BinaryTree)
  case empty()  // AVOID.
}
</code><paragraph>The cases of an enum must follow a logical ordering that the author could explain if asked. If there is no obviously logical ordering, use a lexicographical ordering based on the cases' names.</paragraph><paragraph>In the following example, the cases are arranged in numerical order based on the underlying HTTP status code and blank lines are used to separate groups.</paragraph><code language="javascript">public enum HTTPStatus: Int {
  case ok = 200

  case badRequest = 400
  case notAuthorized = 401
  case paymentRequired = 402
  case forbidden = 403
  case notFound = 404

  case internalServerError = 500
}
</code><paragraph>The following version of the same enum is less readable. Although the cases are ordered lexicographically, the meaningful groupings of related values has been lost.</paragraph><code language="javascript">public enum HTTPStatus: Int {
  case badRequest = 400
  case forbidden = 403
  case internalServerError = 500
  case notAuthorized = 401
  case notFound = 404
  case ok = 200
  case paymentRequired = 402
}
</code><heading level="3">Trailing Closures</heading><paragraph>Functions should not be overloaded such that two overloads differ only by the name of their trailing closure argument. Doing so prevents using trailing closure syntax—when the label is not present, a call to the function with a trailing closure is ambiguous.</paragraph><paragraph>Consider the following example, which prohibits using trailing closure syntax to call greet:</paragraph><code language="javascript">func greet(enthusiastically nameProvider: () -> String) {
  print("Hello, \(nameProvider())! It's a pleasure to see you!")
}

func greet(apathetically nameProvider: () -> String) {
  print("Oh, look. It's \(nameProvider()).")
}

greet { "John" }  // error: ambiguous use of 'greet'
</code><paragraph>This example is fixed by differentiating some part of the function name other than the closure argument—in this case, the base name:</paragraph><code language="javascript">func greetEnthusiastically(_ nameProvider: () -> String) {
  print("Hello, \(nameProvider())! It's a pleasure to see you!")
}

func greetApathetically(_ nameProvider: () -> String) {
  print("Oh, look. It's \(nameProvider()).")
}

greetEnthusiastically { "John" }
greetApathetically { "not John" }
</code><paragraph>If a function call has multiple closure arguments, then none are called using trailing closure syntax; all are labeled and nested inside the argument list's parentheses.</paragraph><code language="javascript">UIView.animate(
  withDuration: 0.5,
  animations: {
    // ...
  },
  completion: { finished in
    // ...
  })
</code><code language="javascript">UIView.animate(
  withDuration: 0.5,
  animations: {
    // ...
  }) { finished in
    // ...
  }
</code><paragraph>If a function has a single closure argument and it is the final argument, then it is always called using trailing closure syntax, except in the following cases to resolve ambiguity or parsing errors:</paragraph><list type="ol"><item>As described above, labeled closure arguments must be used to disambiguate between two overloads with otherwise identical arguments lists.</item><item>Labeled closure arguments must be used in control flow statements where the body of the trailing closure would be parsed as the body of the control flow statement.</item></list><code language="javascript">Timer.scheduledTimer(timeInterval: 30, repeats: false) { timer in
  print("Timer done!")
}

if let firstActive = list.first(where: { $0.isActive }) {
  process(firstActive)
}
</code><code language="javascript">Timer.scheduledTimer(timeInterval: 30, repeats: false, block: { timer in
  print("Timer done!")
})

// This example fails to compile.
if let firstActive = list.first { $0.isActive } {
  process(firstActive)
}
</code><paragraph>When a function called with trailing closure syntax takes no other arguments, empty parentheses (()) after the function name are never present.</paragraph><code language="javascript">let squares = [1, 2, 3].map { $0 * $0 }
</code><code language="javascript">let squares = [1, 2, 3].map({ $0 * $0 })
let squares = [1, 2, 3].map() { $0 * $0 }
</code><heading level="3">Trailing Commas</heading><paragraph>Trailing commas in array and dictionary literals are required when each element is placed on its own line. Doing so produces cleaner diffs when items are added to those literals later.</paragraph><code language="javascript">let configurationKeys = [
  "bufferSize",
  "compression",
  "encoding",                                    // GOOD.
]
</code><code language="javascript">let configurationKeys = [
  "bufferSize",
  "compression",
  "encoding"                                     // AVOID.
]
</code><heading level="3">Numeric Literals</heading><paragraph>It is recommended but not required that long numeric literals (decimal, hexadecimal, octal, and binary) use the underscore (_) separator to group digits for readability when the literal has numeric value or when there exists a domain-specific grouping.</paragraph><paragraph>Recommended groupings are three digits for decimal (thousands separators), four digits for hexadecimal, four or eight digits for binary literals, or value-specific field boundaries when they exist (such as three digits for octal file permissions).</paragraph><paragraph>Do not group digits if the literal is an opaque identifier that does not have a meaningful numeric value.</paragraph><heading level="3">Attributes</heading><paragraph>Parameterized attributes (such as @availability(...) or @objc(...)) are each written on their own line immediately before the declaration to which they apply, are lexicographically ordered, and are indented at the same level as the declaration.</paragraph><code language="javascript">@available(iOS 9.0, *)
public func coolNewFeature() {
  // ...
}
</code><code language="javascript">@available(iOS 9.0, *) public func coolNewFeature() {
  // ...
}
</code><paragraph>Attributes without parameters (for example, @objc without arguments, @IBOutlet, or @NSManaged) are lexicographically ordered and may be placed on the same line as the declaration if and only if they would fit on that line without requiring the line to be rewrapped. If placing an attribute on the same line as the declaration would require a declaration to be wrapped that previously did not need to be wrapped, then the attribute is placed on its own line.</paragraph><code language="python">public class MyViewController: UIViewController {
  @IBOutlet private var tableView: UITableView!
}
</code><heading level="2">Naming</heading><heading level="3">Apple's API Style Guidelines</heading><paragraph>Apple's official Swift naming and API design guidelines hosted on swift.org are considered part of this style guide and are followed as if they were repeated here in their entirety.</paragraph><heading level="3">Naming Conventions Are Not Access Control</heading><paragraph>Restricted access control (internal, fileprivate, or private) is preferred for the purposes of hiding information from clients, rather than naming conventions.</paragraph><paragraph>Naming conventions (such as prefixing a leading underscore) are only used in rare situations when a declaration must be given higher visibility than is otherwise desired in order to work around language limitations—for example, a type that has a method that is only intended to be called by other parts of a library implementation that crosses module boundaries and must therefore be declared public.</paragraph><heading level="3">Identifiers</heading><paragraph>In general, identifiers contain only 7-bit ASCII characters. Unicode identifiers are allowed if they have a clear and legitimate meaning in the problem domain of the code base (for example, Greek letters that represent mathematical concepts) and are well understood by the team who owns the code.</paragraph><code language="javascript">let smile = "😊"
let deltaX = newX - previousX
let Δx = newX - previousX
</code><heading level="3">Initializers</heading><paragraph>For clarity, initializer arguments that correspond directly to a stored property have the same name as the property. Explicit self. is used during assignment to disambiguate them.</paragraph><code language="javascript">public struct Person {
  public let name: String
  public let phoneNumber: String

  // GOOD.
  public init(name: String, phoneNumber: String) {
    self.name = name
    self.phoneNumber = phoneNumber
  }
}
</code><code language="javascript">public struct Person {
  public let name: String
  public let phoneNumber: String

  // AVOID.
  public init(name otherName: String, phoneNumber otherPhoneNumber: String) {
    name = otherName
    phoneNumber = otherPhoneNumber
  }
}
</code><heading level="3">Static and Class Properties</heading><paragraph>Static and class properties that return instances of the declaring type are not suffixed with the name of the type.</paragraph><code language="javascript">public class UIColor {
  public class var red: UIColor {                // GOOD.
    // ...
  }
}

public class URLSession {
  public class var shared: URLSession {          // GOOD.
    // ...
  }
}
</code><code language="javascript">public class UIColor {
  public class var redColor: UIColor {           // AVOID.
    // ...
  }
}

public class URLSession {
  public class var sharedSession: URLSession {   // AVOID.
    // ...
  }
}
</code><paragraph>When a static or class property evaluates to a singleton instance of the declaring type, the names shared and default are commonly used. This style guide does not require specific names for these; the author should choose a name that makes sense for the type.</paragraph><heading level="3">Global Constants</heading><paragraph>Like other variables, global constants are lowerCamelCase. Hungarian notation, such as a leading g or k, is not used.</paragraph><code language="javascript">let secondsPerMinute = 60
</code><code language="javascript">let SecondsPerMinute = 60
let kSecondsPerMinute = 60
let gSecondsPerMinute = 60
let SECONDS_PER_MINUTE = 60
</code><heading level="3">Delegate Methods</heading><paragraph>Methods on delegate protocols and delegate-like protocols (such as data sources) are named using the linguistic syntax described below, which is inspired by Cocoa's protocols.</paragraph><paragraph>The term "delegate's source object" refers to the object that invokes methods on the delegate. For example, a UITableView is the source object that invokes methods on the UITableViewDelegate that is set as the view's delegate property.</paragraph><paragraph>All methods take the delegate's source object as the first argument.</paragraph><paragraph>For methods that take the delegate's source object as their only argument:</paragraph><list type="ul"><item>If the method returns Void (such as those used to notify the delegate that an event has occurred), then the method's base name is the delegate's source type followed by an indicative verb phrase describing the event. The argument is unlabeled. func scrollViewDidBeginScrolling(_ scrollView: UIScrollView)</item><item>If the method returns Bool (such as those that make an assertion about the delegate's source object itself), then the method's name is the delegate's source type followed by an indicative or conditional verb phrase describing the assertion. The argument is unlabeled. func scrollViewShouldScrollToTop(_ scrollView: UIScrollView) -> Bool</item><item>If the method returns some other value (such as those querying for information about a property of the delegate's source object), then the method's base name is a noun phrase describing the property being queried. The argument is labeled with a preposition or phrase with a trailing preposition that appropriately combines the noun phrase and the delegate's source object. func numberOfSections(in scrollView: UIScrollView) -> Int</item></list><paragraph>If the method returns Void (such as those used to notify the delegate that an event has occurred), then the method's base name is the delegate's source type followed by an indicative verb phrase describing the event. The argument is unlabeled.</paragraph><code language="go">func scrollViewDidBeginScrolling(_ scrollView: UIScrollView)
</code><paragraph>If the method returns Bool (such as those that make an assertion about the delegate's source object itself), then the method's name is the delegate's source type followed by an indicative or conditional verb phrase describing the assertion. The argument is unlabeled.</paragraph><code language="go">func scrollViewShouldScrollToTop(_ scrollView: UIScrollView) -> Bool
</code><paragraph>If the method returns some other value (such as those querying for information about a property of the delegate's source object), then the method's base name is a noun phrase describing the property being queried. The argument is labeled with a preposition or phrase with a trailing preposition that appropriately combines the noun phrase and the delegate's source object.</paragraph><code language="go">func numberOfSections(in scrollView: UIScrollView) -> Int
</code><paragraph>For methods that take additional arguments after the delegate's source object, the method's base name is the delegate's source type by itself and the first argument is unlabeled. Then:</paragraph><list type="ul"><item>If the method returns Void, the second argument is labeled with an indicative verb phrase describing the event that has the argument as its direct object or prepositional object, and any other arguments (if present) provide further context. func tableView( _ tableView: UITableView, willDisplayCell cell: UITableViewCell, forRowAt indexPath: IndexPath)</item><item>If the method returns Bool, the second argument is labeled with an indicative or conditional verb phrase that describes the return value in terms of the argument, and any other arguments (if present) provide further context. func tableView( _ tableView: UITableView, shouldSpringLoadRowAt indexPath: IndexPath, with context: UISpringLoadedInteractionContext ) -> Bool</item><item>If the method returns some other value, the second argument is labeled with a noun phrase and trailing preposition that describes the return value in terms of the argument, and any other arguments (if present) provide further context. func tableView( _ tableView: UITableView, heightForRowAt indexPath: IndexPath ) -> CGFloat</item></list><paragraph>If the method returns Void, the second argument is labeled with an indicative verb phrase describing the event that has the argument as its direct object or prepositional object, and any other arguments (if present) provide further context.</paragraph><code language="go">func tableView(
  _ tableView: UITableView,
  willDisplayCell cell: UITableViewCell,
  forRowAt indexPath: IndexPath)
</code><paragraph>If the method returns Bool, the second argument is labeled with an indicative or conditional verb phrase that describes the return value in terms of the argument, and any other arguments (if present) provide further context.</paragraph><code language="go">func tableView(
  _ tableView: UITableView,
  shouldSpringLoadRowAt indexPath: IndexPath,
  with context: UISpringLoadedInteractionContext
) -> Bool
</code><paragraph>If the method returns some other value, the second argument is labeled with a noun phrase and trailing preposition that describes the return value in terms of the argument, and any other arguments (if present) provide further context.</paragraph><code language="go">func tableView(
  _ tableView: UITableView,
  heightForRowAt indexPath: IndexPath
) -> CGFloat
</code><paragraph>Apple's documentation on delegates and data sources also contains some good general guidance about such names.</paragraph><heading level="2">Programming Practices</heading><paragraph>Common themes among the rules in this section are: avoid redundancy, avoid ambiguity, and prefer implicitness over explicitness unless being explicit improves readability and/or reduces ambiguity.</paragraph><heading level="3">Compiler Warnings</heading><paragraph>Code should compile without warnings when feasible. Any warnings that are able to be removed easily by the author must be removed.</paragraph><paragraph>A reasonable exception is deprecation warnings, where it may not be possible to immediately migrate to the replacement API, or where an API may be deprecated for external users but must still be supported inside a library during a deprecation period.</paragraph><heading level="3">Initializers</heading><paragraph>For structs, Swift synthesizes a non-public memberwise init that takes arguments for var properties and for any let properties that lack default values. When that initializer is suitable (that is, a public one is not needed), it is used and no explicit initializer is written.</paragraph><paragraph>The initializers declared by the special ExpressibleBy*Literal compiler protocols are never called directly.</paragraph><code language="javascript">struct Kilometers: ExpressibleByIntegerLiteral {
  init(integerLiteral value: Int) {
    // ...
  }
}

let k1: Kilometers = 10                          // GOOD.
let k2 = 10 as Kilometers                        // ALSO GOOD.
</code><code language="javascript">struct Kilometers: ExpressibleByIntegerLiteral {
  init(integerLiteral value: Int) {
    // ...
  }
}

let k = Kilometers(integerLiteral: 10)           // AVOID.
</code><paragraph>Explicitly calling .init(...) is allowed only when the receiver of the call is a metatype variable. In direct calls to the initializer using the literal type name, .init is omitted. (Referring to the initializer directly by using MyType.init syntax to convert it to a closure is permitted.)</paragraph><code language="javascript">let x = MyType(arguments)

let type = lookupType(context)
let x = type.init(arguments)

let x = makeValue(factory: MyType.init)
</code><code language="javascript">let x = MyType.init(arguments)
</code><heading level="3">Properties</heading><paragraph>The get block for a read-only computed property is omitted and its body is directly nested inside the property declaration.</paragraph><code language="javascript">var totalCost: Int {
  return items.sum { $0.cost }
}
</code><code language="javascript">var totalCost: Int {
  get {
    return items.sum { $0.cost }
  }
}
</code><heading level="3">Types with Shorthand Names</heading><paragraph>Arrays, dictionaries, and optional types are written in their shorthand form whenever possible; that is, [Element], [Key: Value], and Wrapped?. The long forms Array<Element>, Dictionary<Key, Value>, and Optional<Wrapped> are only written when required by the compiler; for example, the Swift parser requires Array<Element>.Index and does not accept [Element].Index.</paragraph><code language="javascript">func enumeratedDictionary<Element>(
  from values: [Element],
  start: Array<Element>.Index? = nil
) -> [Int: Element] {
  // ...
}
</code><code language="javascript">func enumeratedDictionary<Element>(
  from values: Array<Element>,
  start: Optional<Array<Element>.Index> = nil
) -> Dictionary<Int, Element> {
  // ...
}
</code><paragraph>Void is a typealias for the empty tuple (), so from an implementation point of view they are equivalent. In function type declarations (such as closures, or variables holding a function reference), the return type is always written as Void, never as (). In functions declared with the func keyword, the Void return type is omitted entirely.</paragraph><paragraph>Empty argument lists are always written as (), never as Void. (In fact, the function signature Void -> Result is an error in Swift because function arguments must be surrounded by parentheses, and (Void) has a different meaning: an argument list with a single empty-tuple argument.)</paragraph><code language="javascript">func doSomething() {
  // ...
}

let callback: () -> Void
</code><code language="javascript">func doSomething() -> Void {
  // ...
}

func doSomething2() -> () {
  // ...
}

let callback: () -> ()
</code><heading level="3">Optional Types</heading><paragraph>Sentinel values are avoided when designing algorithms (for example, an "index" of −1 when an element was not found in a collection). Sentinel values can easily and accidentally propagate through other layers of logic because the type system cannot distinguish between them and valid outcomes.</paragraph><paragraph>Optional is used to convey a non-error result that is either a value or the absence of a value. For example, when searching a collection for a value, not finding the value is still a valid and expected outcome, not an error.</paragraph><code language="javascript">func index(of thing: Thing, in things: [Thing]) -> Int? {
  // ...
}

if let index = index(of: thing, in: lotsOfThings) {
  // Found it.
} else {
  // Didn't find it.
}
</code><code language="javascript">func index(of thing: Thing, in things: [Thing]) -> Int {
  // ...
}

let index = index(of: thing, in: lotsOfThings)
if index != -1 {
  // Found it.
} else {
  // Didn't find it.
}
</code><paragraph>Optional is also used for error scenarios when there is a single, obvious failure state; that is, when an operation may fail for a single domain-specific reason that is clear to the client. (The domain-specific restriction is meant to exclude severe errors that are typically out of the user's control to properly handle, such as out-of-memory errors.)</paragraph><paragraph>For example, converting a string to an integer would fail if the string does not represent a valid integer that fits into the type's bit width:</paragraph><code language="javascript">struct Int17 {
  init?(_ string: String) {
    // ...
  }
}
</code><paragraph>Conditional statements that test that an Optional is non-nil but do not access the wrapped value are written as comparisons to nil. The following example is clear about the programmer's intent:</paragraph><code language="javascript">if value != nil {
  print("value was not nil")
}
</code><paragraph>This example, while taking advantage of Swift's pattern matching and binding syntax, obfuscates the intent by appearing to unwrap the value and then immediately throw it away.</paragraph><code language="javascript">if let _ = value {
  print("value was not nil")
}
</code><heading level="3">Error Types</heading><paragraph>Error types are used when there are multiple possible error states.</paragraph><paragraph>Throwing errors instead of merging them with the return type cleanly separates concerns in the API. Valid inputs and valid state produce valid outputs in the result domain and are handled with standard sequential control flow. Invalid inputs and invalid state are treated as errors and are handled using the relevant syntactic constructs (do-catch and try). For example:</paragraph><code language="javascript">struct Document {
  enum ReadError: Error {
    case notFound
    case permissionDenied
    case malformedHeader
  }

  init(path: String) throws {
    // ...
  }
}

do {
  let document = try Document(path: "important.data")
} catch Document.ReadError.notFound {
  // ...
} catch Document.ReadError.permissionDenied {
  // ...
} catch {
  // ...
}
</code><paragraph>Such a design forces the caller to consciously acknowledge the failure case by:</paragraph><list type="ul"><item>wrapping the calling code in a do-catch block and handling error cases to whichever degree is appropriate,</item><item>declaring the function in which the call is made as throws and letting the error propagate out, or</item><item>using try? when the specific reason for failure is unimportant and only the information about whether the call failed is needed.</item></list><paragraph>In general, with exceptions noted below, force-try! is forbidden; it is equivalent to try followed by fatalError but without a meaningful message. If an error outcome would mean that the program is in such an unrecoverable state that immediate termination is the only reasonable action, it is better to use do-catch or try? and provide more context in the error message to assist debugging if the operation does fail.</paragraph><paragraph>Exception: Force-try! is allowed in unit tests and test-only code. It is also allowed in non-test code when it is unmistakably clear that an error would only be thrown because of programmer error; we specifically define this to mean a single expression that could be evaluated without context in the Swift REPL. For example, consider initializing a regular expression from a a string literal:</paragraph><code language="javascript">let regex = try! NSRegularExpression(pattern: "a*b+c?")
</code><paragraph>The NSRegularExpression initializer throws an error if the regular expression is malformed, but when it is a string literal, the error would only occur if the programmer mistyped it. There is no benefit to writing extra error handling logic here.</paragraph><paragraph>If the pattern above were not a literal but instead were dynamic or derived from user input, try! should not be used and errors should be handled gracefully.</paragraph><heading level="3">Force Unwrapping and Force Casts</heading><paragraph>Force-unwrapping and force-casting are often code smells and are strongly discouraged. Unless it is extremely clear from surrounding code why such an operation is safe, a comment should be present that describes the invariant that ensures that the operation is safe. For example,</paragraph><code language="javascript">let value = getSomeInteger()

// ...intervening code...

// This force-unwrap is safe because `value` is guaranteed to fall within the
// valid enum cases because it came from some data source that only permits
// those raw values.
return SomeEnum(rawValue: value)!
</code><paragraph>Exception: Force-unwraps are allowed in unit tests and test-only code without additional documentation. This keeps such code free of unnecessary control flow. In the event that nil is unwrapped or a cast operation is to an incompatible type, the test will fail which is the desired result.</paragraph><heading level="3">Implicitly Unwrapped Optionals</heading><paragraph>Implicitly unwrapped optionals are inherently unsafe and should be avoided whenever possible in favor of non-optional declarations or regular Optional types. Exceptions are described below.</paragraph><paragraph>User-interface objects whose lifetimes are based on the UI lifecycle instead of being strictly based on the lifetime of the owning object are allowed to use implicitly unwrapped optionals. Examples of these include @IBOutlet properties connected to objects in a XIB file or storyboard, properties that are initialized externally like in the prepareForSegue implementation of a calling view controller, and properties that are initialized elsewhere during a class's life cycle, like views in a view controller's viewDidLoad method. Making such properties regular optionals can put too much burden on the user to unwrap them because they are guaranteed to be non-nil and remain that way once the objects are ready for use.</paragraph><code language="python">class SomeViewController: UIViewController {
  @IBOutlet var button: UIButton!

  override func viewDidLoad() {
    populateLabel(for: button)
  }

  private func populateLabel(for button: UIButton) {
    // ...
  }
}
</code><paragraph>Implicitly unwrapped optionals can also surface in Swift code when using Objective-C APIs that lack the appropriate nullability attributes. If possible, coordinate with the owners of that code to add those annotations so that the APIs are imported cleanly into Swift. If this is not possible, try to keep the footprint of those implicitly unwrapped optionals as small as possible in your Swift code; that is, do not propagate them through multiple layers of your own abstractions.</paragraph><paragraph>Implicitly unwrapped optionals are also allowed in unit tests. This is for reasons similar to the UI object scenario above—the lifetime of test fixtures often begins not in the test's initializer but in the setUp() method of a test so that they can be reset before the execution of each test.</paragraph><heading level="3">Access Levels</heading><paragraph>Omitting an explicit access level is permitted on declarations. For top-level declarations, the default access level is internal. For nested declarations, the default access level is the lesser of internal and the access level of the enclosing declaration.</paragraph><paragraph>Specifying an explicit access level at the file level on an extension is forbidden. Each member of the extension has its access level specified if it is different than the default.</paragraph><code language="javascript">extension String {
  public var isUppercase: Bool {
    // ...
  }

  public var isLowercase: Bool {
    // ...
  }
}
</code><code language="javascript">public extension String {
  var isUppercase: Bool {
    // ...
  }

  var isLowercase: Bool {
    // ...
  }
}
</code><heading level="3">Nesting and Namespacing</heading><paragraph>Swift allows enums, structs, and classes to be nested, so nesting is preferred (instead of naming conventions) to express scoped and hierarchical relationships among types when possible. For example, flag enums or error types that are associated with a specific type are nested in that type.</paragraph><code language="javascript">class Parser {
  enum Error: Swift.Error {
    case invalidToken(String)
    case unexpectedEOF
  }

  func parse(text: String) throws {
    // ...
  }
}
</code><code language="javascript">class Parser {
  func parse(text: String) throws {
    // ...
  }
}

enum ParseError: Error {
  case invalidToken(String)
  case unexpectedEOF
}
</code><paragraph>Swift does not currently allow protocols to be nested in other types or vice versa, so this rule does not apply to situations such as the relationship between a controller class and its delegate protocol.</paragraph><paragraph>Declaring an enum without cases is the canonical way to define a "namespace" to group a set of related declarations, such as constants or helper functions. This enum automatically has no instances and does not require that extra boilerplate code be written to prevent instantiation.</paragraph><code language="javascript">enum Dimensions {
  static let tileMargin: CGFloat = 8
  static let tilePadding: CGFloat = 4
  static let tileContentSize: CGSize(width: 80, height: 64)
}
</code><code language="javascript">struct Dimensions {
  private init() {}

  static let tileMargin: CGFloat = 8
  static let tilePadding: CGFloat = 4
  static let tileContentSize: CGSize(width: 80, height: 64)
}
</code><heading level="3">guards for Early Exits</heading><paragraph>A guard statement, compared to an if statement with an inverted condition, provides visual emphasis that the condition being tested is a special case that causes early exit from the enclosing scope.</paragraph><paragraph>Furthermore, guard statements improve readability by eliminating extra levels of nesting (the "pyramid of doom"); failure conditions are closely coupled to the conditions that trigger them and the main logic remains flush left within its scope.</paragraph><paragraph>This can be seen in the following examples; in the first, there is a clear progression that checks for invalid states and exits, then executes the main logic in the successful case. In the second example without guard, the main logic is buried at an arbitrary nesting level and the thrown errors are separated from their conditions by a great distance.</paragraph><code language="javascript">func discombobulate(_ values: [Int]) throws -> Int {
  guard let first = values.first else {
    throw DiscombobulationError.arrayWasEmpty
  }
  guard first >= 0 else {
    throw DiscombobulationError.negativeEnergy
  }

  var result = 0
  for value in values {
    result += invertedCombobulatoryFactory(of: value)
  }
  return result
}
</code><code language="javascript">func discombobulate(_ values: [Int]) throws -> Int {
  if let first = values.first {
    if first >= 0 {
      var result = 0
      for value in values {
        result += invertedCombobulatoryFactor(of: value)
      }
      return result
    } else {
      throw DiscombobulationError.negativeEnergy
    }
  } else {
    throw DiscombobulationError.arrayWasEmpty
  }
}
</code><paragraph>A guard-continue statement can also be useful in a loop to avoid increased indentation when the entire body of the loop should only be executed in some cases (but see also the for-where discussion below.)</paragraph><heading level="3">for-where Loops</heading><paragraph>When the entirety of a for loop's body would be a single if block testing a condition of the element, the test is placed in the where clause of the for statement instead.</paragraph><code language="javascript">for item in collection where item.hasProperty {
  // ...
}
</code><code language="javascript">for item in collection {
  if item.hasProperty {
    // ...
  }
}
</code><heading level="3">fallthrough in switch Statements</heading><paragraph>When multiple cases of a switch would execute the same statements, the case patterns are combined into ranges or comma-delimited lists. Multiple case statements that do nothing but fallthrough to a case below are not allowed.</paragraph><code language="javascript">switch value {
case 1: print("one")
case 2...4: print("two to four")
case 5, 7: print("five or seven")
default: break
}
</code><code language="javascript">switch value {
case 1: print("one")
case 2: fallthrough
case 3: fallthrough
case 4: print("two to four")
case 5: fallthrough
case 7: print("five or seven")
default: break
}
</code><paragraph>In other words, there is never a case whose body contains only the fallthrough statement. Cases containing additional statements which then fallthrough to the next case are permitted.</paragraph><heading level="3">Pattern Matching</heading><paragraph>The let and var keywords are placed individually in front of each element in a pattern that is being matched. The shorthand version of let/var that precedes and distributes across the entire pattern is forbidden because it can introduce unexpected behavior if a value being matched in a pattern is itself a variable.</paragraph><code language="javascript">enum DataPoint {
  case unlabeled(Int)
  case labeled(String, Int)
}

let label = "goodbye"

// `label` is treated as a value here because it is not preceded by `let`, so
// the pattern below matches only data points that have the label "goodbye".
switch DataPoint.labeled("hello", 100) {
case .labeled(label, let value):
  // ...
}

// Writing `let` before each individual binding clarifies that the intent is to
// introduce a new binding (shadowing the local variable within the case) rather
// than to match against the value of the local variable. Thus, this pattern
// matches data points with any string label.
switch DataPoint.labeled("hello", 100) {
case .labeled(let label, let value):
  // ...
}
</code><paragraph>In the example below, if the author's intention was to match using the value of the label variable above, that has been lost because let distributes across the entire pattern and thus shadows the variable with a binding that applies to any string value:</paragraph><code language="javascript">switch DataPoint.labeled("hello", 100) {
case let .labeled(label, value):
  // ...
}
</code><paragraph>Labels of tuple arguments and enum associated values are omitted when binding a value to a variable with the same name as the label.</paragraph><code language="javascript">enum BinaryTree<Element> {
  indirect case subtree(left: BinaryTree<Element>, right: BinaryTree<Element>)
  case leaf(element: Element)
}

switch treeNode {
case .subtree(let left, let right):
  // ...
case .leaf(let element):
  // ...
}
</code><paragraph>Including the labels adds noise that is redundant and lacking useful information:</paragraph><code language="javascript">switch treeNode {
case .subtree(left: let left, right: let right):
  // ...
case .leaf(element: let element):
  // ...
}
</code><heading level="3">Tuple Patterns</heading><paragraph>Assigning variables through a tuple pattern (sometimes referred to as a tuple shuffle) is only permitted if the left-hand side of the assignment is unlabeled.</paragraph><code language="javascript">let (a, b) = (y: 4, x: 5.0)
</code><code language="javascript">let (x: a, y: b) = (y: 4, x: 5.0)
</code><paragraph>Labels on the left-hand side closely resemble type annotations, and can lead to confusing code.</paragraph><code language="javascript">// This declares two variables, `Int`, which is a `Double` with value 5.0, and
// `Double`, which is an `Int` with value 4.
// `x` and `y` are not variables.
let (x: Int, y: Double) = (y: 4, x: 5.0)
</code><heading level="3">Numeric and String Literals</heading><paragraph>Integer and string literals in Swift do not have an intrinsic type. For example, 5 by itself is not an Int; it is a special literal value that can express any type that conforms to ExpressibleByIntegerLiteral and only becomes an Int if type inference does not map it to a more specific type. Likewise, the literal "x" is neither String nor Character nor UnicodeScalar, but it can become any of those types depending on its context, falling back to String as a default.</paragraph><paragraph>Thus, when a literal is used to initialize a value of a type other than its default, and when that type cannot be inferred otherwise by context, specify the type explicitly in the declaration or use an as expression to coerce it.</paragraph><code language="javascript">// Without a more explicit type, x1 will be inferred as type Int.
let x1 = 50

// These are explicitly type Int32.
let x2: Int32 = 50
let x3 = 50 as Int32

// Without a more explicit type, y1 will be inferred as type String.
let y1 = "a"

// These are explicitly type Character.
let y2: Character = "a"
let y3 = "a" as Character

// These are explicitly type UnicodeScalar.
let y4: UnicodeScalar = "a"
let y5 = "a" as UnicodeScalar

func writeByte(_ byte: UInt8) {
  // ...
}
// Inference also occurs for function arguments, so 50 is a UInt8 without
// explicitly coercion.
writeByte(50)
</code><paragraph>The compiler will emit errors appropriately for invalid literal coercions if, for example, a number does not fit into the integer type or a multi-character string is coerced to a character. So while the following examples emit errors, they are "good" because the errors are caught at compile-time and for the right reasons.</paragraph><code language="javascript">// error: integer literal '9223372036854775808' overflows when stored into 'Int64'
let a = 0x8000_0000_0000_0000 as Int64

// error: cannot convert value of type 'String' to type 'Character' in coercion
let b = "ab" as Character
</code><paragraph>Using initializer syntax for these types of coercions can lead to misleading compiler errors, or worse, hard-to-debug runtime errors.</paragraph><code language="javascript">// This first tries to create an `Int` (signed) from the literal and then
// convert it to a `UInt64`. Even though this literal fits into a `UInt64`, it
// doesn't fit into an `Int` first, so it doesn't compile.
let a1 = UInt64(0x8000_0000_0000_0000)

// This invokes `Character.init(_: String)`, thus creating a `String` "a" at
// runtime (which involves a slow heap allocation), extracting the character
// from it, and then releasing it. This is significantly slower than a proper
// coercion.
let b = Character("a")

// As above, this creates a `String` and then `Character.init(_: String)`
// attempts to extract the single character from it. This fails a precondition
// check and traps at runtime.
let c = Character("ab")
</code><heading level="3">Playground Literals</heading><paragraph>The graphically-rendered playground literals #colorLiteral(...), #imageLiteral(...), and #fileLiteral(...) are forbidden in non-playground production code. They are permitted in playground sources.</paragraph><code language="javascript">let color = UIColor(red: 1.0, green: 1.0, blue: 1.0, alpha: 1.0)
</code><code language="javascript">let color = #colorLiteral(red: 1.0, green: 1.0, blue: 1.0, alpha: 1.0)
</code><heading level="3">Trapping vs. Overflowing Arithmetic</heading><paragraph>The standard (trapping-on-overflow) arithmetic and bitwise operators (+, -, *, <<, and >>) are used for most normal operations, rather than the masking operations (preceded by &). Trapping on overflow is safer because it prevents bad data from propagating through other layers of the system.</paragraph><code language="javascript">// GOOD. Overflow will not cause the balance to go negative.
let newBankBalance = oldBankBalance + recentHugeProfit
</code><code language="javascript">// AVOID. Overflow will cause the balance to go negative if the summands are
// large.
let newBankBalance = oldBankBalance &+ recentHugeProfit
</code><paragraph>Masking operations are comparatively rare but are permitted (and in fact necessary for correctness) in problem domains that use modular arithmetic, such as cryptography, big-integer implementations, hash functions, and so forth.</paragraph><code language="javascript">var hashValue: Int {
  // GOOD. What matters here is the distribution of the bit pattern rather than
  // the actual numeric value.
  return foo.hashValue &+ 31 * (bar.hashValue &+ 31 &* baz.hashValue)
}
</code><code language="javascript">var hashValue: Int {
  // INCORRECT. This will trap arbitrarily and unpredictably depending on the
  // hash values of the individual terms.
  return foo.hashValue + 31 * (bar.hashValue + 31 * baz.hashValue)
}
</code><paragraph>Masking operations are also permitted in performance-sensitive code where the values are already known to not cause overflow (or where overflow is not a concern). In this case, comments should be used to indicate why the use of masking operations is important. Additionally, consider adding debug preconditions to check these assumptions without affecting performance of optimized builds.</paragraph><heading level="3">Defining New Operators</heading><paragraph>When used unwisely, custom-defined operators can significantly reduce the readability of code because such operators often lack the historical context of the more common ones built into the standard library.</paragraph><paragraph>In general, defining custom operators should be avoided. However, it is allowed when an operator has a clear and well-defined meaning in the problem domain and when using an operator significantly improves the readability of the code when compared to function calls. For example, since * is the only multiplication operator defined by Swift (not including the masking version), a numeric matrix library may define additional operators to support other operations like cross product and dot product.</paragraph><paragraph>An example of a prohibited use case is defining custom <~~ and ~~> operators to decode and encode JSON data. Such operators are not native to the problem domain of processing JSON and even an experienced Swift engineer would have difficulty understanding the purpose of the code without seeking out documentation of those operators.</paragraph><paragraph>If you must use third-party code of unquestionable value that provides an API only available through custom operators, you are strongly encouraged to consider writing a wrapper that defines more readable methods that delegate to the custom operators. This will significantly reduce the learning curve required to understand how such code works for new teammates and other code reviewers.</paragraph><heading level="3">Overloading Existing Operators</heading><paragraph>Overloading operators is permitted when your use of the operator is semantically equivalent to the existing uses in the standard library. Examples of permitted use cases are implementing the operator requirements for Equatable and Hashable, or defining a new Matrix type that supports arithmetic operations.</paragraph><paragraph>If you wish to overload an existing operator with a meaning other than its natural meaning, follow the guidance in Defining New Operators to determine whether this is permitted. In other words, if the new meaning is well-established in the problem domain and the use of the operator is a readability improvement over other syntactic constructs, then it is permitted.</paragraph><paragraph>An example of a prohibited case of operator repurposing would be to overload * and + to build an ad hoc regular expression API. Such an API would not provide strong enough readability benefits compared to simply representing the entire regular expression as a string.</paragraph><heading level="3">General Format</heading><paragraph>Documentation comments are written using the format where each line is preceded by a triple slash (///). Javadoc-style block comments (/** ... */) are not permitted.</paragraph><code language="javascript">/// Returns the numeric value of the given digit represented as a Unicode scalar.
///
/// - Parameters:
///   - digit: The Unicode scalar whose numeric value should be returned.
///   - radix: The radix, between 2 and 36, used to compute the numeric value.
/// - Returns: The numeric value of the scalar.
func numericValue(of digit: UnicodeScalar, radix: Int = 10) -> Int {
  // ...
}
</code><code language="javascript">/**
 * Returns the numeric value of the given digit represented as a Unicode scalar.
 *
 * - Parameters:
 *   - digit: The Unicode scalar whose numeric value should be returned.
 *   - radix: The radix, between 2 and 36, used to compute the numeric value.
 * - Returns: The numeric value of the scalar.
 */
func numericValue(of digit: UnicodeScalar, radix: Int = 10) -> Int {
  // ...
}

/**
Returns the numeric value of the given digit represented as a Unicode scalar.

- Parameters:
  - digit: The Unicode scalar whose numeric value should be returned.
  - radix: The radix, between 2 and 36, used to compute the numeric value.
- Returns: The numeric value of the scalar.
*/
func numericValue(of digit: UnicodeScalar, radix: Int = 10) -> Int {
  // ...
}
</code><heading level="3">Single-Sentence Summary</heading><paragraph>Documentation comments begin with a brief single-sentence summary that describes the declaration. (This sentence may span multiple lines, but if it spans too many lines, the author should consider whether the summary can be simplified and details moved to a new paragraph.)</paragraph><paragraph>If more detail is needed than can be stated in the summary, additional paragraphs (each separated by a blank line) are added after it.</paragraph><paragraph>The single-sentence summary is not necessarily a complete sentence; for example, method summaries are generally written as verb phrases without "this method […]" because it is already implied as the subject and writing it out would be redundant. Likewise, properties are often written as noun phrases without "this property is […]". In any case, however, they are still terminated with a period.</paragraph><code language="javascript">/// The background color of the view.
var backgroundColor: UIColor

/// Returns the sum of the numbers in the given array.
///
/// - Parameter numbers: The numbers to sum.
/// - Returns: The sum of the numbers.
func sum(_ numbers: [Int]) -> Int {
  // ...
}
</code><code language="javascript">/// This property is the background color of the view.
var backgroundColor: UIColor

/// This method returns the sum of the numbers in the given array.
///
/// - Parameter numbers: The numbers to sum.
/// - Returns: The sum of the numbers.
func sum(_ numbers: [Int]) -> Int {
  // ...
}
</code><paragraph>Clearly document the parameters, return value, and thrown errors of functions using the Parameter(s), Returns, and Throws tags, in that order. None ever appears with an empty description. When a description does not fit on a single line, continuation lines are indented 2 spaces in from the position of the hyphen starting the tag.</paragraph><paragraph>The recommended way to write documentation comments in Xcode is to place the text cursor on the declaration and press Command + Option + /. This will automatically generate the correct format with placeholders to be filled in.</paragraph><paragraph>Parameter(s) and Returns tags may be omitted only if the single-sentence brief summary fully describes the meaning of those items and including the tags would only repeat what has already been said.</paragraph><paragraph>The content following the Parameter(s), Returns, and Throws tags should be terminated with a period, even when they are phrases instead of complete sentences.</paragraph><paragraph>When a method takes a single argument, the singular inline form of the Parameter tag is used. When a method takes multiple arguments, the grouped plural form Parameters is used and each argument is written as an item in a nested list with only its name as the tag.</paragraph><code language="javascript">/// Returns the output generated by executing a command.
///
/// - Parameter command: The command to execute in the shell environment.
/// - Returns: A string containing the contents of the invoked process's
///   standard output.
func execute(command: String) -> String {
  // ...
}

/// Returns the output generated by executing a command with the given string
/// used as standard input.
///
/// - Parameters:
///   - command: The command to execute in the shell environment.
///   - stdin: The string to use as standard input.
/// - Returns: A string containing the contents of the invoked process's
///   standard output.
func execute(command: String, stdin: String) -> String {
  // ...
}
</code><paragraph>The following examples are incorrect, because they use the plural form of Parameters for a single parameter or the singular form Parameter for multiple parameters.</paragraph><code language="javascript">/// Returns the output generated by executing a command.
///
/// - Parameters:
///   - command: The command to execute in the shell environment.
/// - Returns: A string containing the contents of the invoked process's
///   standard output.
func execute(command: String) -> String {
  // ...
}

/// Returns the output generated by executing a command with the given string
/// used as standard input.
///
/// - Parameter command: The command to execute in the shell environment.
/// - Parameter stdin: The string to use as standard input.
/// - Returns: A string containing the contents of the invoked process's
///   standard output.
func execute(command: String, stdin: String) -> String {
  // ...
}
</code><heading level="3">Apple's Markup Format</heading><paragraph>Use of Apple's markup format is strongly encouraged to add rich formatting to documentation. Such markup helps to differentiate symbolic references (like parameter names) from descriptive text in comments and is rendered by Xcode and other documentation generation tools. Some examples of frequently used directives are listed below.</paragraph><list type="ul"><item>Paragraphs are separated using a single line that starts with /// and is otherwise blank.</item><item>*Single asterisks* and _single underscores_ surround text that should be rendered in italic/oblique type.</item><item>**Double asterisks** and __double underscores__ surround text that should be rendered in boldface.</item><item>Names of symbols or inline code are surrounded in `backticks`.</item><item>Multi-line code (such as example usage) is denoted by placing three backticks ( `` `) on the lines before and after the code block.</item></list><heading level="3">Where to Document</heading><paragraph>At a minimum, documentation comments are present for every open or public declaration, and every open or public member of such a declaration, with specific exceptions noted below:</paragraph><list type="ul"><item>Individual cases of an enum often are not documented if their meaning is self-explanatory from their name. Cases with associated values, however, should document what those values mean if it is not obvious.</item><item>A documentation comment is not always present on a declaration that overrides a supertype declaration or implements a protocol requirement, or on a declaration that provides the default implementation of a protocol requirement in an extension. It is acceptable to document an overridden declaration to describe new behavior from the declaration that it overrides. In no case should the documentation for the override be a mere copy of the base declaration's documentation.</item><item>A documentation comment is not always present on test classes and test methods. However, they can be useful for functional test classes and for helper classes/methods shared by multiple tests.</item><item>A documentation comment is not always present on an extension declaration (that is, the extension itself). You may choose to add one if it help clarify the purpose of the extension, but avoid meaningless or misleading comments. In the following example, the comment is just repetition of what is already obvious from the source code: /// Add `Equatable` conformance. extension MyType: Equatable { // ... } The next example is more subtle, but it is an example of documentation that is not scalable because the extension or the conformance could be updated in the future. Consider that the type may be made Comparable at the time of that writing in order to sort the values, but that is not the only possible use of that conformance and client code could use it for other purposes in the future. /// Make `Candidate` comparable so that they can be sorted. extension Candidate: Comparable { // ... }</item></list><paragraph>Individual cases of an enum often are not documented if their meaning is self-explanatory from their name. Cases with associated values, however, should document what those values mean if it is not obvious.</paragraph><paragraph>A documentation comment is not always present on a declaration that overrides a supertype declaration or implements a protocol requirement, or on a declaration that provides the default implementation of a protocol requirement in an extension.</paragraph><paragraph>It is acceptable to document an overridden declaration to describe new behavior from the declaration that it overrides. In no case should the documentation for the override be a mere copy of the base declaration's documentation.</paragraph><paragraph>A documentation comment is not always present on test classes and test methods. However, they can be useful for functional test classes and for helper classes/methods shared by multiple tests.</paragraph><paragraph>A documentation comment is not always present on an extension declaration (that is, the extension itself). You may choose to add one if it help clarify the purpose of the extension, but avoid meaningless or misleading comments.</paragraph><paragraph>In the following example, the comment is just repetition of what is already obvious from the source code:</paragraph><code language="javascript">/// Add `Equatable` conformance.
extension MyType: Equatable {
  // ...
}
</code><paragraph>The next example is more subtle, but it is an example of documentation that is not scalable because the extension or the conformance could be updated in the future. Consider that the type may be made Comparable at the time of that writing in order to sort the values, but that is not the only possible use of that conformance and client code could use it for other purposes in the future.</paragraph><code language="javascript">/// Make `Candidate` comparable so that they can be sorted.
extension Candidate: Comparable {
  // ...
}
</code><paragraph>In general, if you find yourself writing documentation that simply repeats information that is obvious from the source and sugaring it with words like "a representation of," then leave the comment out entirely.</paragraph><paragraph>However, it is not appropriate to cite this exception to justify omitting relevant information that a typical reader might need to know. For example, for a property named canonicalName, don't omit its documentation (with the rationale that it would only say /// The canonical name.) if a typical reader may have no idea what the term "canonical name" means in that context. Use the documentation as an opportunity to define the term.</paragraph></content>
</page>
<page url="https://google.github.io/styleguide/xmlstyle.html">
<title>[no-title]</title>
<content><heading level="1">Google XML Document Format Style Guide</heading><paragraph>Version 1.0Copyright Google 2008</paragraph><heading level="2">Introduction</heading><paragraph>This document provides a set of guidelines for general use when designing new XML document formats (and to some extent XML documents as well; see Section 11). Document formats usually include both formal parts (DTDs, schemas) and parts expressed in normative English prose.</paragraph><paragraph>These guidelines apply to new designs, and are not intended to force retroactive changes in existing designs. When participating in the creation of public or private document format designs, the guidelines may be helpful but should not control the group consensus.</paragraph><paragraph>This guide is meant for the design of XML that is to be generated and consumed by machines rather than human beings. Its rules are</paragraph><paragraph>to formats such as XHTML (which should be formatted as much like HTML as possible) or ODF which are meant to express rich text. A document that includes embedded content in XHTML or some other rich-text format, but also contains purely machine-interpretable portions, SHOULD follow this style guide for the machine-interpretable portions. It also does not affect XML document formats that are created by translations from proto buffers or through some other type of format.</paragraph><paragraph>Brief rationales have been added to most of the guidelines. They are maintained in the same document in hopes that they won't get out of date, but they are not considered normative.</paragraph><paragraph>The terms MUST, MUST NOT, SHOULD, SHOULD NOT, and MAY are used in this document in the sense of</paragraph><heading level="2">1. To design or not to design, that is the question</heading><list type="ol"><item>Attempt to reuse existing XML formats whenever possible, especially those which allow extensions. Creating an entirely new format should be done only with care and consideration; read Tim Bray's warnings first. Try to get wide review of your format, from outside your organization as well, if possible. [Rationale: New document formats have a cost: they must be reviewed, documented, and learned by users.]</item><item>If you are reusing or extending an existing format, make sensible use of the prescribed elements and attributes, especially any that are required. Don't completely repurpose them, but do try to see how they might be used in creative ways if the vanilla semantics aren't suitable. As a last resort when an element or attribute is required by the format but is not appropriate for your use case, use some fixed string as its value. [Rationale: Markup reuse is good, markup abuse is bad.]</item><item>When extending formats, use the implicit style of the existing format, even if it contradicts this guide. [Rationale: Consistency.]</item></list><heading level="2">2. Schemas</heading><list type="ol"><item>Document formats SHOULD be expressed using a schema language. [Rationale: Clarity and machine-checkability.]</item><item>The schema language SHOULD be RELAX NG compact syntax. Embedded Schematron rules MAY be added to the schema for additional fine control. [Rationale: RELAX NG is the most flexible schema language, with very few arbitrary restrictions on designs. The compact syntax is quite easy to read and learn, and can be converted one-to-one to and from the XML syntax when necessary. Schematron handles arbitrary cross-element and cross-attribute constraints nicely.]</item><item>Schemas SHOULD use the "Salami Slice" style (one rule per element). Schemas MAY use the "Russian Doll" style (schema resembles document) if they are short and simple. The "Venetian Blind" style (one rule per element type) is unsuited to RELAX NG and SHOULD NOT be used.</item><item>Regular expressions SHOULD be provided to assist in validating complex values.</item><item>DTDs and/or W3C XML Schemas MAY be provided for compatibility with existing products, tools, or users. [Rationale: We can't change the world all at once.]</item></list><heading level="2">3. Namespaces</heading><list type="ol"><item>Element names MUST be in a namespace, except when extending pre-existing document types that do not use namespaces. A default namespace SHOULD be used. [Rationale: Namespace-free documents are obsolete; every set of names should be in some namespace. Using a default namespace improves readability.]</item><item>Attribute names SHOULD NOT be in a namespace unless they are drawn from a foreign document type or are meant to be used in foreign document types. [Rationale: Attribute names in a namespace must always have a prefix, which is annoying to type and hard to read.]</item><item>Namespace names are HTTP URIs. Namespace names SHOULD take the form https://example.com/whatever/year, where whatever is a unique value based on the name of the document type, and year is the year the namespace was created. There may be additional URI-path parts before the year. [Rationale: Existing convention. Providing the year allows for the possible recycling of code names.]</item><item>Namespaces MUST NOT be changed unless the semantics of particular elements or attributes has changed in drastically incompatible ways. [Rationale: Changing the namespace requires changing all client code.]</item><item>Namespace prefixes SHOULD be short (but not so short that they are likely to be conflict with another project). Single-letter prefixes MUST NOT be used. Prefixes SHOULD contain only lower-case ASCII letters. [Rationale: Ease of typing and absence of encoding compatibility problems.]</item></list><heading level="2">4. Names and enumerated values</heading><paragraph>"Names" refers to the names of elements, attributes, and enumerated values.</paragraph><list type="ol"><item>All names MUST use lowerCamelCase. That is, they start with an initial lower-case letter, then each new word within the name starts with an initial capital letter. [Rationale: Adopting a single style provides consistency, which helps when referring to names since the capitalization is known and so does not have to be remembered. It matches Java style, and other languages can be dealt with using automated name conversion.]</item><item>Names MUST contain only ASCII letters and digits. [Rationale: Ease of typing and absence of encoding compatibility problems.]</item><item>Names SHOULD NOT exceed 25 characters. Longer names SHOULD be avoided by devising concise and informative names. If a name can only remain within this limit by becoming obscure, the limit SHOULD be ignored. [Rationale: Longer names are awkward to use and require additional bandwidth.]</item><item>Published standard abbreviations, if sufficiently well-known, MAY be employed in constructing names. Ad hoc abbreviations MUST NOT be used. Acronyms MUST be treated as words for camel-casing purposes: informationUri, not informationURI. [Rationale: An abbreviation that is well known to one community is often incomprehensible to others who need to use the same document format (and who do understand the full name); treating an acronym as a word makes it easier to see where the word boundaries are.]</item></list><heading level="2">5. Elements</heading><list type="ol"><item>All elements MUST contain either nothing, character content, or child elements. Mixed content MUST NOT be used. [Rationale: Many XML data models don't handle mixed content properly, and its use makes the element order-dependent. As always, textual formats are not covered by this rule.]</item><item>XML elements that merely wrap repeating child elements SHOULD NOT be used. [Rationale: They are not used in Atom and add nothing.]</item></list><heading level="2">6. Attributes</heading><list type="ol"><item>Document formats MUST NOT depend on the order of attributes in a start-tag. [Rationale: Few XML parsers report the order, and it is not part of the XML Infoset.]</item><item>Elements SHOULD NOT be overloaded with too many attributes (no more than 10 as a rule of thumb). Instead, use child elements to encapsulate closely related attributes. [Rationale: This approach maintains the built-in extensibility that XML provides with elements, and is useful for providing forward compatibility as a specification evolves.]</item><item>Attributes MUST NOT be used to hold values in which line breaks are significant. [Rationale: Such line breaks are converted to spaces by conformant XML parsers.]</item><item>Document formats MUST allow either single or double quotation marks around attribute values. [Rationale: XML parsers don't report the difference.]</item></list><heading level="2">7. Values</heading><list type="ol"><item>Numeric values SHOULD be 32-bit signed integers, 64-bit signed integers, or 64-bit IEEE doubles, all expressed in base 10. These correspond to the XML Schema types xsd:int, xsd:long, and xsd:double respectively. If required in particular cases, xsd:integer (unlimited-precision integer) values MAY also be used. [Rationale: There are far too many numeric types in XML Schema: these provide a reasonable subset.]</item><item>Boolean values SHOULD NOT be used (use enumerations instead). If they must be used, they MUST be expressed as true or false, corresponding to a subset of the XML Schema type xsd:boolean. The alternative xsd:boolean values 1 and 0 MUST NOT be used. [Rationale: Boolean arguments are not extensible. The additional flexibility of allowing numeric values is not abstracted away by any parser.]</item><item>Dates should be represented using RFC 3339 format, a subset of both ISO 8601 format and XML Schema xsd:dateTime format. UTC times SHOULD be used rather than local times. [Rationale: There are far too many date formats and time zones, although it is recognized that sometimes local time preserves important information.]</item><item>Embedded syntax in character content and attribute values SHOULD NOT be used. Syntax in values means XML tools are largely useless. Syntaxes such as dates, URIs, and XPath expressions are exceptions. [Rationale: Users should be able to process XML documents using only an XML parser without requiring additional special-purpose parsers, which are easy to get wrong.]</item><item>Be careful with whitespace in values. XML parsers don't strip whitespace in elements, but do convert newlines to spaces in attributes. However, application frameworks may do more aggressive whitespace stripping. Your document format SHOULD give rules for whitespace stripping.</item></list><heading level="2">8. Key-value pairs</heading><list type="ol"><item>Simple key-value pairs SHOULD be represented with an empty element whose name represents the key, with the value attribute containing the value. Elements that have a value attribute MAY also have a unit attribute to specify the unit of a measured value. For physical measurements, the SI system SHOULD be used. [Rationale: Simplicity and design consistency. Keeping the value in an attribute hides it from the user, since displaying just the value without the key is not useful.]</item><item>If the number of possible keys is very large or unbounded, key-value pairs MAY be represented by a single generic element with key, value, and optional unit and scheme attributes (which serve to discriminate keys from different domains). In that case, also provide (not necessarily in the same document) a list of keys with human-readable explanations.</item></list><heading level="2">9. Binary data</heading><paragraph>Note: There are no hard and fast rules about whether binary data should be included as part of an XML document or not. If it's too large, it's probably better to link to it.</paragraph><list type="ol"><item>Binary data MUST NOT be included directly as-is in XML documents, but MUST be encoded using Base64 encoding. [Rationale: XML does not allow arbitrary binary bytes.]</item><item>The line breaks required by Base64 MAY be omitted. [Rationale: The line breaks are meant to keep plain text lines short, but XML is not really plain text.]</item><item>An attribute named xsi:type with value xs:base64Binary MAY be attached to this element to signal that the Base64 format is in use. [Rationale: Opaque blobs should have decoding instructions attached.]</item></list><heading level="2">10. Processing instructions</heading><list type="ol"><item>New processing instructions MUST NOT be created except in order to specify purely local processing conventions, and SHOULD be avoided altogether. Existing standardized processing instructions MAY be used. [Rationale: Processing instructions fit awkwardly into XML data models and can always be replaced by elements; they exist primarily to avoid breaking backward compatibility.]</item></list><heading level="2">11. Representation of XML document instances</heading><paragraph>Note: These points are only guidelines, as the format of program-created instances will often be outside the programmer's control (for example, when an XML serialization library is being used). In no case should XML parsers rely on these guidelines being followed. Use standard XML parsers, not hand-rolled hacks.</paragraph><list type="ol"><item>The character encoding used SHOULD be UTF-8. Exceptions should require extremely compelling circumstances. [Rationale: UTF-8 is universal and in common use.]</item><item>Namespaces SHOULD be declared in the root element of a document wherever possible. [Rationale: Clarity and consistency.]</item><item>The mapping of namespace URIs to prefixes SHOULD remain constant throughout the document, and SHOULD also be used in documentation of the design. [Rationale: Clarity and consistency.]</item><item>Well-known prefixes such as html: (for XHTML), dc: (for Dublin Core metadata), and xs: (for XML Schema) should be used for standard namespaces. [Rationale: Human readability.]</item><item>Redundant whitespace in a tag SHOULD NOT be used. Use one space before each attribute in a start-tag; if the start tag is too long, the space MAY be replaced by a newline. [Rationale: Consistency and conciseness.]</item><item>Empty elements MAY be expressed as empty tags or a start-tag immediately followed by an end-tag. No distinction should be made between these two formats by any application. [Rationale: They are not distinguished by XML parsers.]</item><item>Documents MAY be pretty-printed using 2-space indentation for child elements. Elements that contain character content SHOULD NOT be wrapped. Long start-tags MAY be broken using newlines (possibly with extra indentation) after any attribute value except the last. [Rationale: General compatibility with our style. Wrapping character content affects its value.]</item><item>Attribute values MAY be surrounded with either quotation marks or apostrophes. Specifications MUST NOT require or forbid the use of either form. &apos; and &quot; may be freely used to escape each type of quote. [Rationale: No XML parsers report the distinction.]</item><item>Comments MUST NOT be used to carry real data. Comments MAY be used to contain TODOs in hand-written XML. Comments SHOULD NOT be used at all in publicly transmitted documents. [Rationale: Comments are often discarded by parsers.]</item><item>If comments are nevertheless used, they SHOULD appear only in the document prolog or in elements that contain child elements. If pretty-printing is required, pretty-print comments like elements, but with line wrapping. Comments SHOULD NOT appear in elements that contain character content. [Rationale: Whitespace in and around comments improves readability, but embedding a comment in character content can lead to confusion about what whitespace is or is not in the content.]</item><item>Comments SHOULD have whitespace following <!-- and preceding -->. [Rationale: Readability.]</item><item>CDATA sections MAY be used; they are equivalent to the use of &amp; and &lt;. Specifications MUST NOT require or forbid the use of CDATA sections. [Rationale: Few XML parsers report the distinction, and combinations of CDATA and text are often reported as single objects anyway.]</item><item>Entity references other than the XML standard entity references &amp;, &lt;, &gt;, &quot;, and &apos; MUST NOT be used. Character references MAY be used, but actual characters are preferred, unless the character encoding is not UTF-8. As usual, textual formats are exempt from this rule.</item></list><heading level="2">12. Elements vs. Attributes</heading><paragraph>Note: There are no hard and fast rules for deciding when to use attributes and when to use elements. Here are some of the considerations that designers should take into account; no rationales are given.</paragraph><heading level="3">12.1. General points:</heading><list type="ol"><item>Attributes are more restrictive than elements, and all designs have some elements, so an all-element design is simplest -- which is not the same as best.</item><item>In a tree-style data model, elements are typically represented internally as nodes, which use more memory than the strings used to represent attributes. Sometimes the nodes are of different application-specific classes, which in many languages also takes up memory to represent the classes.</item><item>When streaming, elements are processed one at a time (possibly even piece by piece, depending on the XML parser you are using), whereas all the attributes of an element and their values are reported at once, which costs memory, particularly if some attribute values are very long.</item><item>Both element content and attribute values need to be escaped appropriately, so escaping should not be a consideration in the design.</item><item>In some programming languages and libraries, processing elements is easier; in others, processing attributes is easier. Beware of using ease of processing as a criterion. In particular, XSLT can handle either with equal facility.</item><item>If a piece of data should usually be shown to the user, consider using an element; if not, consider using an attribute. (This rule is often violated for one reason or another.)</item><item>If you are extending an existing schema, do things by analogy to how things are done in that schema.</item><item>Sensible schema languages, meaning RELAX NG and Schematron, treat elements and attributes symmetrically. Older and cruder schema languages such as DTDs and XML Schema, tend to have better support for elements.</item></list><paragraph>Attributes are more restrictive than elements, and all designs have some elements, so an all-element design is simplest -- which is not the same as best.</paragraph><paragraph>In a tree-style data model, elements are typically represented internally as nodes, which use more memory than the strings used to represent attributes. Sometimes the nodes are of different application-specific classes, which in many languages also takes up memory to represent the classes.</paragraph><paragraph>When streaming, elements are processed one at a time (possibly even piece by piece, depending on the XML parser you are using), whereas all the attributes of an element and their values are reported at once, which costs memory, particularly if some attribute values are very long.</paragraph><paragraph>Both element content and attribute values need to be escaped appropriately, so escaping should not be a consideration in the design.</paragraph><paragraph>In some programming languages and libraries, processing elements is easier; in others, processing attributes is easier. Beware of using ease of processing as a criterion. In particular, XSLT can handle either with equal facility.</paragraph><paragraph>If a piece of data should usually be shown to the user, consider using an element; if not, consider using an attribute. (This rule is often violated for one reason or another.)</paragraph><paragraph>If you are extending an existing schema, do things by analogy to how things are done in that schema.</paragraph><paragraph>Sensible schema languages, meaning RELAX NG and Schematron, treat elements and attributes symmetrically. Older and cruder schema languages such as DTDs and XML Schema, tend to have better support for elements.</paragraph><heading level="3">12.2 Using elements</heading><list type="ol"><item>If something might appear more than once in a data model, use an element rather than introducing attributes with names like foo1, foo2, foo3 ....</item><item>Use elements to represent a piece of information that can be considered an independent object and when the information is related via a parent/child relationship to another piece of information.</item><item>Use elements when data incorporates strict typing or relationship rules.</item><item>If order matters between two pieces of data, use elements for them: attributes are inherently unordered.</item><item>If a piece of data has, or might have, its own substructure, use it in an element: getting substructure into an attribute is always messy. Similarly, if the data is a constituent part of some larger piece of data, put it in an element.</item><item>An exception to the previous rule: multiple whitespace-separated tokens can safely be put in an attribute. In principle, the separator can be anything, but schema-language validators are currently only able to handle whitespace, so it's best to stick with that.</item><item>If a piece of data extends across multiple lines, use an element: XML parsers will change newlines in attribute values into spaces.</item><item>If a piece of data is very large, use an element so that its content can be streamed.</item><item>If a piece of data is in a natural language, put it in an element so you can use the xml:lang attribute to label the language being used. Some kinds of natural-language text, like Japanese, often make use annotations that are conventionally represented using child elements; right-to-left languages like Hebrew and Arabic may similarly require child elements to manage bidirectionality properly.</item></list><paragraph>If something might appear more than once in a data model, use an element rather than introducing attributes with names like foo1, foo2, foo3 ....</paragraph><paragraph>Use elements to represent a piece of information that can be considered an independent object and when the information is related via a parent/child relationship to another piece of information.</paragraph><paragraph>Use elements when data incorporates strict typing or relationship rules.</paragraph><paragraph>If order matters between two pieces of data, use elements for them: attributes are inherently unordered.</paragraph><paragraph>If a piece of data has, or might have, its own substructure, use it in an element: getting substructure into an attribute is always messy. Similarly, if the data is a constituent part of some larger piece of data, put it in an element.</paragraph><paragraph>An exception to the previous rule: multiple whitespace-separated tokens can safely be put in an attribute. In principle, the separator can be anything, but schema-language validators are currently only able to handle whitespace, so it's best to stick with that.</paragraph><paragraph>If a piece of data extends across multiple lines, use an element: XML parsers will change newlines in attribute values into spaces.</paragraph><paragraph>If a piece of data is in a natural language, put it in an element so you can use the xml:lang attribute to label the language being used. Some kinds of natural-language text, like Japanese, often make use annotations that are conventionally represented using child elements; right-to-left languages like Hebrew and Arabic may similarly require child elements to manage bidirectionality properly.</paragraph><heading level="3">12.3 Using attributes</heading><list type="ol"><item>If the data is a code from an enumeration, code list, or controlled vocabulary, put it in an attribute if possible. For example, language tags, currency codes, medical diagnostic codes, etc. are best handled as attributes.</item><item>If a piece of data is really metadata on some other piece of data (for example, representing a class or role that the main data serves, or specifying a method of processing it), put it in an attribute if possible.</item><item>In particular, if a piece of data is an ID for some other piece of data, or a reference to such an ID, put the identifying piece in an attribute. When it's an ID, use the name xml:id for the attribute.</item><item>Hypertext references are conventionally put in href attributes.</item><item>If a piece of data is applicable to an element and any descendant elements unless it is overridden in some of them, it is conventional to put it in an attribute. Well-known examples are xml:lang, xml:space, xml:base, and namespace declarations.</item><item>If terseness is really the most important thing, use attributes, but consider gzip compression instead -- it works very well on documents with highly repetitive structures.</item></list><paragraph>If the data is a code from an enumeration, code list, or controlled vocabulary, put it in an attribute if possible. For example, language tags, currency codes, medical diagnostic codes, etc. are best handled as attributes.</paragraph><paragraph>If a piece of data is really metadata on some other piece of data (for example, representing a class or role that the main data serves, or specifying a method of processing it), put it in an attribute if possible.</paragraph><paragraph>In particular, if a piece of data is an ID for some other piece of data, or a reference to such an ID, put the identifying piece in an attribute. When it's an ID, use the name xml:id for the attribute.</paragraph><paragraph>Hypertext references are conventionally put in href attributes.</paragraph><paragraph>If a piece of data is applicable to an element and any descendant elements unless it is overridden in some of them, it is conventional to put it in an attribute. Well-known examples are xml:lang, xml:space, xml:base, and namespace declarations.</paragraph><paragraph>If terseness is really the most important thing, use attributes, but consider gzip compression instead -- it works very well on documents with highly repetitive structures.</paragraph><heading level="2">13. Parting words</heading><paragraph>Use common sense and BE CONSISTENT. Design for extensibility. You are gonna need it. [Rationale: Long and painful experience.]</paragraph><paragraph>When designing XML formats, take a few minutes to look at other formats and determine their style. The point of having style guidelines is so that people can concentrate on what you are saying, rather than on how you are saying it.</paragraph><paragraph>Break ANY OR ALL of these rules (yes, even the ones that say MUST) rather than create a crude, arbitrary, disgusting mess of a design if that's what following them slavishly would give you. In particular, random mixtures of attributes and child elements are hard to follow and hard to use, though it often makes good sense to use both when the data clearly fall into two different groups such as simple/complex or metadata/data.</paragraph><paragraph>Newbies always ask:</paragraph><paragraph>"Elements or attributes?</paragraph><paragraph>Which will serve me best?"</paragraph><paragraph>Those who know roar like lions;</paragraph><paragraph>Wise hackers smile like tigers.</paragraph><paragraph>--a tanka, or extended haiku</paragraph><paragraph>[TODO: if a registry of schemas is set up, add a link to it]</paragraph></content>
</page>
<page url="https://google.github.io/styleguide/go">
<title>Go Style | styleguide</title>
<content><heading level="1">Go Style</heading><paragraph>https://google.github.io/styleguide/go</paragraph><paragraph>Overview | Guide | Decisions | Best practices</paragraph><heading level="2">About</heading><paragraph>The Go Style Guide and accompanying documents codify the current best approaches for writing readable and idiomatic Go. Adherence to the Style Guide is not intended to be absolute, and these documents will never be exhaustive. Our intention is to minimize the guesswork of writing readable Go so that newcomers to the language can avoid common mistakes. The Style Guide also serves to unify the style guidance given by anyone reviewing Go code at Google.</paragraph><table><thead><tr><th>Document</th><th>Link</th><th>Primary Audience</th><th>Normative</th><th>Canonical</th></tr></thead><tbody><tr><td>Style Guide</td><td>https://google.github.io/styleguide/go/guide</td><td>Everyone</td><td>Yes</td><td>Yes</td></tr><tr><td>Style Decisions</td><td>https://google.github.io/styleguide/go/decisions</td><td>Readability Mentors</td><td>Yes</td><td>No</td></tr><tr><td>Best Practices</td><td>https://google.github.io/styleguide/go/best-practices</td><td>Anyone interested</td><td>No</td><td>No</td></tr></tbody></table><heading level="3">Documents</heading><list type="ol"><item>The Style Guide outlines the foundation of Go style at Google. This document is definitive and is used as the basis for the recommendations in Style Decisions and Best Practices.</item><item>Style Decisions is a more verbose document that summarizes decisions on specific style points and discusses the reasoning behind the decisions where appropriate. These decisions may occasionally change based on new data, new language features, new libraries, or emerging patterns, but it is not expected that individual Go programmers at Google should keep up-to-date with this document.</item><item>Best Practices documents some of the patterns that have evolved over time that solve common problems, read well, and are robust to code maintenance needs. These best practices are not canonical, but Go programmers at Google are encouraged to use them where possible to keep the codebase uniform and consistent.</item></list><paragraph>The Style Guide outlines the foundation of Go style at Google. This document is definitive and is used as the basis for the recommendations in Style Decisions and Best Practices.</paragraph><paragraph>Style Decisions is a more verbose document that summarizes decisions on specific style points and discusses the reasoning behind the decisions where appropriate.</paragraph><paragraph>These decisions may occasionally change based on new data, new language features, new libraries, or emerging patterns, but it is not expected that individual Go programmers at Google should keep up-to-date with this document.</paragraph><paragraph>Best Practices documents some of the patterns that have evolved over time that solve common problems, read well, and are robust to code maintenance needs.</paragraph><paragraph>These best practices are not canonical, but Go programmers at Google are encouraged to use them where possible to keep the codebase uniform and consistent.</paragraph><paragraph>These documents intend to:</paragraph><list type="ul"><item>Agree on a set of principles for weighing alternate styles</item><item>Codify settled matters of Go style</item><item>Document and provide canonical examples for Go idioms</item><item>Document the pros and cons of various style decisions</item><item>Help minimize surprises in Go readability reviews</item><item>Help readability mentors use consistent terminology and guidance</item></list><paragraph>These documents do not intend to:</paragraph><list type="ul"><item>Be an exhaustive list of comments that can be given in a readability review</item><item>List all of the rules everyone is expected to remember and follow at all times</item><item>Replace good judgment in the use of language features and style</item><item>Justify large-scale changes to get rid of style differences</item></list><paragraph>There will always be differences from one Go programmer to another and from one team's codebase to another. However, it is in the best interest of Google and Alphabet that our codebase be as consistent as possible. (See guide for more on consistency.) To that end, feel free to make style improvements as you see fit, but you do not need to nit-pick every violation of the Style Guide that you find. In particular, these documents may change over time, and that is no reason to cause extra churn in existing codebases; it suffices to write new code using the latest best practices and address nearby issues over time.</paragraph><paragraph>It is important to recognize that issues of style are inherently personal and that there are always inherent trade-offs. Much of the guidance in these documents is subjective, but just like with gofmt, there is significant value in the uniformity they provide. As such, style recommendations will not be changed without due discourse, Go programmers at Google are encouraged to follow the style guide even where they might disagree.</paragraph><heading level="2">Definitions</heading><paragraph>The following words, which are used throughout the style documents, are defined below:</paragraph><list type="ul"><item>Canonical: Establishes prescriptive and enduring rules Within these documents, "canonical" is used to describe something that is considered a standard that all code (old and new) should follow and that is not expected to change substantially over time. Principles in the canonical documents should be understood by authors and reviewers alike, so everything included within a canonical document must meet a high bar. As such, canonical documents are generally shorter and prescribe fewer elements of style than non-canonical documents. https://google.github.io/styleguide/go#canonical</item><item>Normative: Intended to establish consistency Within these documents, "normative" is used to describe something that is an agreed-upon element of style for use by Go code reviewers, in order that the suggestions, terminology, and justifications are consistent. These elements may change over time, and these documents will reflect such changes so that reviewers can remain consistent and up-to-date. Authors of Go code are not expected to be familiar with the normative documents, but the documents will frequently be used as a reference by reviewers in readability reviews. https://google.github.io/styleguide/go#normative</item><item>Idiomatic: Common and familiar Within these documents, "idiomatic" is used to refer to something that is prevalent in Go code and has become a familiar pattern that is easy to recognize. In general, an idiomatic pattern should be preferred to something unidiomatic if both serve the same purpose in context, as this is what will be the most familiar to readers. https://google.github.io/styleguide/go#idiomatic</item></list><paragraph>Canonical: Establishes prescriptive and enduring rules</paragraph><paragraph>Within these documents, "canonical" is used to describe something that is considered a standard that all code (old and new) should follow and that is not expected to change substantially over time. Principles in the canonical documents should be understood by authors and reviewers alike, so everything included within a canonical document must meet a high bar. As such, canonical documents are generally shorter and prescribe fewer elements of style than non-canonical documents.</paragraph><paragraph>https://google.github.io/styleguide/go#canonical</paragraph><paragraph>Normative: Intended to establish consistency</paragraph><paragraph>Within these documents, "normative" is used to describe something that is an agreed-upon element of style for use by Go code reviewers, in order that the suggestions, terminology, and justifications are consistent. These elements may change over time, and these documents will reflect such changes so that reviewers can remain consistent and up-to-date. Authors of Go code are not expected to be familiar with the normative documents, but the documents will frequently be used as a reference by reviewers in readability reviews.</paragraph><paragraph>https://google.github.io/styleguide/go#normative</paragraph><paragraph>Idiomatic: Common and familiar</paragraph><paragraph>Within these documents, "idiomatic" is used to refer to something that is prevalent in Go code and has become a familiar pattern that is easy to recognize. In general, an idiomatic pattern should be preferred to something unidiomatic if both serve the same purpose in context, as this is what will be the most familiar to readers.</paragraph><paragraph>https://google.github.io/styleguide/go#idiomatic</paragraph><heading level="2">Additional references</heading><paragraph>This guide assumes the reader is familiar with Effective Go, as it provides a common baseline for Go code across the entire Go community.</paragraph><paragraph>Below are some additional resources for those looking to self-educate about Go style and for reviewers looking to provide further linkable context in their reviews. Participants in the Go readability process are not expected to be familiar with these resources, but they may arise as context in readability reviews.</paragraph><paragraph>External References</paragraph><paragraph>Relevant Testing-on-the-Toilet articles</paragraph><paragraph>Additional External Writings</paragraph></content>
</page>
<page url="https://google.github.io/styleguide/go/index.html">
<title>Go Style | styleguide</title>
<content><heading level="1">Go Style</heading><paragraph>https://google.github.io/styleguide/go</paragraph><paragraph>Overview | Guide | Decisions | Best practices</paragraph><heading level="2">About</heading><paragraph>The Go Style Guide and accompanying documents codify the current best approaches for writing readable and idiomatic Go. Adherence to the Style Guide is not intended to be absolute, and these documents will never be exhaustive. Our intention is to minimize the guesswork of writing readable Go so that newcomers to the language can avoid common mistakes. The Style Guide also serves to unify the style guidance given by anyone reviewing Go code at Google.</paragraph><table><thead><tr><th>Document</th><th>Link</th><th>Primary Audience</th><th>Normative</th><th>Canonical</th></tr></thead><tbody><tr><td>Style Guide</td><td>https://google.github.io/styleguide/go/guide</td><td>Everyone</td><td>Yes</td><td>Yes</td></tr><tr><td>Style Decisions</td><td>https://google.github.io/styleguide/go/decisions</td><td>Readability Mentors</td><td>Yes</td><td>No</td></tr><tr><td>Best Practices</td><td>https://google.github.io/styleguide/go/best-practices</td><td>Anyone interested</td><td>No</td><td>No</td></tr></tbody></table><heading level="3">Documents</heading><list type="ol"><item>The Style Guide outlines the foundation of Go style at Google. This document is definitive and is used as the basis for the recommendations in Style Decisions and Best Practices.</item><item>Style Decisions is a more verbose document that summarizes decisions on specific style points and discusses the reasoning behind the decisions where appropriate. These decisions may occasionally change based on new data, new language features, new libraries, or emerging patterns, but it is not expected that individual Go programmers at Google should keep up-to-date with this document.</item><item>Best Practices documents some of the patterns that have evolved over time that solve common problems, read well, and are robust to code maintenance needs. These best practices are not canonical, but Go programmers at Google are encouraged to use them where possible to keep the codebase uniform and consistent.</item></list><paragraph>The Style Guide outlines the foundation of Go style at Google. This document is definitive and is used as the basis for the recommendations in Style Decisions and Best Practices.</paragraph><paragraph>Style Decisions is a more verbose document that summarizes decisions on specific style points and discusses the reasoning behind the decisions where appropriate.</paragraph><paragraph>These decisions may occasionally change based on new data, new language features, new libraries, or emerging patterns, but it is not expected that individual Go programmers at Google should keep up-to-date with this document.</paragraph><paragraph>Best Practices documents some of the patterns that have evolved over time that solve common problems, read well, and are robust to code maintenance needs.</paragraph><paragraph>These best practices are not canonical, but Go programmers at Google are encouraged to use them where possible to keep the codebase uniform and consistent.</paragraph><paragraph>These documents intend to:</paragraph><list type="ul"><item>Agree on a set of principles for weighing alternate styles</item><item>Codify settled matters of Go style</item><item>Document and provide canonical examples for Go idioms</item><item>Document the pros and cons of various style decisions</item><item>Help minimize surprises in Go readability reviews</item><item>Help readability mentors use consistent terminology and guidance</item></list><paragraph>These documents do not intend to:</paragraph><list type="ul"><item>Be an exhaustive list of comments that can be given in a readability review</item><item>List all of the rules everyone is expected to remember and follow at all times</item><item>Replace good judgment in the use of language features and style</item><item>Justify large-scale changes to get rid of style differences</item></list><paragraph>There will always be differences from one Go programmer to another and from one team's codebase to another. However, it is in the best interest of Google and Alphabet that our codebase be as consistent as possible. (See guide for more on consistency.) To that end, feel free to make style improvements as you see fit, but you do not need to nit-pick every violation of the Style Guide that you find. In particular, these documents may change over time, and that is no reason to cause extra churn in existing codebases; it suffices to write new code using the latest best practices and address nearby issues over time.</paragraph><paragraph>It is important to recognize that issues of style are inherently personal and that there are always inherent trade-offs. Much of the guidance in these documents is subjective, but just like with gofmt, there is significant value in the uniformity they provide. As such, style recommendations will not be changed without due discourse, Go programmers at Google are encouraged to follow the style guide even where they might disagree.</paragraph><heading level="2">Definitions</heading><paragraph>The following words, which are used throughout the style documents, are defined below:</paragraph><list type="ul"><item>Canonical: Establishes prescriptive and enduring rules Within these documents, "canonical" is used to describe something that is considered a standard that all code (old and new) should follow and that is not expected to change substantially over time. Principles in the canonical documents should be understood by authors and reviewers alike, so everything included within a canonical document must meet a high bar. As such, canonical documents are generally shorter and prescribe fewer elements of style than non-canonical documents. https://google.github.io/styleguide/go#canonical</item><item>Normative: Intended to establish consistency Within these documents, "normative" is used to describe something that is an agreed-upon element of style for use by Go code reviewers, in order that the suggestions, terminology, and justifications are consistent. These elements may change over time, and these documents will reflect such changes so that reviewers can remain consistent and up-to-date. Authors of Go code are not expected to be familiar with the normative documents, but the documents will frequently be used as a reference by reviewers in readability reviews. https://google.github.io/styleguide/go#normative</item><item>Idiomatic: Common and familiar Within these documents, "idiomatic" is used to refer to something that is prevalent in Go code and has become a familiar pattern that is easy to recognize. In general, an idiomatic pattern should be preferred to something unidiomatic if both serve the same purpose in context, as this is what will be the most familiar to readers. https://google.github.io/styleguide/go#idiomatic</item></list><paragraph>Canonical: Establishes prescriptive and enduring rules</paragraph><paragraph>Within these documents, "canonical" is used to describe something that is considered a standard that all code (old and new) should follow and that is not expected to change substantially over time. Principles in the canonical documents should be understood by authors and reviewers alike, so everything included within a canonical document must meet a high bar. As such, canonical documents are generally shorter and prescribe fewer elements of style than non-canonical documents.</paragraph><paragraph>https://google.github.io/styleguide/go#canonical</paragraph><paragraph>Normative: Intended to establish consistency</paragraph><paragraph>Within these documents, "normative" is used to describe something that is an agreed-upon element of style for use by Go code reviewers, in order that the suggestions, terminology, and justifications are consistent. These elements may change over time, and these documents will reflect such changes so that reviewers can remain consistent and up-to-date. Authors of Go code are not expected to be familiar with the normative documents, but the documents will frequently be used as a reference by reviewers in readability reviews.</paragraph><paragraph>https://google.github.io/styleguide/go#normative</paragraph><paragraph>Idiomatic: Common and familiar</paragraph><paragraph>Within these documents, "idiomatic" is used to refer to something that is prevalent in Go code and has become a familiar pattern that is easy to recognize. In general, an idiomatic pattern should be preferred to something unidiomatic if both serve the same purpose in context, as this is what will be the most familiar to readers.</paragraph><paragraph>https://google.github.io/styleguide/go#idiomatic</paragraph><heading level="2">Additional references</heading><paragraph>This guide assumes the reader is familiar with Effective Go, as it provides a common baseline for Go code across the entire Go community.</paragraph><paragraph>Below are some additional resources for those looking to self-educate about Go style and for reviewers looking to provide further linkable context in their reviews. Participants in the Go readability process are not expected to be familiar with these resources, but they may arise as context in readability reviews.</paragraph><paragraph>External References</paragraph><paragraph>Relevant Testing-on-the-Toilet articles</paragraph><paragraph>Additional External Writings</paragraph></content>
</page>
<page url="https://google.github.io/styleguide/go/best-practices.html">
<title>styleguide | Style guides for Google-originated open-source projects</title>
<content><heading level="1">Go Style Best Practices</heading><paragraph>https://google.github.io/styleguide/go/best-practices</paragraph><paragraph>Overview | Guide | Decisions | Best practices</paragraph><paragraph>Note: This is part of a series of documents that outline Go Style at Google. This document is neither normative nor canonical, and is an auxiliary document to the core style guide. See the overview for more information.</paragraph><heading level="2">About</heading><paragraph>This file documents guidance about how to best apply the Go Style Guide. This guidance is intended for common situations that arise frequently, but may not apply in every circumstance. Where possible, multiple alternative approaches are discussed along with the considerations that go into the decision about when and when not to apply them.</paragraph><paragraph>See the overview for the full set of Style Guide documents.</paragraph><heading level="2">Naming</heading><heading level="3">Function and method names</heading><heading level="4">Avoid repetition</heading><paragraph>When choosing the name for a function or method, consider the context in which the name will be read. Consider the following recommendations to avoid excess repetition at the call site:</paragraph><list type="ul"><item>The following can generally be omitted from function and method names: The types of the inputs and outputs (when there is no collision) The type of a method's receiver Whether an input or output is a pointer</item><item>For functions, do not repeat the name of the package. // Bad: package yamlconfig func ParseYAMLConfig(input string) (*Config, error) // Good: package yamlconfig func Parse(input string) (*Config, error)</item><item>For methods, do not repeat the name of the method receiver. // Bad: func (c *Config) WriteConfigTo(w io.Writer) (int64, error) // Good: func (c *Config) WriteTo(w io.Writer) (int64, error)</item><item>Do not repeat the names of variables passed as parameters. // Bad: func OverrideFirstWithSecond(dest, source *Config) error // Good: func Override(dest, source *Config) error</item><item>Do not repeat the names and types of the return values. // Bad: func TransformToJSON(input *Config) *jsonconfig.Config // Good: func Transform(input *Config) *jsonconfig.Config</item></list><paragraph>The following can generally be omitted from function and method names:</paragraph><list type="ul"><item>The types of the inputs and outputs (when there is no collision)</item><item>The type of a method's receiver</item><item>Whether an input or output is a pointer</item></list><paragraph>For functions, do not repeat the name of the package.</paragraph><code language="go">// Bad:
package yamlconfig

func ParseYAMLConfig(input string) (*Config, error)
</code><code language="go">// Good:
package yamlconfig

func Parse(input string) (*Config, error)
</code><paragraph>For methods, do not repeat the name of the method receiver.</paragraph><code language="code">// Bad:
func (c *Config) WriteConfigTo(w io.Writer) (int64, error)
</code><code language="code">// Good:
func (c *Config) WriteTo(w io.Writer) (int64, error)
</code><paragraph>Do not repeat the names of variables passed as parameters.</paragraph><code language="go">// Bad:
func OverrideFirstWithSecond(dest, source *Config) error
</code><code language="go">// Good:
func Override(dest, source *Config) error
</code><paragraph>Do not repeat the names and types of the return values.</paragraph><code language="go">// Bad:
func TransformToJSON(input *Config) *jsonconfig.Config
</code><code language="go">// Good:
func Transform(input *Config) *jsonconfig.Config
</code><paragraph>When it is necessary to disambiguate functions of a similar name, it is acceptable to include extra information.</paragraph><code language="code">// Good:
func (c *Config) WriteTextTo(w io.Writer) (int64, error)
func (c *Config) WriteBinaryTo(w io.Writer) (int64, error)
</code><heading level="4">Naming conventions</heading><paragraph>There are some other common conventions when choosing names for functions and methods:</paragraph><list type="ul"><item>Functions that return something are given noun-like names. // Good: func (c *Config) JobName(key string) (value string, ok bool) A corollary of this is that function and method names should avoid the prefix Get. // Bad: func (c *Config) GetJobName(key string) (value string, ok bool)</item><item>Functions that do something are given verb-like names. // Good: func (c *Config) WriteDetail(w io.Writer) (int64, error)</item><item>Identical functions that differ only by the types involved include the name of the type at the end of the name. // Good: func ParseInt(input string) (int, error) func ParseInt64(input string) (int64, error) func AppendInt(buf []byte, value int) []byte func AppendInt64(buf []byte, value int64) []byte If there is a clear "primary" version, the type can be omitted from the name for that version: // Good: func (c *Config) Marshal() ([]byte, error) func (c *Config) MarshalText() (string, error)</item></list><paragraph>Functions that return something are given noun-like names.</paragraph><code language="code">// Good:
func (c *Config) JobName(key string) (value string, ok bool)
</code><paragraph>A corollary of this is that function and method names should avoid the prefix Get.</paragraph><code language="code">// Bad:
func (c *Config) GetJobName(key string) (value string, ok bool)
</code><paragraph>Functions that do something are given verb-like names.</paragraph><code language="code">// Good:
func (c *Config) WriteDetail(w io.Writer) (int64, error)
</code><paragraph>Identical functions that differ only by the types involved include the name of the type at the end of the name.</paragraph><code language="go">// Good:
func ParseInt(input string) (int, error)
func ParseInt64(input string) (int64, error)
func AppendInt(buf []byte, value int) []byte
func AppendInt64(buf []byte, value int64) []byte
</code><paragraph>If there is a clear "primary" version, the type can be omitted from the name for that version:</paragraph><code language="code">// Good:
func (c *Config) Marshal() ([]byte, error)
func (c *Config) MarshalText() (string, error)
</code><heading level="3">Test double and helper packages</heading><paragraph>There are several disciplines you can apply to naming packages and types that provide test helpers and especially test doubles. A test double could be a stub, fake, mock, or spy.</paragraph><paragraph>These examples mostly use stubs. Update your names accordingly if your code uses fakes or another kind of test double.</paragraph><paragraph>Suppose you have a well-focused package providing production code similar to this:</paragraph><code language="javascript">package creditcard

import (
    "errors"

    "path/to/money"
)

// ErrDeclined indicates that the issuer declines the charge.
var ErrDeclined = errors.New("creditcard: declined")

// Card contains information about a credit card, such as its issuer,
// expiration, and limit.
type Card struct {
    // omitted
}

// Service allows you to perform operations with credit cards against external
// payment processor vendors like charge, authorize, reimburse, and subscribe.
type Service struct {
    // omitted
}

func (s *Service) Charge(c *Card, amount money.Money) error { /* omitted */ }
</code><heading level="4">Creating test helper packages</heading><paragraph>Suppose you want to create a package that contains test doubles for another. We'll use package creditcard (from above) for this example:</paragraph><paragraph>One approach is to introduce a new Go package based on the production one for testing. A safe choice is to append the word test to the original package name ("creditcard" + "test"):</paragraph><code language="code">// Good:
package creditcardtest
</code><paragraph>Unless stated explicitly otherwise, all examples in the sections below are in package creditcardtest.</paragraph><heading level="4">Simple case</heading><paragraph>You want to add a set of test doubles for Service. Because Card is effectively a dumb data type, similar to a Protocol Buffer message, it needs no special treatment in tests, so no double is required. If you anticipate only test doubles for one type (like Service), you can take a concise approach to naming the doubles:</paragraph><code language="javascript">// Good:
import (
    "path/to/creditcard"
    "path/to/money"
)

// Stub stubs creditcard.Service and provides no behavior of its own.
type Stub struct{}

func (Stub) Charge(*creditcard.Card, money.Money) error { return nil }
</code><paragraph>This is strictly preferable to a naming choice like StubService or the very poor StubCreditCardService, because the base package name and its domain types imply what creditcardtest.Stub is.</paragraph><paragraph>Finally, if the package is built with Bazel, make sure the new go_library rule for the package is marked as testonly:</paragraph><code language="code"># Good:
go_library(
    name = "creditcardtest",
    srcs = ["creditcardtest.go"],
    deps = [
        ":creditcard",
        ":money",
    ],
    testonly = True,
)
</code><paragraph>The approach above is conventional and will be reasonably well understood by other engineers.</paragraph><paragraph>See also:</paragraph><heading level="4">Multiple test double behaviors</heading><paragraph>When one kind of stub is not enough (for example, you also need one that always fails), we recommend naming the stubs according to the behavior they emulate. Here we rename Stub to AlwaysCharges and introduce a new stub called AlwaysDeclines:</paragraph><code language="javascript">// Good:
// AlwaysCharges stubs creditcard.Service and simulates success.
type AlwaysCharges struct{}

func (AlwaysCharges) Charge(*creditcard.Card, money.Money) error { return nil }

// AlwaysDeclines stubs creditcard.Service and simulates declined charges.
type AlwaysDeclines struct{}

func (AlwaysDeclines) Charge(*creditcard.Card, money.Money) error {
    return creditcard.ErrDeclined
}
</code><heading level="4">Multiple doubles for multiple types</heading><paragraph>But now suppose that package creditcard contains multiple types worth creating doubles for, as seen below with Service and StoredValue:</paragraph><code language="javascript">package creditcard

type Service struct {
    // omitted
}

type Card struct {
    // omitted
}

// StoredValue manages customer credit balances.  This applies when returned
// merchandise is credited to a customer's local account instead of processed
// by the credit issuer.  For this reason, it is implemented as a separate
// service.
type StoredValue struct {
    // omitted
}

func (s *StoredValue) Credit(c *Card, amount money.Money) error { /* omitted */ }
</code><paragraph>In this case, more explicit test double naming is sensible:</paragraph><code language="code">// Good:
type StubService struct{}

func (StubService) Charge(*creditcard.Card, money.Money) error { return nil }

type StubStoredValue struct{}

func (StubStoredValue) Credit(*creditcard.Card, money.Money) error { return nil }
</code><heading level="4">Local variables in tests</heading><paragraph>When variables in your tests refer to doubles, choose a name that most clearly differentiates the double from other production types based on context. Consider some production code you want to test:</paragraph><code language="javascript">package payment

import (
    "path/to/creditcard"
    "path/to/money"
)

type CreditCard interface {
    Charge(*creditcard.Card, money.Money) error
}

type Processor struct {
    CC CreditCard
}

var ErrBadInstrument = errors.New("payment: instrument is invalid or expired")

func (p *Processor) Process(c *creditcard.Card, amount money.Money) error {
    if c.Expired() {
        return ErrBadInstrument
    }
    return p.CC.Charge(c, amount)
}
</code><paragraph>In the tests, a test double called a "spy" for CreditCard is juxtaposed against production types, so prefixing the name may improve clarity.</paragraph><code language="javascript">// Good:
package payment

import "path/to/creditcardtest"

func TestProcessor(t *testing.T) {
    var spyCC creditcardtest.Spy
    proc := &Processor{CC: spyCC}

    // declarations omitted: card and amount
    if err := proc.Process(card, amount); err != nil {
        t.Errorf("proc.Process(card, amount) = %v, want nil", err)
    }

    charges := []creditcardtest.Charge{
        {Card: card, Amount: amount},
    }

    if got, want := spyCC.Charges, charges; !cmp.Equal(got, want) {
        t.Errorf("spyCC.Charges = %v, want %v", got, want)
    }
}
</code><paragraph>This is clearer than when the name is not prefixed.</paragraph><code language="javascript">// Bad:
package payment

import "path/to/creditcardtest"

func TestProcessor(t *testing.T) {
    var cc creditcardtest.Spy

    proc := &Processor{CC: cc}

    // declarations omitted: card and amount
    if err := proc.Process(card, amount); err != nil {
        t.Errorf("proc.Process(card, amount) = %v, want nil", err)
    }

    charges := []creditcardtest.Charge{
        {Card: card, Amount: amount},
    }

    if got, want := cc.Charges, charges; !cmp.Equal(got, want) {
        t.Errorf("cc.Charges = %v, want %v", got, want)
    }
}
</code><heading level="3">Shadowing</heading><paragraph>Note: This explanation uses two informal terms, stomping and shadowing. They are not official concepts in the Go language spec.</paragraph><paragraph>Like many programming languages, Go has mutable variables: assigning to a variable changes its value.</paragraph><code language="javascript">// Good:
func abs(i int) int {
    if i < 0 {
        i *= -1
    }
    return i
}
</code><paragraph>When using short variable declarations with the := operator, in some cases a new variable is not created. We can call this stomping. It's OK to do this when the original value is no longer needed.</paragraph><code language="javascript">// Good:
// innerHandler is a helper for some request handler, which itself issues
// requests to other backends.
func (s *Server) innerHandler(ctx context.Context, req *pb.MyRequest) *pb.MyResponse {
    // Unconditionally cap the deadline for this part of request handling.
    ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
    defer cancel()
    ctxlog.Info(ctx, "Capped deadline in inner request")

    // Code here no longer has access to the original context.
    // This is good style if when first writing this, you anticipate
    // that even as the code grows, no operation legitimately should
    // use the (possibly unbounded) original context that the caller provided.

    // ...
}
</code><paragraph>Be careful using short variable declarations in a new scope, though: that introduces a new variable. We can call this shadowing the original variable. Code after the end of the block refers to the original. Here is a buggy attempt to shorten the deadline conditionally:</paragraph><code language="javascript">// Bad:
func (s *Server) innerHandler(ctx context.Context, req *pb.MyRequest) *pb.MyResponse {
    // Attempt to conditionally cap the deadline.
    if *shortenDeadlines {
        ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
        defer cancel()
        ctxlog.Info(ctx, "Capped deadline in inner request")
    }

    // BUG: "ctx" here again means the context that the caller provided.
    // The above buggy code compiled because both ctx and cancel
    // were used inside the if statement.

    // ...
}
</code><paragraph>A correct version of the code might be:</paragraph><code language="javascript">// Good:
func (s *Server) innerHandler(ctx context.Context, req *pb.MyRequest) *pb.MyResponse {
    if *shortenDeadlines {
        var cancel func()
        // Note the use of simple assignment, = and not :=.
        ctx, cancel = context.WithTimeout(ctx, 3*time.Second)
        defer cancel()
        ctxlog.Info(ctx, "Capped deadline in inner request")
    }
    // ...
}
</code><paragraph>In the case we called stomping, because there's no new variable, the type being assigned must match that of the original variable. With shadowing, an entirely new entity is introduced so it can have a different type. Intentional shadowing can be a useful practice, but you can always use a new name if it improves clarity.</paragraph><paragraph>It is not a good idea to use variables with the same name as standard packages other than very small scopes, because that renders free functions and values from that package inaccessible. Conversely, when picking a name for your package, avoid names that are likely to require import renaming or cause shadowing of otherwise good variable names at the client side.</paragraph><code language="javascript">// Bad:
func LongFunction() {
    url := "https://example.com/"
    // Oops, now we can't use net/url in code below.
}
</code><heading level="3">Util packages</heading><paragraph>Go packages have a name specified on the package declaration, separate from the import path. The package name matters more for readability than the path.</paragraph><paragraph>Go package names should be related to what the package provides. Naming a package just util, helper, common or similar is usually a poor choice (it can be used as part of the name though). Uninformative names make the code harder to read, and if used too broadly they are liable to cause needless import conflicts.</paragraph><paragraph>Instead, consider what the callsite will look like.</paragraph><code language="code">// Good:
db := spannertest.NewDatabaseFromFile(...)

_, err := f.Seek(0, io.SeekStart)

b := elliptic.Marshal(curve, x, y)
</code><paragraph>You can tell roughly what each of these do even without knowing the imports list (cloud.google.com/go/spanner/spannertest, io, and crypto/elliptic). With less focused names, these might read:</paragraph><code language="code">// Bad:
db := test.NewDatabaseFromFile(...)

_, err := f.Seek(0, common.SeekStart)

b := helper.Marshal(curve, x, y)
</code><heading level="2">Package size</heading><paragraph>If you're asking yourself how big your Go packages should be and whether to place related types in the same package or split them into different ones, a good place to start is the Go blog post about package names. Despite the post title, it's not solely about naming. It contains some helpful hints and cites several useful articles and talks.</paragraph><paragraph>Here are some other considerations and notes.</paragraph><paragraph>Users see godoc for the package in one page, and any methods exported by types supplied by the package are grouped by their type. Godoc also group constructors along with the types they return. If client code is likely to need two values of different type to interact with each other, it may be convenient for the user to have them in the same package.</paragraph><paragraph>Code within a package can access unexported identifiers in the package. If you have a few related types whose implementation is tightly coupled, placing them in the same package lets you achieve this coupling without polluting the public API with these details. A good test for this coupling is to imagine a hypothetical user of two packages, where the packages cover closely related topics: if the user must import both packages in order to use either in any meaningful way, combining them together is usually the right thing to do. The standard library generally demonstrates this kind of scoping and layering well.</paragraph><paragraph>All of that being said, putting your entire project in a single package would likely make that package too large. When something is conceptually distinct, giving it its own small package can make it easier to use. The short name of the package as known to clients together with the exported type name work together to make a meaningful identifier: e.g. bytes.Buffer, ring.New. The Package Names blog post has more examples.</paragraph><paragraph>Go style is flexible about file size, because maintainers can move code within a package from one file to another without affecting callers. But as a general guideline: it is usually not a good idea to have a single file with many thousands of lines in it, or having many tiny files. There is no "one type, one file" convention as in some other languages. As a rule of thumb, files should be focused enough that a maintainer can tell which file contains something, and the files should be small enough that it will be easy to find once there. The standard library often splits large packages to several source files, grouping related code by file. The source for package bytes is a good example. Packages with long package documentation may choose to dedicate one file called doc.go that has the package documentation, a package declaration, and nothing else, but this is not required.</paragraph><paragraph>Within the Google codebase and in projects using Bazel, directory layout for Go code is different than it is in open source Go projects: you can have multiple go_library targets in a single directory. A good reason to give each package its own directory is if you expect to open source your project in the future.</paragraph><paragraph>A few non-canonical reference examples to help demonstrate these ideas in action:</paragraph><list type="ul"><item>small packages that contain one cohesive idea that warrant nothing more being added nor nothing being removed:</item><item>moderately sized packages that contain one large domain and its multiple responsibilities together:</item><item>large packages that divide several closely related domains across several files:</item></list><paragraph>small packages that contain one cohesive idea that warrant nothing more being added nor nothing being removed:</paragraph><paragraph>moderately sized packages that contain one large domain and its multiple responsibilities together:</paragraph><paragraph>large packages that divide several closely related domains across several files:</paragraph><paragraph>See also:</paragraph><heading level="2">Imports</heading><heading level="3">Protocol Buffer Messages and Stubs</heading><paragraph>Proto library imports are treated differently than standard Go imports due to their cross-language nature. The convention for renamed proto imports are based on the rule that generated the package:</paragraph><list type="ul"><item>The pb suffix is generally used for go_proto_library rules.</item><item>The grpc suffix is generally used for go_grpc_library rules.</item></list><paragraph>Often a single word describing the package is used:</paragraph><code language="javascript">// Good:
import (
    foopb "path/to/package/foo_service_go_proto"
    foogrpc "path/to/package/foo_service_go_grpc"
)
</code><paragraph>Follow the style guidance for package names. Prefer whole words. Short names are good, but avoid ambiguity. When in doubt, use the proto package name up to _go with a pb suffix:</paragraph><code language="javascript">// Good:
import (
    pushqueueservicepb "path/to/package/push_queue_service_go_proto"
)
</code><paragraph>Note: Previous guidance encouraged very short names such as "xpb" or even just "pb". New code should prefer more descriptive names. Existing code which uses short names should not be used as an example, but does not need to be changed.</paragraph><heading level="3">Import ordering</heading><paragraph>Imports are typically grouped into the following two (or more) blocks, in order:</paragraph><list type="ol"><item>Standard library imports (e.g., "fmt")</item><item>imports (e.g., "/path/to/somelib")</item><item>(optional) Protobuf imports (e.g., fpb "path/to/foo_go_proto")</item><item>(optional) Side-effect imports (e.g., _ "path/to/package")</item></list><paragraph>If a file does not have a group for one of the optional categories above, the relevant imports are included in the project import group.</paragraph><paragraph>Any import grouping that is clear and easy to understand is generally fine. For example, a team may choose to group gRPC imports separately from protobuf imports.</paragraph><paragraph>Note: For code maintaining only the two mandatory groups (one group for the standard library and one for all other imports), the goimports tool produces output consistent with this guidance.</paragraph><paragraph>However, goimports has no knowledge of groups beyond the mandatory ones; the optional groups are prone to invalidation by the tool. When optional groups are used, attention on the part of both authors and reviewers is required to ensure that groupings remain compliant.</paragraph><paragraph>Either approach is fine, but do not leave the imports section in an inconsistent, partially grouped state.</paragraph><heading level="2">Error handling</heading><paragraph>In Go, errors are values; they are created by code and consumed by code. Errors can be:</paragraph><list type="ul"><item>Converted into diagnostic information for display to humans</item><item>Used by the maintainer</item><item>Interpreted by an end user</item></list><paragraph>Error messages also show up across a variety of different surfaces including log messages, error dumps, and rendered UIs.</paragraph><paragraph>Code that processes (produces or consumes) errors should do so deliberately. It can be tempting to ignore or blindly propagate an error return value. However, it is always worth considering whether the current function in the call frame is positioned to handle the error most effectively. This is a large topic and it is hard to give categorical advice. Use your judgment, but keep the following considerations in mind:</paragraph><list type="ul"><item>When creating an error value, decide whether to give it any structure.</item><item>When handling an error, consider adding information that you have but that the caller and/or callee might not.</item><item>See also guidance on error logging.</item></list><paragraph>While it is usually not appropriate to ignore an error, a reasonable exception to this is when orchestrating related operations, where often only the first error is useful. Package errgroup provides a convenient abstraction for a group of operations that can all fail or be canceled as a group.</paragraph><paragraph>See also:</paragraph><heading level="3">Error structure</heading><paragraph>If callers need to interrogate the error (e.g., distinguish different error conditions), give the error value structure so that this can be done programmatically rather than having the caller perform string matching. This advice applies to production code as well as to tests that care about different error conditions.</paragraph><paragraph>The simplest structured errors are unparameterized global values.</paragraph><code language="javascript">type Animal string

var (
    // ErrDuplicate occurs if this animal has already been seen.
    ErrDuplicate = errors.New("duplicate")

    // ErrMarsupial occurs because we're allergic to marsupials outside Australia.
    // Sorry.
    ErrMarsupial = errors.New("marsupials are not supported")
)

func process(animal Animal) error {
    switch {
    case seen[animal]:
        return ErrDuplicate
    case marsupial(animal):
        return ErrMarsupial
    }
    seen[animal] = true
    // ...
    return nil
}
</code><paragraph>The caller can simply compare the returned error value of the function with one of the known error values:</paragraph><code language="javascript">// Good:
func handlePet(...) {
    switch err := process(an); err {
    case ErrDuplicate:
        return fmt.Errorf("feed %q: %v", an, err)
    case ErrMarsupial:
        // Try to recover with a friend instead.
        alternate = an.BackupAnimal()
        return handlePet(..., alternate, ...)
    }
}
</code><paragraph>The above uses sentinel values, where the error must be equal (in the sense of ==) to the expected value. That is perfectly adequate in many cases. If process returns wrapped errors (discussed below), you can use errors.Is.</paragraph><code language="javascript">// Good:
func handlePet(...) {
    switch err := process(an); {
    case errors.Is(err, ErrDuplicate):
        return fmt.Errorf("feed %q: %v", an, err)
    case errors.Is(err, ErrMarsupial):
        // ...
    }
}
</code><paragraph>Do not attempt to distinguish errors based on their string form. (See Go Tip #13: Designing Errors for Checking for more.)</paragraph><code language="javascript">// Bad:
func handlePet(...) {
    err := process(an)
    if regexp.MatchString(`duplicate`, err.Error()) {...}
    if regexp.MatchString(`marsupial`, err.Error()) {...}
}
</code><paragraph>If there is extra information in the error that the caller needs programmatically, it should ideally be presented structurally. For example, the os.PathError type is documented to place the pathname of the failing operation in a struct field which the caller can easily access.</paragraph><paragraph>Other error structures can be used as appropriate, for example a project struct containing an error code and detail string. Package status is a common encapsulation; if you choose this approach (which you are not obligated to do), use canonical codes. See Go Tip #89: When to Use Canonical Status Codes as Errors to know if using status codes is the right choice.</paragraph><heading level="3">Adding information to errors</heading><paragraph>Any function returning an error should strive to make the error value useful. Often, the function is in the middle of a callchain and is merely propagating an error from some other function that it called (maybe even from another package). Here there is an opportunity to annotate the error with extra information, but the programmer should ensure there's sufficient information in the error without adding duplicate or irrelevant detail. If you're unsure, try triggering the error condition during development: that's a good way to assess what the observers of the error (either humans or code) will end up with.</paragraph><paragraph>Convention and good documentation help. For example, the standard package os advertises that its errors contain path information when it is available. This is a useful style, because callers getting back an error don't need to annotate it with information that they had already provided the failing function.</paragraph><code language="javascript">// Good:
if err := os.Open("settings.txt"); err != nil {
    return err
}

// Output:
//
// open settings.txt: no such file or directory
</code><paragraph>If there is something interesting to say about the meaning of the error, of course it can be added. Just consider which level of the callchain is best positioned to understand this meaning.</paragraph><code language="javascript">// Good:
if err := os.Open("settings.txt"); err != nil {
    // We convey the significance of this error to us. Note that the current
    // function might perform more than one file operation that can fail, so
    // these annotations can also serve to disambiguate to the caller what went
    // wrong.
    return fmt.Errorf("launch codes unavailable: %v", err)
}

// Output:
//
// launch codes unavailable: open settings.txt: no such file or directory
</code><paragraph>Contrast with the redundant information here:</paragraph><code language="javascript">// Bad:
if err := os.Open("settings.txt"); err != nil {
    return fmt.Errorf("could not open settings.txt: %w", err)
}

// Output:
//
// could not open settings.txt: open settings.txt: no such file or directory
</code><paragraph>When adding information to a propagated error, you can either wrap the error or present a fresh error. Wrapping the error with the %w verb in fmt.Errorf allows callers to access data from the original error. This can be very useful at times, but in other cases these details are misleading or uninteresting to the caller. See the blog post on error wrapping for more information. Wrapping errors also expands the API surface of your package in a non-obvious way, and this can cause breakages if you change the implementation details of your package.</paragraph><paragraph>It is best to avoid using %w unless you also document (and have tests that validate) the underlying errors that you expose. If you do not expect your caller to call errors.Unwrap, errors.Is and so on, don't bother with %w.</paragraph><paragraph>The same concept applies to structured errors like *status.Status (see canonical codes). For example, if your server sends malformed requests to a backend and receives an InvalidArgument code, this code should not be propagated to the client, assuming that the client has done nothing wrong. Instead, return an Internal canonical code to the client.</paragraph><paragraph>However, annotating errors helps automated logging systems preserve the status payload of an error. For example, annotating the error is appropriate in an internal function:</paragraph><code language="javascript">// Good:
func (s *Server) internalFunction(ctx context.Context) error {
    // ...
    if err != nil {
        return fmt.Errorf("couldn't find remote file: %w", err)
    }
}
</code><paragraph>Code directly at system boundaries (typically RPC, IPC, storage, and similar) should report errors using the canonical error space. It is the responsibility of code here to handle domain-specific errors and represent them canonically. For example:</paragraph><code language="javascript">// Bad:
func (*FortuneTeller) SuggestFortune(context.Context, *pb.SuggestionRequest) (*pb.SuggestionResponse, error) {
    // ...
    if err != nil {
        return nil, fmt.Errorf("couldn't find remote file: %w", err)
    }
}
</code><code language="javascript">// Good:
import (
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
)
func (*FortuneTeller) SuggestFortune(context.Context, *pb.SuggestionRequest) (*pb.SuggestionResponse, error) {
    // ...
    if err != nil {
        // Or use fmt.Errorf with the %w verb if deliberately wrapping an
        // error which the caller is meant to unwrap.
        return nil, status.Errorf(codes.Internal, "couldn't find fortune database", status.ErrInternal)
    }
}
</code><paragraph>See also:</paragraph><heading level="3">Placement of %w in errors</heading><paragraph>Prefer to place %w at the end of an error string.</paragraph><paragraph>Errors can be wrapped with the %w verb, or by placing them in a structured error that implements Unwrap() error (ex: fs.PathError).</paragraph><paragraph>Wrapped errors form error chains: each new layer of wrapping adds a new entry to the front of the error chain. The error chain can be traversed with the Unwrap() error method. For example:</paragraph><code language="code">err1 := fmt.Errorf("err1")
err2 := fmt.Errorf("err2: %w", err1)
err3 := fmt.Errorf("err3: %w", err2)
</code><paragraph>This forms an error chain of the form,</paragraph><code language="javascript">flowchart LR
  err3 == err3 wraps err2 ==> err2;
  err2 == err2 wraps err1 ==> err1;
</code><paragraph>Regardless of where the %w verb is placed, the error returned always represents the front of the error chain, and the %w is the next child. Similarly, Unwrap() error always traverses the error chain from newest to oldest error.</paragraph><paragraph>Placement of the %w verb does, however, affect whether the error chain is printed newest to oldest, oldest to newest, or neither:</paragraph><code language="code">// Good:
err1 := fmt.Errorf("err1")
err2 := fmt.Errorf("err2: %w", err1)
err3 := fmt.Errorf("err3: %w", err2)
fmt.Println(err3) // err3: err2: err1
// err3 is a newest-to-oldest error chain, that prints newest-to-oldest.
</code><code language="code">// Bad:
err1 := fmt.Errorf("err1")
err2 := fmt.Errorf("%w: err2", err1)
err3 := fmt.Errorf("%w: err3", err2)
fmt.Println(err3) // err1: err2: err3
// err3 is a newest-to-oldest error chain, that prints oldest-to-newest.
</code><code language="code">// Bad:
err1 := fmt.Errorf("err1")
err2 := fmt.Errorf("err2-1 %w err2-2", err1)
err3 := fmt.Errorf("err3-1 %w err3-2", err2)
fmt.Println(err3) // err3-1 err2-1 err1 err2-2 err3-2
// err3 is a newest-to-oldest error chain, that neither prints newest-to-oldest
// nor oldest-to-newest.
</code><paragraph>Therefore, in order for error text to mirror error chain structure, prefer placing the %w verb at the end with the form [...]: %w.</paragraph><heading level="3">Logging errors</heading><paragraph>Functions sometimes need to tell an external system about an error without propagating it to their callers. Logging is an obvious choice here; but be conscious of what and how you log errors.</paragraph><list type="ul"><item>Like good test failure messages, log messages should clearly express what went wrong and help the maintainer by including relevant information to diagnose the problem.</item><item>Avoid duplication. If you return an error, it's usually better not to log it yourself but rather let the caller handle it. The caller can choose to log the error, or perhaps rate-limit logging using rate.Sometimes. Other options include attempting recovery or even stopping the program. In any case, giving the caller control helps avoid logspam. The downside to this approach, however, is that any logging is written using the caller's line coordinates.</item><item>Be careful with PII. Many log sinks are not appropriate destinations for sensitive end-user information.</item><item>Use log.Error sparingly. ERROR level logging causes a flush and is more expensive than lower logging levels. This can have serious performance impact on your code. When deciding between error and warning levels, consider the best practice that messages at the error level should be actionable rather than "more serious" than a warning.</item><item>Inside Google, we have monitoring systems that can be set up for more effective alerting than writing to a log file and hoping someone notices it. This is similar but not identical to the standard library package expvar.</item></list><paragraph>Like good test failure messages, log messages should clearly express what went wrong and help the maintainer by including relevant information to diagnose the problem.</paragraph><paragraph>Avoid duplication. If you return an error, it's usually better not to log it yourself but rather let the caller handle it. The caller can choose to log the error, or perhaps rate-limit logging using rate.Sometimes. Other options include attempting recovery or even stopping the program. In any case, giving the caller control helps avoid logspam.</paragraph><paragraph>The downside to this approach, however, is that any logging is written using the caller's line coordinates.</paragraph><paragraph>Be careful with PII. Many log sinks are not appropriate destinations for sensitive end-user information.</paragraph><paragraph>Use log.Error sparingly. ERROR level logging causes a flush and is more expensive than lower logging levels. This can have serious performance impact on your code. When deciding between error and warning levels, consider the best practice that messages at the error level should be actionable rather than "more serious" than a warning.</paragraph><paragraph>Inside Google, we have monitoring systems that can be set up for more effective alerting than writing to a log file and hoping someone notices it. This is similar but not identical to the standard library package expvar.</paragraph><heading level="4">Custom verbosity levels</heading><paragraph>Use verbose logging (log.V) to your advantage. Verbose logging can be useful for development and tracing. Establishing a convention around verbosity levels can be helpful. For example:</paragraph><list type="ul"><item>Write a small amount of extra information at V(1)</item><item>Trace more information in V(2)</item><item>Dump large internal states in V(3)</item></list><paragraph>To minimize the cost of verbose logging, you should ensure not to accidentally call expensive functions even when log.V is turned off. log.V offers two APIs. The more convenient one carries the risk of this accidental expense. When in doubt, use the slightly more verbose style.</paragraph><code language="javascript">// Good:
for _, sql := range queries {
  log.V(1).Infof("Handling %v", sql)
  if log.V(2) {
    log.Infof("Handling %v", sql.Explain())
  }
  sql.Run(...)
}
</code><code language="code">// Bad:
// sql.Explain called even when this log is not printed.
log.V(2).Infof("Handling %v", sql.Explain())
</code><heading level="3">Program initialization</heading><paragraph>Program initialization errors (such as bad flags and configuration) should be propagated upward to main, which should call log.Exit with an error that explains how to fix the error. In these cases, log.Fatal should not generally be used, because a stack trace that points at the check is not likely to be as useful as a human-generated, actionable message.</paragraph><heading level="3">Program checks and panics</heading><paragraph>As stated in the decision against panics, standard error handling should be structured around error return values. Libraries should prefer returning an error to the caller rather than aborting the program, especially for transient errors.</paragraph><paragraph>It is occasionally necessary to perform consistency checks on an invariant and terminate the program if it is violated. In general, this is only done when a failure of the invariant check means that the internal state has become unrecoverable. The most reliable way to do this in the Google codebase is to call log.Fatal. Using panic in these cases is not reliable, because it is possible for deferred functions to deadlock or further corrupt internal or external state.</paragraph><paragraph>Similarly, resist the temptation to recover panics to avoid crashes, as doing so can result in propagating a corrupted state. The further you are from the panic, the less you know about the state of the program, which could be holding locks or other resources. The program can then develop other unexpected failure modes that can make the problem even more difficult to diagnose. Instead of trying to handle unexpected panics in code, use monitoring tools to surface unexpected failures and fix related bugs with a high priority.</paragraph><paragraph>Note: The standard net/http server violates this advice and recovers panics from request handlers. Consensus among experienced Go engineers is that this was a historical mistake. If you sample server logs from application servers in other languages, it is common to find large stacktraces that are left unhandled. Avoid this pitfall in your servers.</paragraph><heading level="3">When to panic</heading><paragraph>The standard library panics on API misuse. For example, reflect issues a panic in many cases where a value is accessed in a way that suggests it was misinterpreted. This is analogous to the panics on core language bugs such as accessing an element of a slice that is out of bounds. Code review and tests should discover such bugs, which are not expected to appear in production code. These panics act as invariant checks that do not depend on a library, as the standard library does not have access to the levelled log package that the Google codebase uses.</paragraph><paragraph>Another case in which panics can be useful, though uncommon, is as an internal implementation detail of a package which always has a matching recover in the callchain. Parsers and similar deeply nested, tightly coupled internal function groups can benefit from this design, where plumbing error returns adds complexity without value.</paragraph><paragraph>The key attribute of this design is that these panics are never allowed to escape across package boundaries and do not form part of the package's API. This is typically accomplished with a top-level deferred function that uses recover to translate a propagated panic into a returned error at the public API boundary. It requires the code that panics and recovers to distinguish between panics that the code raises itself and those that it doesn't:</paragraph><code language="javascript">// Good:
type syntaxError struct {
  msg string
}

func parseInt(in string) int {
  n, err := strconv.Atoi(in)
  if err != nil {
    panic(&syntaxError{"not a valid integer"})
  }
}

func Parse(in string) (_ *Node, err error) {
  defer func() {
    if p := recover(); p != nil {
      sErr, ok := p.(*syntaxError)
      if !ok {
        panic(p) // Propagate the panic since it is outside our code's domain.
      }
      err = fmt.Errorf("syntax error: %v", sErr.msg)
    }
  }()
  ... // Parse input calling parseInt internally to parse integers
}
</code><paragraph>Warning: Code employing this pattern must take care to manage any resources associated with the code run in such defer-managed sections (e.g., close, free, or unlock).</paragraph><paragraph>See: Go Tip #81: Avoiding Resource Leaks in API Design</paragraph><paragraph>Panic is also used when the compiler cannot identify unreachable code, for example when using a function like log.Fatal that will not return:</paragraph><code language="javascript">// Good:
func answer(i int) string {
    switch i {
    case 42:
        return "yup"
    case 54:
        return "base 13, huh"
    default:
        log.Fatalf("Sorry, %d is not the answer.", i)
        panic("unreachable")
    }
}
</code><paragraph>Do not call log functions before flags have been parsed. If you must die in a package initialization function (an init or a "must" function), a panic is acceptable in place of the fatal logging call.</paragraph><paragraph>See also:</paragraph><heading level="2">Documentation</heading><heading level="3">Conventions</heading><paragraph>This section augments the decisions document's commentary section.</paragraph><paragraph>Go code that is documented in familiar style is easier to read and less likely to be misused than something misdocumented or not documented at all. Runnable examples show up in Godoc and Code Search and are an excellent way of explaining how to use your code.</paragraph><heading level="4">Parameters and configuration</heading><paragraph>Not every parameter must be enumerated in the documentation. This applies to:</paragraph><list type="ul"><item>function and method parameters</item><item>struct fields</item><item>APIs for options</item></list><paragraph>Document the error-prone or non-obvious fields and parameters by saying why they are interesting.</paragraph><paragraph>In the following snippet, the highlighted commentary adds little useful information to the reader:</paragraph><code language="go">// Bad:
// Sprintf formats according to a format specifier and returns the resulting
// string.
//
// format is the format, and data is the interpolation data.
func Sprintf(format string, data ...any) string
</code><paragraph>However, this snippet demonstrates a code scenario similar to the previous where the commentary instead states something non-obvious or materially helpful to the reader:</paragraph><code language="go">// Good:
// Sprintf formats according to a format specifier and returns the resulting
// string.
//
// The provided data is used to interpolate the format string. If the data does
// not match the expected format verbs or the amount of data does not satisfy
// the format specification, the function will inline warnings about formatting
// errors into the output string as described by the Format errors section
// above.
func Sprintf(format string, data ...any) string
</code><paragraph>Consider your likely audience in choosing what to document and at what depth. Maintainers, newcomers to the team, external users, and even yourself six months in the future may appreciate slightly different information from what is on your mind when you first come to write your docs.</paragraph><paragraph>See also:</paragraph><heading level="4">Contexts</heading><paragraph>It is implied that the cancellation of a context argument interrupts the function it is provided to. If the function can return an error, conventionally it is ctx.Err().</paragraph><paragraph>This fact does not need to be restated:</paragraph><code language="code">// Bad:
// Run executes the worker's run loop.
//
// The method will process work until the context is cancelled and accordingly
// returns an error.
func (Worker) Run(ctx context.Context) error
</code><paragraph>Because that is implied, the following is better:</paragraph><code language="code">// Good:
// Run executes the worker's run loop.
func (Worker) Run(ctx context.Context) error
</code><paragraph>Where context behavior is different or non-obvious, it should be expressly documented if any of the following are true.</paragraph><list type="ul"><item>The function returns an error other than ctx.Err() when the context is cancelled: // Good: // Run executes the worker's run loop. // // If the context is cancelled, Run returns a nil error. func (Worker) Run(ctx context.Context) error</item><item>The function has other mechanisms that may interrupt it or affect lifetime: // Good: // Run executes the worker's run loop. // // Run processes work until the context is cancelled or Stop is called. // Context cancellation is handled asynchronously internally: run may return // before all work has stopped. The Stop method is synchronous and waits // until all operations from the run loop finish. Use Stop for graceful // shutdown. func (Worker) Run(ctx context.Context) error func (Worker) Stop()</item><item>The function has special expectations about context lifetime, lineage, or attached values: // Good: // NewReceiver starts receiving messages sent to the specified queue. // The context should not have a deadline. func NewReceiver(ctx context.Context) *Receiver // Principal returns a human-readable name of the party who made the call. // The context must have a value attached to it from security.NewContext. func Principal(ctx context.Context) (name string, ok bool) Warning: Avoid designing APIs that make such demands (like contexts not having deadlines) from their callers. The above is only an example of how to document this if it cannot be avoided, not an endorsement of the pattern.</item></list><paragraph>The function returns an error other than ctx.Err() when the context is cancelled:</paragraph><code language="code">// Good:
// Run executes the worker's run loop.
//
// If the context is cancelled, Run returns a nil error.
func (Worker) Run(ctx context.Context) error
</code><paragraph>The function has other mechanisms that may interrupt it or affect lifetime:</paragraph><code language="code">// Good:
// Run executes the worker's run loop.
//
// Run processes work until the context is cancelled or Stop is called.
// Context cancellation is handled asynchronously internally: run may return
// before all work has stopped. The Stop method is synchronous and waits
// until all operations from the run loop finish. Use Stop for graceful
// shutdown.
func (Worker) Run(ctx context.Context) error

func (Worker) Stop()
</code><paragraph>The function has special expectations about context lifetime, lineage, or attached values:</paragraph><code language="go">// Good:
// NewReceiver starts receiving messages sent to the specified queue.
// The context should not have a deadline.
func NewReceiver(ctx context.Context) *Receiver

// Principal returns a human-readable name of the party who made the call.
// The context must have a value attached to it from security.NewContext.
func Principal(ctx context.Context) (name string, ok bool)
</code><paragraph>Warning: Avoid designing APIs that make such demands (like contexts not having deadlines) from their callers. The above is only an example of how to document this if it cannot be avoided, not an endorsement of the pattern.</paragraph><heading level="4">Concurrency</heading><paragraph>Go users assume that conceptually read-only operations are safe for concurrent use and do not require extra synchronization.</paragraph><paragraph>The extra remark about concurrency can safely be removed in this Godoc:</paragraph><code language="code">// Len returns the number of bytes of the unread portion of the buffer;
// b.Len() == len(b.Bytes()).
//
// It is safe to be called concurrently by multiple goroutines.
func (*Buffer) Len() int
</code><paragraph>Mutating operations, however, are not assumed to be safe for concurrent use and require the user to consider synchronization.</paragraph><paragraph>Similarly, the extra remark about concurrency can safely be removed here:</paragraph><code language="code">// Grow grows the buffer's capacity.
//
// It is not safe to be called concurrently by multiple goroutines.
func (*Buffer) Grow(n int)
</code><paragraph>Documentation is strongly encouraged if any of the following are true.</paragraph><list type="ul"><item>It is unclear whether the operation is read-only or mutating: // Good: package lrucache // Lookup returns the data associated with the key from the cache. // // This operation is not safe for concurrent use. func (*Cache) Lookup(key string) (data []byte, ok bool) Why? A cache hit when looking up the key mutate a LRU cache internally. How this is implemented may not be obvious to all readers.</item><item>Synchronization is provided by the API: // Good: package fortune_go_proto // NewFortuneTellerClient returns an *rpc.Client for the FortuneTeller service. // It is safe for simultaneous use by multiple goroutines. func NewFortuneTellerClient(cc *rpc.ClientConn) *FortuneTellerClient Why? Stubby provides synchronization. Note: If the API is a type and the API provides synchronization in entirety, conventionally only the type definition documents the semantics.</item><item>The API consumes user-implemented types of interfaces, and the interface's consumer has particular concurrency requirements: // Good: package health // A Watcher reports the health of some entity (usually a backend service). // // Watcher methods are safe for simultaneous use by multiple goroutines. type Watcher interface { // Watch sends true on the passed-in channel when the Watcher's // status has changed. Watch(changed chan<- bool) (unwatch func()) // Health returns nil if the entity being watched is healthy, or a // non-nil error explaining why the entity is not healthy. Health() error } Why? Whether an API is safe for use by multiple goroutines is part of its contract.</item></list><paragraph>It is unclear whether the operation is read-only or mutating:</paragraph><code language="code">// Good:
package lrucache

// Lookup returns the data associated with the key from the cache.
//
// This operation is not safe for concurrent use.
func (*Cache) Lookup(key string) (data []byte, ok bool)
</code><paragraph>Why? A cache hit when looking up the key mutate a LRU cache internally. How this is implemented may not be obvious to all readers.</paragraph><paragraph>Synchronization is provided by the API:</paragraph><code language="go">// Good:
package fortune_go_proto

// NewFortuneTellerClient returns an *rpc.Client for the FortuneTeller service.
// It is safe for simultaneous use by multiple goroutines.
func NewFortuneTellerClient(cc *rpc.ClientConn) *FortuneTellerClient
</code><paragraph>Why? Stubby provides synchronization.</paragraph><paragraph>Note: If the API is a type and the API provides synchronization in entirety, conventionally only the type definition documents the semantics.</paragraph><paragraph>The API consumes user-implemented types of interfaces, and the interface's consumer has particular concurrency requirements:</paragraph><code language="javascript">// Good:
package health

// A Watcher reports the health of some entity (usually a backend service).
//
// Watcher methods are safe for simultaneous use by multiple goroutines.
type Watcher interface {
    // Watch sends true on the passed-in channel when the Watcher's
    // status has changed.
    Watch(changed chan<- bool) (unwatch func())

    // Health returns nil if the entity being watched is healthy, or a
    // non-nil error explaining why the entity is not healthy.
    Health() error
}
</code><paragraph>Why? Whether an API is safe for use by multiple goroutines is part of its contract.</paragraph><heading level="4">Cleanup</heading><paragraph>Document any explicit cleanup requirements that the API has. Otherwise, callers won't use the API correctly, leading to resource leaks and other possible bugs.</paragraph><paragraph>Call out cleanups that are up to the caller:</paragraph><code language="go">// Good:
// NewTicker returns a new Ticker containing a channel that will send the
// current time on the channel after each tick.
//
// Call Stop to release the Ticker's associated resources when done.
func NewTicker(d Duration) *Ticker

func (*Ticker) Stop()
</code><paragraph>If it is potentially unclear how to clean up the resources, explain how:</paragraph><code language="javascript">// Good:
// Get issues a GET to the specified URL.
//
// When err is nil, resp always contains a non-nil resp.Body.
// Caller should close resp.Body when done reading from it.
//
//    resp, err := http.Get("http://example.com/")
//    if err != nil {
//        // handle error
//    }
//    defer resp.Body.Close()
//    body, err := io.ReadAll(resp.Body)
func (c *Client) Get(url string) (resp *Response, err error)
</code><paragraph>See also:</paragraph><heading level="4">Errors</heading><paragraph>Document significant error sentinel values or error types that your functions return to callers so that callers can anticipate what types of conditions they can handle in their code.</paragraph><code language="javascript">// Good:
package os

// Read reads up to len(b) bytes from the File and stores them in b. It returns
// the number of bytes read and any error encountered.
//
// At end of file, Read returns 0, io.EOF.
func (*File) Read(b []byte) (n int, err error) {
</code><paragraph>When a function returns a specific error type, correctly note whether the error is a pointer receiver or not:</paragraph><code language="javascript">// Good:
package os

type PathError struct {
    Op   string
    Path string
    Err  error
}

// Chdir changes the current working directory to the named directory.
//
// If there is an error, it will be of type *PathError.
func Chdir(dir string) error {
</code><paragraph>Documenting whether the values returned are pointer receivers enables callers to correctly compare the errors using errors.Is, errors.As, and package cmp. This is because a non-pointer value is not equivalent to a pointer value.</paragraph><paragraph>Note: In the Chdir example, the return type is written as error rather than *PathError due to how nil interface values work.</paragraph><paragraph>Document overall error conventions in the package's documentation when the behavior is applicable to most errors found in the package:</paragraph><code language="code">// Good:
// Package os provides a platform-independent interface to operating system
// functionality.
//
// Often, more information is available within the error. For example, if a
// call that takes a file name fails, such as Open or Stat, the error will
// include the failing file name when printed and will be of type *PathError,
// which may be unpacked for more information.
package os
</code><paragraph>Thoughtful application of these approaches can add extra information to errors without much effort and help callers avoid adding redundant annotations.</paragraph><paragraph>See also:</paragraph><heading level="3">Preview</heading><paragraph>Go features a documentation server. It is recommended to preview the documentation your code produces both before and during the code review process. This helps to validate that the godoc formatting is rendered correctly.</paragraph><heading level="3">Godoc formatting</heading><paragraph>Godoc provides some specific syntax to format documentation.</paragraph><list type="ul"><item>A blank line is required to separate paragraphs: // Good: // LoadConfig reads a configuration out of the named file. // // See some/shortlink for config file format details.</item><item>Test files can contain runnable examples that appear attached to the corresponding documentation in godoc: // Good: func ExampleConfig_WriteTo() { cfg := &Config{ Name: "example", } if err := cfg.WriteTo(os.Stdout); err != nil { log.Exitf("Failed to write config: %s", err) } // Output: // { // "name": "example" // } }</item><item>Indenting lines by an additional two spaces formats them verbatim: // Good: // Update runs the function in an atomic transaction. // // This is typically used with an anonymous TransactionFunc: // // if err := db.Update(func(state *State) { state.Foo = bar }); err != nil { // //... // } Note, however, that it can often be more appropriate to put code in a runnable example instead of including it in a comment. This verbatim formatting can be leveraged for formatting that is not native to godoc, such as lists and tables: // Good: // LoadConfig reads a configuration out of the named file. // // LoadConfig treats the following keys in special ways: // "import" will make this configuration inherit from the named file. // "env" if present will be populated with the system environment.</item><item>A single line that begins with a capital letter, contains no punctuation except parentheses and commas, and is followed by another paragraph, is formatted as a header: // Good: // The following line is formatted as a heading. // // Using headings // // Headings come with autogenerated anchor tags for easy linking.</item></list><paragraph>A blank line is required to separate paragraphs:</paragraph><code language="code">// Good:
// LoadConfig reads a configuration out of the named file.
//
// See some/shortlink for config file format details.
</code><paragraph>Test files can contain runnable examples that appear attached to the corresponding documentation in godoc:</paragraph><code language="javascript">// Good:
func ExampleConfig_WriteTo() {
  cfg := &Config{
    Name: "example",
  }
  if err := cfg.WriteTo(os.Stdout); err != nil {
    log.Exitf("Failed to write config: %s", err)
  }
  // Output:
  // {
  //   "name": "example"
  // }
}
</code><paragraph>Indenting lines by an additional two spaces formats them verbatim:</paragraph><code language="javascript">// Good:
// Update runs the function in an atomic transaction.
//
// This is typically used with an anonymous TransactionFunc:
//
//   if err := db.Update(func(state *State) { state.Foo = bar }); err != nil {
//     //...
//   }
</code><paragraph>Note, however, that it can often be more appropriate to put code in a runnable example instead of including it in a comment.</paragraph><paragraph>This verbatim formatting can be leveraged for formatting that is not native to godoc, such as lists and tables:</paragraph><code language="code">// Good:
// LoadConfig reads a configuration out of the named file.
//
// LoadConfig treats the following keys in special ways:
//   "import" will make this configuration inherit from the named file.
//   "env" if present will be populated with the system environment.
</code><paragraph>A single line that begins with a capital letter, contains no punctuation except parentheses and commas, and is followed by another paragraph, is formatted as a header:</paragraph><code language="code">// Good:
// The following line is formatted as a heading.
//
// Using headings
//
// Headings come with autogenerated anchor tags for easy linking.
</code><heading level="3">Signal boosting</heading><paragraph>Sometimes a line of code looks like something common, but actually isn't. One of the best examples of this is an err == nil check (since err != nil is much more common). The following two conditional checks are hard to distinguish:</paragraph><code language="javascript">// Good:
if err := doSomething(); err != nil {
    // ...
}
</code><code language="javascript">// Bad:
if err := doSomething(); err == nil {
    // ...
}
</code><paragraph>You can instead "boost" the signal of the conditional by adding a comment:</paragraph><code language="code">// Good:
if err := doSomething(); err == nil { // if NO error
    // ...
}
</code><paragraph>The comment draws attention to the difference in the conditional.</paragraph><heading level="2">Variable declarations</heading><heading level="3">Initialization</heading><paragraph>For consistency, prefer := over var when initializing a new variable with a non-zero value.</paragraph><heading level="3">Declaring variables with zero values</heading><paragraph>The following declarations use the zero value:</paragraph><code language="javascript">// Good:
var (
    coords Point
    magic  [4]byte
    primes []int
)
</code><paragraph>You should declare values using the zero value when you want to convey an empty value that is ready for later use. Using composite literals with explicit initialization can be clunky:</paragraph><code language="javascript">// Bad:
var (
    coords = Point{X: 0, Y: 0}
    magic  = [4]byte{0, 0, 0, 0}
    primes = []int(nil)
)
</code><paragraph>A common application of zero value declaration is when using a variable as the output when unmarshalling:</paragraph><code language="javascript">// Good:
var coords Point
if err := json.Unmarshal(data, &coords); err != nil {
</code><paragraph>It is also okay to use the zero value in the following form when you need a variable of a pointer type:</paragraph><code language="javascript">// Good:
msg := new(pb.Bar) // or "&pb.Bar{}"
if err := proto.Unmarshal(data, msg); err != nil {
</code><paragraph>If you need a lock or other field that must not be copied in your struct, you can make it a value type to take advantage of zero value initialization. It does mean that the containing type must now be passed via a pointer and not a value. Methods on the type must take pointer receivers.</paragraph><code language="javascript">// Good:
type Counter struct {
    // This field does not have to be "*sync.Mutex". However,
    // users must now pass *Counter objects between themselves, not Counter.
    mu   sync.Mutex
    data map[string]int64
}

// Note this must be a pointer receiver to prevent copying.
func (c *Counter) IncrementBy(name string, n int64)
</code><paragraph>It's acceptable to use value types for local variables of composites (such as structs and arrays) even if they contain such uncopyable fields. However, if the composite is returned by the function, or if all accesses to it end up needing to take an address anyway, prefer declaring the variable as a pointer type at the outset. Similarly, protobufs should be declared as pointer types.</paragraph><code language="javascript">// Good:
func NewCounter(name string) *Counter {
    c := new(Counter) // "&Counter{}" is also fine.
    registerCounter(name, c)
    return c
}

var msg = new(pb.Bar) // or "&pb.Bar{}".
</code><paragraph>This is because *pb.Something satisfies proto.Message while pb.Something does not.</paragraph><code language="javascript">// Bad:
func NewCounter(name string) *Counter {
    var c Counter
    registerCounter(name, &c)
    return &c
}

var msg = pb.Bar{}
</code><paragraph>Important: Map types must be explicitly initialized before they can be modified. However, reading from zero-value maps is perfectly fine.</paragraph><paragraph>For map and slice types, if the code is particularly performance sensitive and if you know the sizes in advance, see the size hints section.</paragraph><heading level="3">Composite literals</heading><paragraph>The following are composite literal declarations:</paragraph><code language="javascript">// Good:
var (
    coords   = Point{X: x, Y: y}
    magic    = [4]byte{'I', 'W', 'A', 'D'}
    primes   = []int{2, 3, 5, 7, 11}
    captains = map[string]string{"Kirk": "James Tiberius", "Picard": "Jean-Luc"}
)
</code><paragraph>You should declare a value using a composite literal when you know initial elements or members.</paragraph><paragraph>In contrast, using composite literals to declare empty or memberless values can be visually noisy compared to zero-value initialization.</paragraph><paragraph>When you need a pointer to a zero value, you have two options: empty composite literals and new. Both are fine, but the new keyword can serve to remind the reader that if a non-zero value were needed, a composite literal wouldn't work:</paragraph><code language="javascript">// Good:
var (
  buf = new(bytes.Buffer) // non-empty Buffers are initialized with constructors.
  msg = new(pb.Message) // non-empty proto messages are initialized with builders or by setting fields one by one.
)
</code><heading level="3">Size hints</heading><paragraph>The following are declarations that take advantage of size hints in order to preallocate capacity:</paragraph><code language="javascript">// Good:
var (
    // Preferred buffer size for target filesystem: st_blksize.
    buf = make([]byte, 131072)
    // Typically process up to 8-10 elements per run (16 is a safe assumption).
    q = make([]Node, 0, 16)
    // Each shard processes shardSize (typically 32000+) elements.
    seen = make(map[string]bool, shardSize)
)
</code><paragraph>Size hints and preallocation are important steps when combined with empirical analysis of the code and its integrations, to create performance-sensitive and resource-efficient code.</paragraph><paragraph>Most code does not need a size hint or preallocation, and can allow the runtime to grow the slice or map as necessary. It is acceptable to preallocate when the final size is known (e.g. when converting between a map and a slice) but this is not a readability requirement, and may not be worth the clutter in small cases.</paragraph><paragraph>Warning: Preallocating more memory than you need can waste memory in the fleet or even harm performance. When in doubt, see GoTip #3: Benchmarking Go Code and default to a zero initialization or a composite literal declaration.</paragraph><heading level="3">Channel direction</heading><paragraph>Specify channel direction where possible.</paragraph><code language="javascript">// Good:
// sum computes the sum of all of the values. It reads from the channel until
// the channel is closed.
func sum(values <-chan int) int {
    // ...
}
</code><paragraph>This prevents casual programming errors that are possible without specification:</paragraph><code language="javascript">// Bad:
func sum(values chan int) (out int) {
    for v := range values {
        out += v
    }
    // values must already be closed for this code to be reachable, which means
    // a second close triggers a panic.
    close(values)
}
</code><paragraph>When the direction is specified, the compiler catches simple errors like this. It also helps to convey a measure of ownership to the type.</paragraph><paragraph>See also Bryan Mills' talk "Rethinking Classical Concurrency Patterns": slides video.</paragraph><heading level="2">Function argument lists</heading><paragraph>Don't let the signature of a function get too long. As more parameters are added to a function, the role of individual parameters becomes less clear, and adjacent parameters of the same type become easier to confuse. Functions with large numbers of arguments are less memorable and more difficult to read at the call-site.</paragraph><paragraph>When designing an API, consider splitting a highly configurable function whose signature is growing complex into several simpler ones. These can share an (unexported) implementation if necessary.</paragraph><paragraph>Where a function requires many inputs, consider introducing an option struct for some of the arguments or employing the more advanced variadic options technique. The primary consideration for which strategy to choose should be how the function call looks across all expected use cases.</paragraph><paragraph>The recommendations below primarily apply to exported APIs, which are held to a higher standard than unexported ones. These techniques may be unnecessary for your use case. Use your judgment, and balance the principles of clarity and least mechanism.</paragraph><paragraph>See also: Go Tip #24: Use Case-Specific Constructions</paragraph><heading level="3">Option structure</heading><paragraph>An option structure is a struct type that collects some or all of the arguments of a function or method, that is then passed as the last argument to the function or method. (The struct should be exported only if it is used in an exported function.)</paragraph><paragraph>Using an option structure has a number of benefits:</paragraph><list type="ul"><item>The struct literal includes both fields and values for each argument, which makes them self-documenting and harder to swap.</item><item>Irrelevant or "default" fields can be omitted.</item><item>Callers can share the option struct and write helpers to operate on it.</item><item>Structs provide cleaner per-field documentation than function arguments.</item><item>Option structs can grow over time without impacting call-sites.</item></list><paragraph>Here is an example of a function that could be improved:</paragraph><code language="javascript">// Bad:
func EnableReplication(ctx context.Context, config *replicator.Config, primaryRegions, readonlyRegions []string, replicateExisting, overwritePolicies bool, replicationInterval time.Duration, copyWorkers int, healthWatcher health.Watcher) {
    // ...
}
</code><paragraph>The function above could be rewritten with an option structure as follows:</paragraph><code language="javascript">// Good:
type ReplicationOptions struct {
    Config              *replicator.Config
    PrimaryRegions      []string
    ReadonlyRegions     []string
    ReplicateExisting   bool
    OverwritePolicies   bool
    ReplicationInterval time.Duration
    CopyWorkers         int
    HealthWatcher       health.Watcher
}

func EnableReplication(ctx context.Context, opts ReplicationOptions) {
    // ...
}
</code><paragraph>The function can then be called in a different package:</paragraph><code language="javascript">// Good:
func foo(ctx context.Context) {
    // Complex call:
    storage.EnableReplication(ctx, storage.ReplicationOptions{
        Config:              config,
        PrimaryRegions:      []string{"us-east1", "us-central2", "us-west3"},
        ReadonlyRegions:     []string{"us-east5", "us-central6"},
        OverwritePolicies:   true,
        ReplicationInterval: 1 * time.Hour,
        CopyWorkers:         100,
        HealthWatcher:       watcher,
    })

    // Simple call:
    storage.EnableReplication(ctx, storage.ReplicationOptions{
        Config:         config,
        PrimaryRegions: []string{"us-east1", "us-central2", "us-west3"},
    })
}
</code><paragraph>Note: Contexts are never included in option structs.</paragraph><paragraph>This option is often preferred when some of the following apply:</paragraph><list type="ul"><item>All callers need to specify one or more of the options.</item><item>A large number of callers need to provide many options.</item><item>The options are shared between multiple functions that the user will call.</item></list><heading level="3">Variadic options</heading><paragraph>Using variadic options, exported functions are created which return closures that can be passed to the variadic (...) parameter of a function. The function takes as its parameters the values of the option (if any), and the returned closure accepts a mutable reference (usually a pointer to a struct type) that will be updated based on the inputs.</paragraph><paragraph>Using variadic options can provide a number of benefits:</paragraph><list type="ul"><item>Options take no space at a call-site when no configuration is needed.</item><item>Options are still values, so callers can share them, write helpers, and accumulate them.</item><item>Options can accept multiple parameters (e.g. cartesian.Translate(dx, dy int) TransformOption).</item><item>The option functions can return a named type to group options together in godoc.</item><item>Packages can allow (or prevent) third-party packages to define (or from defining) their own options.</item></list><paragraph>Note: Using variadic options requires a substantial amount of additional code (see the following example), so it should only be used when the advantages outweigh the overhead.</paragraph><paragraph>Here is an example of a function that could be improved:</paragraph><code language="javascript">// Bad:
func EnableReplication(ctx context.Context, config *placer.Config, primaryCells, readonlyCells []string, replicateExisting, overwritePolicies bool, replicationInterval time.Duration, copyWorkers int, healthWatcher health.Watcher) {
  ...
}
</code><paragraph>The example above could be rewritten with variadic options as follows:</paragraph><code language="javascript">// Good:
type replicationOptions struct {
    readonlyCells       []string
    replicateExisting   bool
    overwritePolicies   bool
    replicationInterval time.Duration
    copyWorkers         int
    healthWatcher       health.Watcher
}

// A ReplicationOption configures EnableReplication.
type ReplicationOption func(*replicationOptions)

// ReadonlyCells adds additional cells that should additionally
// contain read-only replicas of the data.
//
// Passing this option multiple times will add additional
// read-only cells.
//
// Default: none
func ReadonlyCells(cells ...string) ReplicationOption {
    return func(opts *replicationOptions) {
        opts.readonlyCells = append(opts.readonlyCells, cells...)
    }
}

// ReplicateExisting controls whether files that already exist in the
// primary cells will be replicated.  Otherwise, only newly-added
// files will be candidates for replication.
//
// Passing this option again will overwrite earlier values.
//
// Default: false
func ReplicateExisting(enabled bool) ReplicationOption {
    return func(opts *replicationOptions) {
        opts.replicateExisting = enabled
    }
}

// ... other options ...

// DefaultReplicationOptions control the default values before
// applying options passed to EnableReplication.
var DefaultReplicationOptions = []ReplicationOption{
    OverwritePolicies(true),
    ReplicationInterval(12 * time.Hour),
    CopyWorkers(10),
}

func EnableReplication(ctx context.Context, config *placer.Config, primaryCells []string, opts ...ReplicationOption) {
    var options replicationOptions
    for _, opt := range DefaultReplicationOptions {
        opt(&options)
    }
    for _, opt := range opts {
        opt(&options)
    }
}
</code><paragraph>The function can then be called in a different package:</paragraph><code language="javascript">// Good:
func foo(ctx context.Context) {
    // Complex call:
    storage.EnableReplication(ctx, config, []string{"po", "is", "ea"},
        storage.ReadonlyCells("ix", "gg"),
        storage.OverwritePolicies(true),
        storage.ReplicationInterval(1*time.Hour),
        storage.CopyWorkers(100),
        storage.HealthWatcher(watcher),
    )

    // Simple call:
    storage.EnableReplication(ctx, config, []string{"po", "is", "ea"})
}
</code><paragraph>Prefer this option when many of the following apply:</paragraph><list type="ul"><item>Most callers will not need to specify any options.</item><item>Most options are used infrequently.</item><item>There are a large number of options.</item><item>Options require arguments.</item><item>Options could fail or be set incorrectly (in which case the option function returns an error).</item><item>Options require a lot of documentation that can be hard to fit in a struct.</item><item>Users or other packages can provide custom options.</item></list><paragraph>Options in this style should accept parameters rather than using presence to signal their value; the latter can make dynamic composition of arguments much more difficult. For example, binary settings should accept a boolean (e.g. rpc.FailFast(enable bool) is preferable to rpc.EnableFailFast()). An enumerated option should accept an enumerated constant (e.g. log.Format(log.Capacitor) is preferable to log.CapacitorFormat()). The alternative makes it much more difficult for users who must programmatically choose which options to pass; such users are forced to change the actual composition of the parameters rather than simply changing the arguments to the options. Don't assume that all users will know the full set of options statically.</paragraph><paragraph>In general, options should be processed in order. If there is a conflict or if a non-cumulative option is passed multiple times, the last argument should win.</paragraph><paragraph>The parameter to the option function is generally unexported in this pattern, to restrict the options to being defined only within the package itself. This is a good default, though there may be times when it is appropriate to allow other packages to define options.</paragraph><paragraph>See Rob Pike's original blog post and Dave Cheney's talk for a more in-depth look at how these options can be used.</paragraph><heading level="2">Complex command-line interfaces</heading><paragraph>Some programs wish to present users with a rich command-line interface that includes sub-commands. For example, kubectl create, kubectl run, and many other sub-commands are all provided by the program kubectl. There are at least the following libraries in common use for achieving this.</paragraph><paragraph>If you don't have a preference or other considerations are equal, subcommands is recommended, since it is the simplest and is easy to use correctly. However, if you need different features that it doesn't provide, pick one of the other options.</paragraph><list type="ul"><item>cobra Flag convention: getopt Common outside the Google codebase. Many extra features. Pitfalls in usage (see below).</item><item>subcommands Flag convention: Go Simple and easy to use correctly. Recommended if you don't need extra features.</item></list><paragraph>cobra</paragraph><list type="ul"><item>Flag convention: getopt</item><item>Common outside the Google codebase.</item><item>Many extra features.</item><item>Pitfalls in usage (see below).</item></list><paragraph>subcommands</paragraph><list type="ul"><item>Flag convention: Go</item><item>Simple and easy to use correctly.</item><item>Recommended if you don't need extra features.</item></list><paragraph>Warning: cobra command functions should use cmd.Context() to obtain a context rather than creating their own root context with context.Background. Code that uses the subcommands package already receives the correct context as a function parameter.</paragraph><paragraph>You are not required to place each subcommand in a separate package, and it is often not necessary to do so. Apply the same considerations about package boundaries as in any Go codebase. If your code can be used both as a library and as a binary, it is usually beneficial to separate the CLI code and the library, making the CLI just one more of its clients. (This is not specific to CLIs that have subcommands, but is mentioned here because it is a common place where it comes up.)</paragraph><heading level="2">Tests</heading><heading level="3">Leave testing to the Test function</heading><paragraph>Go distinguishes between "test helpers" and "assertion helpers":</paragraph><list type="ul"><item>Test helpers are functions that do setup or cleanup tasks. All failures that occur in test helpers are expected to be failures of the environment (not from the code under test) — for example when a test database cannot be started because there are no more free ports on this machine. For functions like these, calling t.Helper is often appropriate to mark them as a test helper. See error handling in test helpers for more details.</item><item>Assertion helpers are functions that check the correctness of a system and fail the test if an expectation is not met. Assertion helpers are not considered idiomatic in Go.</item></list><paragraph>Test helpers are functions that do setup or cleanup tasks. All failures that occur in test helpers are expected to be failures of the environment (not from the code under test) — for example when a test database cannot be started because there are no more free ports on this machine. For functions like these, calling t.Helper is often appropriate to mark them as a test helper. See error handling in test helpers for more details.</paragraph><paragraph>Assertion helpers are functions that check the correctness of a system and fail the test if an expectation is not met. Assertion helpers are not considered idiomatic in Go.</paragraph><paragraph>The purpose of a test is to report pass/fail conditions of the code under test. The ideal place to fail a test is within the Test function itself, as that ensures that failure messages and the test logic are clear.</paragraph><paragraph>As your testing code grows, it may become necessary to factor out some functionality to separate functions. Standard software engineering considerations still apply, as test code is still code. If the functionality does not interact with the testing framework, then all of the usual rules apply. When the common code interacts with the framework, however, some care must be taken to avoid common pitfalls that can lead to uninformative failure messages and unmaintainable tests.</paragraph><paragraph>If many separate test cases require the same validation logic, arrange the test in one of the following ways instead of using assertion helpers or complex validation functions:</paragraph><list type="ul"><item>Inline the logic (both the validation and the failure) in the Test function, even if it is repetitive. This works best in simple cases.</item><item>If inputs are similar, consider unifying them into a table-driven test while keeping the logic inlined in the loop. This helps to avoid repetition while keeping the validation and failure in the Test.</item><item>If there are multiple callers who need the same validation function but table tests are not suitable (typically because the inputs are not simple enough or the validation is required as part of a sequence of operations), arrange the validation function so that it returns a value (typically an error) rather than taking a testing.T parameter and using it to fail the test. Use logic within the Test to decide whether to fail, and to provide useful test failures. You can also create test helpers to factor out common boilerplate setup code.</item></list><paragraph>The design outlined in the last point maintains orthogonality. For example, package cmp is not designed to fail tests, but rather to compare (and to diff) values. It therefore does not need to know about the context in which the comparison was made, since the caller can supply that. If your common testing code provides a cmp.Transformer for your data type, that can often be the simplest design. For other validations, consider returning an error value.</paragraph><code language="javascript">// Good:
// polygonCmp returns a cmp.Option that equates s2 geometry objects up to
// some small floating-point error.
func polygonCmp() cmp.Option {
    return cmp.Options{
        cmp.Transformer("polygon", func(p *s2.Polygon) []*s2.Loop { return p.Loops() }),
        cmp.Transformer("loop", func(l *s2.Loop) []s2.Point { return l.Vertices() }),
        cmpopts.EquateApprox(0.00000001, 0),
        cmpopts.EquateEmpty(),
    }
}

func TestFenceposts(t *testing.T) {
    // This is a test for a fictional function, Fenceposts, which draws a fence
    // around some Place object. The details are not important, except that
    // the result is some object that has s2 geometry (github.com/golang/geo/s2)
    got := Fencepost(tomsDiner, 1*meter)
    if diff := cmp.Diff(want, got, polygonCmp()); diff != "" {
        t.Errorf("Fencepost(tomsDiner, 1m) returned unexpected diff (-want+got):\n%v", diff)
    }
}

func FuzzFencepost(f *testing.F) {
    // Fuzz test (https://go.dev/doc/fuzz) for the same.

    f.Add(tomsDiner, 1*meter)
    f.Add(school, 3*meter)

    f.Fuzz(func(t *testing.T, geo Place, padding Length) {
        got := Fencepost(geo, padding)
        // Simple reference implementation: not used in prod, but easy to
        // reason about and therefore useful to check against in random tests.
        reference := slowFencepost(geo, padding)

        // In the fuzz test, inputs and outputs can be large so don't
        // bother with printing a diff. cmp.Equal is enough.
        if !cmp.Equal(got, reference, polygonCmp()) {
            t.Errorf("Fencepost returned wrong placement")
        }
    })
}
</code><paragraph>The polygonCmp function is agnostic about how it's called; it doesn't take a concrete input type nor does it police what to do in case two objects don't match. Therefore, more callers can make use of it.</paragraph><paragraph>Note: There is an analogy between test helpers and plain library code. Code in libraries should usually not panic except in rare circumstances; code called from a test should not stop the test unless there is no point in proceeding.</paragraph><heading level="3">Designing extensible validation APIs</heading><paragraph>Most of the advice about testing in the style guide is about testing your own code. This section is about how to provide facilities for other people to test the code they write to ensure that it conforms to your library's requirements.</paragraph><heading level="4">Acceptance testing</heading><paragraph>Such testing is referred to as acceptance testing. The premise of this kind of testing is that the person using the test does not know every last detail of what goes on in the test; they just hand the inputs over to the testing facility to do the work. This can be thought of as a form of inversion of control.</paragraph><paragraph>In a typical Go test, the test function controls the program flow, and the no assert and test functions guidance encourages you to keep it that way. This section explains how to author support for these tests in a way that is consistent with Go style.</paragraph><paragraph>Before diving into how, consider an example from io/fs, excerpted below:</paragraph><code language="javascript">type FS interface {
    Open(name string) (File, error)
}
</code><paragraph>While there exist well-known implementations of fs.FS, a Go developer may be expected to author one. To help validate the user-implemented fs.FS is correct, a generic library has been provided in testing/fstest called fstest.TestFS. This API treats the implementation as a blackbox to make sure it upholds the most basic parts of the io/fs contract.</paragraph><heading level="4">Writing an acceptance test</heading><paragraph>Now that we know what an acceptance test is and why you might use one, let's explore building an acceptance test for package chess, a package used to simulate chess games. Users of chess are expected to implement the chess.Player interface. These implementations are the primary thing we will validate. Our acceptance test concerns itself with whether the player implementation makes legal moves, not whether the moves are smart.</paragraph><list type="ol"><item>Create a new package for the validation behavior, customarily named by appending the word test to the package name (for example, chesstest).</item><item>Create the function that performs the validation by accepting the implementation under test as an argument and exercises it: // ExercisePlayer tests a Player implementation in a single turn on a board. // The board itself is spot checked for sensibility and correctness. // // It returns a nil error if the player makes a correct move in the context // of the provided board. Otherwise ExercisePlayer returns one of this // package's errors to indicate how and why the player failed the // validation. func ExercisePlayer(b *chess.Board, p chess.Player) error The test should note which invariants are broken and how. Your design can choose between two disciplines for failure reporting: Fail fast: return an error as soon as the implementation violates an invariant. This is the simplest approach, and it works well if the acceptance test is expected to execute quickly. Simple error sentinels and custom types can be used easily here, which conversely makes testing the acceptance test easy. for color, army := range b.Armies { // The king should never leave the board, because the game ends at // checkmate. if army.King == nil { return &MissingPieceError{Color: color, Piece: chess.King} } } Aggregate all failures: collect all failures, and report them all. This approach resembles the keep going guidance in feel and may be preferable if the acceptance test is expected to execute slowly. How you aggregate the failures should be dictated by whether you want to give users the ability or yourself the ability to interrogate individual failures (for example, for you to test your acceptance test). Below demonstrates using a custom error type that aggregates errors: var badMoves []error move := p.Move() if putsOwnKingIntoCheck(b, move) { badMoves = append(badMoves, PutsSelfIntoCheckError{Move: move}) } if len(badMoves) > 0 { return SimulationError{BadMoves: badMoves} } return nil</item></list><paragraph>Create a new package for the validation behavior, customarily named by appending the word test to the package name (for example, chesstest).</paragraph><paragraph>Create the function that performs the validation by accepting the implementation under test as an argument and exercises it:</paragraph><code language="go">// ExercisePlayer tests a Player implementation in a single turn on a board.
// The board itself is spot checked for sensibility and correctness.
//
// It returns a nil error if the player makes a correct move in the context
// of the provided board. Otherwise ExercisePlayer returns one of this
// package's errors to indicate how and why the player failed the
// validation.
func ExercisePlayer(b *chess.Board, p chess.Player) error
</code><paragraph>The test should note which invariants are broken and how. Your design can choose between two disciplines for failure reporting:</paragraph><list type="ul"><item>Fail fast: return an error as soon as the implementation violates an invariant. This is the simplest approach, and it works well if the acceptance test is expected to execute quickly. Simple error sentinels and custom types can be used easily here, which conversely makes testing the acceptance test easy. for color, army := range b.Armies { // The king should never leave the board, because the game ends at // checkmate. if army.King == nil { return &MissingPieceError{Color: color, Piece: chess.King} } }</item><item>Aggregate all failures: collect all failures, and report them all. This approach resembles the keep going guidance in feel and may be preferable if the acceptance test is expected to execute slowly. How you aggregate the failures should be dictated by whether you want to give users the ability or yourself the ability to interrogate individual failures (for example, for you to test your acceptance test). Below demonstrates using a custom error type that aggregates errors: var badMoves []error move := p.Move() if putsOwnKingIntoCheck(b, move) { badMoves = append(badMoves, PutsSelfIntoCheckError{Move: move}) } if len(badMoves) > 0 { return SimulationError{BadMoves: badMoves} } return nil</item></list><paragraph>Fail fast: return an error as soon as the implementation violates an invariant.</paragraph><paragraph>This is the simplest approach, and it works well if the acceptance test is expected to execute quickly. Simple error sentinels and custom types can be used easily here, which conversely makes testing the acceptance test easy.</paragraph><code language="javascript">for color, army := range b.Armies {
    // The king should never leave the board, because the game ends at
    // checkmate.
    if army.King == nil {
        return &MissingPieceError{Color: color, Piece: chess.King}
    }
}
</code><paragraph>Aggregate all failures: collect all failures, and report them all.</paragraph><paragraph>This approach resembles the keep going guidance in feel and may be preferable if the acceptance test is expected to execute slowly.</paragraph><paragraph>How you aggregate the failures should be dictated by whether you want to give users the ability or yourself the ability to interrogate individual failures (for example, for you to test your acceptance test). Below demonstrates using a custom error type that aggregates errors:</paragraph><code language="javascript">var badMoves []error

move := p.Move()
if putsOwnKingIntoCheck(b, move) {
    badMoves = append(badMoves, PutsSelfIntoCheckError{Move: move})
}

if len(badMoves) > 0 {
    return SimulationError{BadMoves: badMoves}
}
return nil
</code><paragraph>The acceptance test should honor the keep going guidance by not calling t.Fatal unless the test detects a broken invariant in the system being exercised.</paragraph><paragraph>For example, t.Fatal should be reserved for exceptional cases such as setup failure as usual:</paragraph><code language="javascript">func ExerciseGame(t *testing.T, cfg *Config, p chess.Player) error {
    t.Helper()

    if cfg.Simulation == Modem {
        conn, err := modempool.Allocate()
        if err != nil {
            t.Fatalf("No modem for the opponent could be provisioned: %v", err)
        }
        t.Cleanup(func() { modempool.Return(conn) })
    }
    // Run acceptance test (a whole game).
}
</code><paragraph>This technique can help you create concise, canonical validations. But do not attempt to use it to bypass the guidance on assertions.</paragraph><paragraph>The final product should be in a form similar to this for end users:</paragraph><code language="javascript">// Good:
package deepblue_test

import (
    "chesstest"
    "deepblue"
)

func TestAcceptance(t *testing.T) {
    player := deepblue.New()
    err := chesstest.ExerciseGame(t, chesstest.SimpleGame, player)
    if err != nil {
        t.Errorf("Deep Blue player failed acceptance test: %v", err)
    }
}
</code><heading level="3">Use real transports</heading><paragraph>When testing component integrations, especially where HTTP or RPC are used as the underlying transport between the components, prefer using the real underlying transport to connect to the test version of the backend.</paragraph><paragraph>For example, suppose the code you want to test (sometimes referred to as "system under test" or SUT) interacts with a backend that implements the long running operations API. To test your SUT, use a real OperationsClient that is connected to a test double (e.g., a mock, stub, or fake) of the OperationsServer.</paragraph><paragraph>This is recommended over hand-implementing the client, due to the complexity of imitating client behavior correctly. By using the production client with a test-specific server, you ensure your test is using as much of the real code as possible.</paragraph><paragraph>Tip: Where possible, use a testing library provided by the authors of the service under test.</paragraph><heading level="3">t.Error vs. t.Fatal</heading><paragraph>As discussed in decisions, tests should generally not abort at the first encountered problem.</paragraph><paragraph>However, some situations require that the test not proceed. Calling t.Fatal is appropriate when some piece of test setup fails, especially in test setup helpers, without which you cannot run the rest of the test. In a table-driven test, t.Fatal is appropriate for failures that set up the whole test function before the test loop. Failures that affect a single entry in the test table, which make it impossible to continue with that entry, should be reported as follows:</paragraph><list type="ul"><item>If you're not using t.Run subtests, use t.Error followed by a continue statement to move on to the next table entry.</item><item>If you're using subtests (and you're inside a call to t.Run), use t.Fatal, which ends the current subtest and allows your test case to progress to the next subtest.</item></list><paragraph>Warning: It is not always safe to call t.Fatal and similar functions. More details here.</paragraph><heading level="3">Error handling in test helpers</heading><paragraph>Note: This section discusses test helpers in the sense Go uses the term: functions that perform test setup and cleanup, not common assertion facilities. See the test functions section for more discussion.</paragraph><paragraph>Operations performed by a test helper sometimes fail. For example, setting up a directory with files involves I/O, which can fail. When test helpers fail, their failure often signifies that the test cannot continue, since a setup precondition failed. When this happens, prefer calling one of the Fatal functions in the helper:</paragraph><code language="javascript">// Good:
func mustAddGameAssets(t *testing.T, dir string) {
    t.Helper()
    if err := os.WriteFile(path.Join(dir, "pak0.pak"), pak0, 0644); err != nil {
        t.Fatalf("Setup failed: could not write pak0 asset: %v", err)
    }
    if err := os.WriteFile(path.Join(dir, "pak1.pak"), pak1, 0644); err != nil {
        t.Fatalf("Setup failed: could not write pak1 asset: %v", err)
    }
}
</code><paragraph>This keeps the calling side cleaner than if the helper were to return the error to the test itself:</paragraph><code language="javascript">// Bad:
func addGameAssets(t *testing.T, dir string) error {
    t.Helper()
    if err := os.WriteFile(path.Join(d, "pak0.pak"), pak0, 0644); err != nil {
        return err
    }
    if err := os.WriteFile(path.Join(d, "pak1.pak"), pak1, 0644); err != nil {
        return err
    }
    return nil
}
</code><paragraph>Warning: It is not always safe to call t.Fatal and similar functions. More details here.</paragraph><paragraph>The failure message should include a description of what happened. This is important, as you may be providing a testing API to many users, especially as the number of error-producing steps in the helper increases. When the test fails, the user should know where, and why.</paragraph><paragraph>Tip: Go 1.14 introduced a t.Cleanup function that can be used to register cleanup functions that run when your test completes. The function also works with test helpers. See GoTip #4: Cleaning Up Your Tests for guidance on simplifying test helpers.</paragraph><paragraph>The snippet below in a fictional file called paint_test.go demonstrates how (*testing.T).Helper influences failure reporting in a Go test:</paragraph><code language="javascript">package paint_test

import (
    "fmt"
    "testing"
)

func paint(color string) error {
    return fmt.Errorf("no %q paint today", color)
}

func badSetup(t *testing.T) {
    // This should call t.Helper, but doesn't.
    if err := paint("taupe"); err != nil {
        t.Fatalf("Could not paint the house under test: %v", err) // line 15
    }
}

func mustGoodSetup(t *testing.T) {
    t.Helper()
    if err := paint("lilac"); err != nil {
        t.Fatalf("Could not paint the house under test: %v", err)
    }
}

func TestBad(t *testing.T) {
    badSetup(t)
    // ...
}

func TestGood(t *testing.T) {
    mustGoodSetup(t) // line 32
    // ...
}
</code><paragraph>Here is an example of this output when run. Note the highlighted text and how it differs:</paragraph><code language="code">=== RUN   TestBad
    paint_test.go:15: Could not paint the house under test: no "taupe" paint today
--- FAIL: TestBad (0.00s)
=== RUN   TestGood
    paint_test.go:32: Could not paint the house under test: no "lilac" paint today
--- FAIL: TestGood (0.00s)
FAIL
</code><paragraph>The error with paint_test.go:15 refers to the line of the setup function that failed in badSetup:</paragraph><paragraph>t.Fatalf("Could not paint the house under test: %v", err)</paragraph><paragraph>Whereas paint_test.go:32 refers to the line of the test that failed in TestGood:</paragraph><paragraph>goodSetup(t)</paragraph><paragraph>Correctly using (*testing.T).Helper attributes the location of the failure much better when:</paragraph><list type="ul"><item>the helper functions grow</item><item>the helper functions call other helpers</item><item>the amount of helper usage in the test functions grow</item></list><paragraph>Tip: If a helper calls (*testing.T).Error or (*testing.T).Fatal, provide some context in the format string to help determine what went wrong and why.</paragraph><paragraph>Tip: If nothing a helper does can cause a test to fail, it doesn't need to call t.Helper. Simplify its signature by removing t from the function parameter list.</paragraph><heading level="3">Don't call t.Fatal from separate goroutines</heading><paragraph>As documented in package testing, it is incorrect to call t.FailNow, t.Fatal, etc. from any goroutine but the one running the Test function (or the subtest). If your test starts new goroutines, they must not call these functions from inside these goroutines.</paragraph><paragraph>Test helpers usually don't signal failure from new goroutines, and therefore it is all right for them to use t.Fatal. If in doubt, call t.Error and return instead.</paragraph><code language="javascript">// Good:
func TestRevEngine(t *testing.T) {
    engine, err := Start()
    if err != nil {
        t.Fatalf("Engine failed to start: %v", err)
    }

    num := 11
    var wg sync.WaitGroup
    wg.Add(num)
    for i := 0; i < num; i++ {
        go func() {
            defer wg.Done()
            if err := engine.Vroom(); err != nil {
                // This cannot be t.Fatalf.
                t.Errorf("No vroom left on engine: %v", err)
                return
            }
            if rpm := engine.Tachometer(); rpm > 1e6 {
                t.Errorf("Inconceivable engine rate: %d", rpm)
            }
        }()
    }
    wg.Wait()

    if seen := engine.NumVrooms(); seen != num {
        t.Errorf("engine.NumVrooms() = %d, want %d", seen, num)
    }
}
</code><paragraph>Adding t.Parallel to a test or subtest does not make it unsafe to call t.Fatal.</paragraph><paragraph>When all calls to the testing API are in the test function, it is usually easy to spot incorrect usage because the go keyword is plain to see. Passing testing.T arguments around makes tracking such usage harder. Typically, the reason for passing these arguments is to introduce a test helper, and those should not depend on the system under test. Therefore, if a test helper registers a fatal test failure, it can and should do so from the test's goroutine.</paragraph><heading level="3">Use field names in struct literals</heading><paragraph>In table-driven tests, prefer to specify field names when initializing test case struct literals. This is helpful when the test cases cover a large amount of vertical space (e.g. more than 20-30 lines), when there are adjacent fields with the same type, and also when you wish to omit fields which have the zero value. For example:</paragraph><code language="javascript">// Good:
func TestStrJoin(t *testing.T) {
    tests := []struct {
        slice     []string
        separator string
        skipEmpty bool
        want      string
    }{
        {
            slice:     []string{"a", "b", ""},
            separator: ",",
            want:      "a,b,",
        },
        {
            slice:     []string{"a", "b", ""},
            separator: ",",
            skipEmpty: true,
            want:      "a,b",
        },
        // ...
    }
    // ...
}
</code><heading level="3">Keep setup code scoped to specific tests</heading><paragraph>Where possible, setup of resources and dependencies should be as closely scoped to specific test cases as possible. For example, given a setup function:</paragraph><code language="javascript">// mustLoadDataSet loads a data set for the tests.
//
// This example is very simple and easy to read. Often realistic setup is more
// complex, error-prone, and potentially slow.
func mustLoadDataset(t *testing.T) []byte {
    t.Helper()
    data, err := os.ReadFile("path/to/your/project/testdata/dataset")

    if err != nil {
        t.Fatalf("Could not load dataset: %v", err)
    }
    return data
}
</code><paragraph>Call mustLoadDataset explicitly in test functions that need it:</paragraph><code language="javascript">// Good:
func TestParseData(t *testing.T) {
    data := mustLoadDataset(t)
    parsed, err := ParseData(data)
    if err != nil {
        t.Fatalf("Unexpected error parsing data: %v", err)
    }
    want := &DataTable{ /* ... */ }
    if got := parsed; !cmp.Equal(got, want) {
        t.Errorf("ParseData(data) = %v, want %v", got, want)
    }
}

func TestListContents(t *testing.T) {
    data := mustLoadDataset(t)
    contents, err := ListContents(data)
    if err != nil {
        t.Fatalf("Unexpected error listing contents: %v", err)
    }
    want := []string{ /* ... */ }
    if got := contents; !cmp.Equal(got, want) {
        t.Errorf("ListContents(data) = %v, want %v", got, want)
    }
}

func TestRegression682831(t *testing.T) {
    if got, want := guessOS("zpc79.example.com"), "grhat"; got != want {
        t.Errorf(`guessOS("zpc79.example.com") = %q, want %q`, got, want)
    }
}
</code><paragraph>The test function TestRegression682831 does not use the data set and therefore does not call mustLoadDataset, which could be slow and failure-prone:</paragraph><code language="javascript">// Bad:
var dataset []byte

func TestParseData(t *testing.T) {
    // As documented above without calling mustLoadDataset directly.
}

func TestListContents(t *testing.T) {
    // As documented above without calling mustLoadDataset directly.
}

func TestRegression682831(t *testing.T) {
    if got, want := guessOS("zpc79.example.com"), "grhat"; got != want {
        t.Errorf(`guessOS("zpc79.example.com") = %q, want %q`, got, want)
    }
}

func init() {
    dataset = mustLoadDataset()
}
</code><paragraph>A user may wish to run a function in isolation of the others and should not be penalized by these factors:</paragraph><code language="code"># No reason for this to perform the expensive initialization.
$ go test -run TestRegression682831
</code><heading level="4">When to use a custom TestMain entrypoint</heading><paragraph>If all tests in the package require common setup and the setup requires teardown, you can use a custom testmain entrypoint. This can happen if the resource the test cases require is especially expensive to setup, and the cost should be amortized. Typically you have extracted any unrelated tests from the test suite at that point. It is typically only used for functional tests.</paragraph><paragraph>Using a custom TestMain should not be your first choice due the amount of care that should be taken for correct use. Consider first whether the solution in the amortizing common test setup section or an ordinary test helper is sufficient for your needs.</paragraph><code language="javascript">// Good:
var db *sql.DB

func TestInsert(t *testing.T) { /* omitted */ }

func TestSelect(t *testing.T) { /* omitted */ }

func TestUpdate(t *testing.T) { /* omitted */ }

func TestDelete(t *testing.T) { /* omitted */ }

// runMain sets up the test dependencies and eventually executes the tests.
// It is defined as a separate function to enable the setup stages to clearly
// defer their teardown steps.
func runMain(ctx context.Context, m *testing.M) (code int, err error) {
    ctx, cancel := context.WithCancel(ctx)
    defer cancel()

    d, err := setupDatabase(ctx)
    if err != nil {
        return 0, err
    }
    defer d.Close() // Expressly clean up database.
    db = d          // db is defined as a package-level variable.

    // m.Run() executes the regular, user-defined test functions.
    // Any defer statements that have been made will be run after m.Run()
    // completes.
    return m.Run(), nil
}

func TestMain(m *testing.M) {
    code, err := runMain(context.Background(), m)
    if err != nil {
        // Failure messages should be written to STDERR, which log.Fatal uses.
        log.Fatal(err)
    }
    // NOTE: defer statements do not run past here due to os.Exit
    //       terminating the process.
    os.Exit(code)
}
</code><paragraph>Ideally a test case is hermetic between invocations of itself and between other test cases.</paragraph><paragraph>At the very least, ensure that individual test cases reset any global state they have modified if they have done so (for instance, if the tests are working with an external database).</paragraph><heading level="4">Amortizing common test setup</heading><paragraph>Using a sync.Once may be appropriate, though not required, if all of the following are true about the common setup:</paragraph><list type="ul"><item>It is expensive.</item><item>It only applies to some tests.</item><item>It does not require teardown.</item></list><code language="javascript">// Good:
var dataset struct {
    once sync.Once
    data []byte
    err  error
}

func mustLoadDataset(t *testing.T) []byte {
    t.Helper()
    dataset.once.Do(func() {
        data, err := os.ReadFile("path/to/your/project/testdata/dataset")
        // dataset is defined as a package-level variable.
        dataset.data = data
        dataset.err = err
    })
    if err := dataset.err; err != nil {
        t.Fatalf("Could not load dataset: %v", err)
    }
    return dataset.data
}
</code><paragraph>When mustLoadDataset is used in multiple test functions, its cost is amortized:</paragraph><code language="javascript">// Good:
func TestParseData(t *testing.T) {
    data := mustLoadDataset(t)

    // As documented above.
}

func TestListContents(t *testing.T) {
    data := mustLoadDataset(t)

    // As documented above.
}

func TestRegression682831(t *testing.T) {
    if got, want := guessOS("zpc79.example.com"), "grhat"; got != want {
        t.Errorf(`guessOS("zpc79.example.com") = %q, want %q`, got, want)
    }
}
</code><paragraph>The reason that common teardown is tricky is there is no uniform place to register cleanup routines. If the setup function (in this case loadDataset) relies on a context, sync.Once may be problematic. This is because the second of two racing calls to the setup function would need to wait for the first call to finish before returning. This period of waiting cannot be easily made to respect the context's cancellation.</paragraph><heading level="2">String concatenation</heading><paragraph>There are several ways to concatenate strings in Go. Some examples include:</paragraph><list type="ul"><item>The "+" operator</item><item>fmt.Sprintf</item><item>strings.Builder</item><item>text/template</item><item>safehtml/template</item></list><paragraph>Though there is no one-size-fits-all rule for which to choose, the following guidance outlines when each method is preferred.</paragraph><heading level="3">Prefer "+" for simple cases</heading><paragraph>Prefer using "+" when concatenating few strings. This method is syntactically the simplest and requires no import.</paragraph><code language="code">// Good:
key := "projectid: " + p
</code><heading level="3">Prefer fmt.Sprintf when formatting</heading><paragraph>Prefer using fmt.Sprintf when building a complex string with formatting. Using many "+" operators may obscure the end result.</paragraph><code language="code">// Good:
str := fmt.Sprintf("%s [%s:%d]-> %s", src, qos, mtu, dst)
</code><code language="code">// Bad:
bad := src.String() + " [" + qos.String() + ":" + strconv.Itoa(mtu) + "]-> " + dst.String()
</code><paragraph>Best Practice: When the output of the string-building operation is an io.Writer, don't construct a temporary string with fmt.Sprintf just to send it to the Writer. Instead, use fmt.Fprintf to emit to the Writer directly.</paragraph><paragraph>When the formatting is even more complex, prefer text/template or safehtml/template as appropriate.</paragraph><heading level="3">Prefer strings.Builder for constructing a string piecemeal</heading><paragraph>Prefer using strings.Builder when building a string bit-by-bit. strings.Builder takes amortized linear time, whereas "+" and fmt.Sprintf take quadratic time when called sequentially to form a larger string.</paragraph><code language="javascript">// Good:
b := new(strings.Builder)
for i, d := range digitsOfPi {
    fmt.Fprintf(b, "the %d digit of pi is: %d\n", i, d)
}
str := b.String()
</code><paragraph>Note: For more discussion, see GoTip #29: Building Strings Efficiently.</paragraph><heading level="3">Constant strings</heading><paragraph>Prefer to use backticks (`) when constructing constant, multi-line string literals.</paragraph><code language="code">// Good:
usage := `Usage:

custom_tool [args]`
</code><code language="code">// Bad:
usage := "" +
  "Usage:\n" +
  "\n" +
  "custom_tool [args]"
</code><heading level="2">Global state</heading><paragraph>Libraries should not force their clients to use APIs that rely on global state. They are advised not to expose APIs or export package level variables that control behavior for all clients as parts of their API. The rest of the section uses "global" and "package level state" synonymously.</paragraph><paragraph>Instead, if your functionality maintains state, allow your clients to create and use instance values.</paragraph><paragraph>Important: While this guidance is applicable to all developers, it is most critical for infrastructure providers who offer libraries, integrations, and services to other teams.</paragraph><code language="go">// Good:
// Package sidecar manages subprocesses that provide features for applications.
package sidecar

type Registry struct { plugins map[string]*Plugin }

func New() *Registry { return &Registry{plugins: make(map[string]*Plugin)} }

func (r *Registry) Register(name string, p *Plugin) error { ... }
</code><paragraph>Your users will instantiate the data they need (a *sidecar.Registry) and then pass it as an explicit dependency:</paragraph><code language="javascript">// Good:
package main

func main() {
  sidecars := sidecar.New()
  if err := sidecars.Register("Cloud Logger", cloudlogger.New()); err != nil {
    log.Exitf("Could not setup cloud logger: %v", err)
  }
  cfg := &myapp.Config{Sidecars: sidecars}
  myapp.Run(context.Background(), cfg)
}
</code><paragraph>There are different approaches to migrating existing code to support dependency passing. The main one you will use is passing dependencies as parameters to constructors, functions, methods, or struct fields on the call chain.</paragraph><paragraph>See also:</paragraph><paragraph>APIs that do not support explicit dependency passing become fragile as the number of clients increases:</paragraph><code language="javascript">// Bad:
package sidecar

var registry = make(map[string]*Plugin)

func Register(name string, p *Plugin) error { /* registers plugin in registry */ }
</code><paragraph>Consider what happens in the case of tests exercising code that transitively relies on a sidecar for cloud logging.</paragraph><code language="javascript">// Bad:
package app

import (
  "cloudlogger"
  "sidecar"
  "testing"
)

func TestEndToEnd(t *testing.T) {
  // The system under test (SUT) relies on a sidecar for a production cloud
  // logger already being registered.
  ... // Exercise SUT and check invariants.
}

func TestRegression_NetworkUnavailability(t *testing.T) {
  // We had an outage because of a network partition that rendered the cloud
  // logger inoperative, so we added a regression test to exercise the SUT with
  // a test double that simulates network unavailability with the logger.
  sidecar.Register("cloudlogger", cloudloggertest.UnavailableLogger)
  ... // Exercise SUT and check invariants.
}

func TestRegression_InvalidUser(t *testing.T) {
  // The system under test (SUT) relies on a sidecar for a production cloud
  // logger already being registered.
  //
  // Oops. cloudloggertest.UnavailableLogger is still registered from the
  // previous test.
  ... // Exercise SUT and check invariants.
}
</code><paragraph>Go tests are executed sequentially by default, so the tests above run as:</paragraph><list type="ol"><item>TestEndToEnd</item><item>TestRegression_NetworkUnavailability, which overrides the default value of cloudlogger</item><item>TestRegression_InvalidUser, which requires the default value of cloudlogger registered in package sidecar</item></list><paragraph>This creates an order-dependent test case, which breaks running with test filters, and prevents tests from running in parallel or being sharded.</paragraph><paragraph>Using global state poses problems that lack easy answers for you and the API's clients:</paragraph><list type="ul"><item>What happens if a client needs to use different and separately operating sets of Plugins (for example, to support multiple servers) in the same process space?</item><item>What happens if a client wants to replace a registered Plugin with an alternative implementation in a test, like a test double? What happens if a client's tests require hermeticity between instances of a Plugin, or between all of the plugins registered?</item><item>What happens if multiple clients Register a Plugin under the same name? Which one wins, if any? How should errors be handled? If the code panics or calls log.Fatal, will that always be appropriate for all places in which API would be called? Can a client verify it doesn't do something bad before doing so?</item><item>Are there certain stages in a program's startup phases or lifetime during which Register can be called and when it can't? What happens if Register is called at the wrong time? A client could call Register in func init, before flags are parsed, or after main. The stage at which a function is called affects error handling. If the author of an API assumes the API is only called during program initialization without the requirement that it is, the assumption may nudge the author to design error handling to abort the program by modeling the API as a Must-like function. Aborting is not appropriate for general-purpose library functions that can be used at any stage.</item><item>What if the client's and the designer's concurrency needs are mismatched?</item></list><paragraph>What happens if a client needs to use different and separately operating sets of Plugins (for example, to support multiple servers) in the same process space?</paragraph><paragraph>What happens if a client wants to replace a registered Plugin with an alternative implementation in a test, like a test double?</paragraph><paragraph>What happens if a client's tests require hermeticity between instances of a Plugin, or between all of the plugins registered?</paragraph><paragraph>What happens if multiple clients Register a Plugin under the same name? Which one wins, if any?</paragraph><paragraph>How should errors be handled? If the code panics or calls log.Fatal, will that always be appropriate for all places in which API would be called? Can a client verify it doesn't do something bad before doing so?</paragraph><paragraph>Are there certain stages in a program's startup phases or lifetime during which Register can be called and when it can't?</paragraph><paragraph>What happens if Register is called at the wrong time? A client could call Register in func init, before flags are parsed, or after main. The stage at which a function is called affects error handling. If the author of an API assumes the API is only called during program initialization without the requirement that it is, the assumption may nudge the author to design error handling to abort the program by modeling the API as a Must-like function. Aborting is not appropriate for general-purpose library functions that can be used at any stage.</paragraph><paragraph>What if the client's and the designer's concurrency needs are mismatched?</paragraph><paragraph>See also:</paragraph><paragraph>Global state has cascading effects on the health of the Google codebase. Global state should be approached with extreme scrutiny.</paragraph><paragraph>Global state comes in several forms, and you can use a few litmus tests to identify when it is safe.</paragraph><heading level="3">Major forms of package state APIs</heading><paragraph>Several of the most common problematic API forms are enumerated below:</paragraph><list type="ul"><item>Top-level variables irrespective of whether they are exported. // Bad: package logger // Sinks manages the default output sources for this package's logging API. This // variable should be set at package initialization time and never thereafter. var Sinks []Sink See the litmus tests to know when these are safe.</item><item>The service locator pattern. See the first example. The service locator pattern itself is not problematic, rather the locator being defined as global.</item><item>Registries for callbacks and similar behaviors. // Bad: package health var unhealthyFuncs []func func OnUnhealthy(f func()) { unhealthyFuncs = append(unhealthyFuncs, f) }</item><item>Thick-Client singletons for things like backends, storage, data access layers, and other system resources. These often pose additional problems with service reliability. // Bad: package useradmin var client pb.UserAdminServiceClientInterface func Client() *pb.UserAdminServiceClient { if client == nil { client = ... // Set up client. } return client }</item></list><paragraph>Top-level variables irrespective of whether they are exported.</paragraph><code language="javascript">// Bad:
package logger

// Sinks manages the default output sources for this package's logging API.  This
// variable should be set at package initialization time and never thereafter.
var Sinks []Sink
</code><paragraph>See the litmus tests to know when these are safe.</paragraph><paragraph>The service locator pattern. See the first example. The service locator pattern itself is not problematic, rather the locator being defined as global.</paragraph><paragraph>Registries for callbacks and similar behaviors.</paragraph><code language="javascript">// Bad:
package health

var unhealthyFuncs []func

func OnUnhealthy(f func()) {
  unhealthyFuncs = append(unhealthyFuncs, f)
}
</code><paragraph>Thick-Client singletons for things like backends, storage, data access layers, and other system resources. These often pose additional problems with service reliability.</paragraph><code language="javascript">// Bad:
package useradmin

var client pb.UserAdminServiceClientInterface

func Client() *pb.UserAdminServiceClient {
    if client == nil {
        client = ...  // Set up client.
    }
    return client
}
</code><paragraph>Note: Many legacy APIs in the Google codebase do not follow this guidance; in fact, some Go standard libraries allow for configuration via global values. Nevertheless, the legacy API's contravention of this guidance should not be used as precedent for continuing the pattern.</paragraph><paragraph>It is better to invest in proper API design today than pay for redesigning later.</paragraph><heading level="3">Litmus tests</heading><paragraph>APIs using the patterns above are unsafe when:</paragraph><list type="ul"><item>Multiple functions interact via global state when executed in the same program, despite being otherwise independent (for example, authored by different authors in vastly different directories).</item><item>Independent test cases interact with each other through global state.</item><item>Users of the API are tempted to swap or replace global state for testing purposes, particularly to replace any part of the state with a test double, like a stub, fake, spy, or mock.</item><item>Users have to consider special ordering requirements when interacting with global state: func init, whether flags are parsed yet, etc.</item></list><paragraph>Provided the conditions above are avoided, there are a few limited circumstances under which these APIs are safe, namely when any of the following is true:</paragraph><list type="ul"><item>The global state is logically constant (example).</item><item>The package's observable behavior is stateless. For example, a public function may use a private global variable as a cache, but so long as the caller can't distinguish cache hits from misses, the function is stateless.</item><item>The global state does not bleed into things that are external to the program, like sidecar processes or files on a shared filesystem.</item><item>There is no expectation of predictable behavior (example).</item></list><paragraph>Note: Sidecar processes may not strictly be process-local. They can and often are shared with more than one application process. Moreover, these sidecars often interact with external distributed systems.</paragraph><paragraph>Further, the same stateless, idempotent, and local rules in addition to the base considerations above would apply to the code of the sidecar process itself!</paragraph><paragraph>An example of one of these safe situations is package image with its image.RegisterFormat function. Consider the litmus tests from above applied to a typical decoder, like the one for handling the PNG format:</paragraph><list type="ul"><item>Multiple calls to package image's APIs that use the registered decoders (for example, image.Decode) cannot interfere with one another, similarly for tests. The only exception is image.RegisterFormat, but that is mitigated by the points below.</item><item>It is extremely unlikely that a user would want to replace a decoder with a test double, as the PNG decoder exemplifies a case in which our codebase's preference for real objects applies. However, a user would be more likely to replace a decoder with a test double if the decoder statefully interacted with operating system resources (for example, the network).</item><item>Collisions in registration are conceivable, though they are probably rare in practice.</item><item>The decoders are stateless, idempotent, and pure.</item></list><heading level="3">Providing a default instance</heading><paragraph>While not recommended, it is acceptable to provide a simplified API that uses package level state if you need to maximize convenience for the user.</paragraph><paragraph>Follow the litmus tests with these guidelines in such cases:</paragraph><list type="ol"><item>The package must offer clients the ability to create isolated instances of package types as described above.</item><item>The public APIs that use global state must be a thin proxy to the previous API. A good example of this is http.Handle internally calling (*http.ServeMux).Handle on the package variable http.DefaultServeMux.</item><item>This package-level API must only be used by binary build targets, not libraries, unless the libraries are undertaking a refactoring to support dependency passing. Infrastructure libraries that can be imported by other packages must not rely on package-level state of the packages they import. For example, an infrastructure provider implementing a sidecar that is to be shared with other teams using the API from the top should offer an API to accommodate this: // Good: package cloudlogger func New() *Logger { ... } func Register(r *sidecar.Registry, l *Logger) { r.Register("Cloud Logging", l) }</item><item>This package-level API must document and enforce its invariants (for example, at which stage in the program's life it can be called, whether it can be used concurrently). Further, it must provide an API to reset global state to a known-good default (for example, to facilitate testing).</item></list><paragraph>This package-level API must only be used by binary build targets, not libraries, unless the libraries are undertaking a refactoring to support dependency passing. Infrastructure libraries that can be imported by other packages must not rely on package-level state of the packages they import.</paragraph><paragraph>For example, an infrastructure provider implementing a sidecar that is to be shared with other teams using the API from the top should offer an API to accommodate this:</paragraph><code language="javascript">// Good:
package cloudlogger

func New() *Logger { ... }

func Register(r *sidecar.Registry, l *Logger) {
  r.Register("Cloud Logging", l)
}
</code><paragraph>See also:</paragraph></content>
</page>
<page url="https://google.github.io/styleguide/go/guide.html">
<title>styleguide | Style guides for Google-originated open-source projects</title>
<content><heading level="1">Go Style Guide</heading><paragraph>https://google.github.io/styleguide/go/guide</paragraph><paragraph>Overview | Guide | Decisions | Best practices</paragraph><paragraph>Note: This is part of a series of documents that outline Go Style at Google. This document is normative and canonical. See the overview for more information.</paragraph><heading level="2">Style principles</heading><paragraph>There are a few overarching principles that summarize how to think about writing readable Go code. The following are attributes of readable code, in order of importance:</paragraph><list type="ol"><item>Clarity: The code's purpose and rationale is clear to the reader.</item><item>Simplicity: The code accomplishes its goal in the simplest way possible.</item><item>Concision: The code has a high signal-to-noise ratio.</item><item>Maintainability: The code is written such that it can be easily maintained.</item><item>Consistency: The code is consistent with the broader Google codebase.</item></list><heading level="3">Clarity</heading><paragraph>The core goal of readability is to produce code that is clear to the reader.</paragraph><paragraph>Clarity is primarily achieved with effective naming, helpful commentary, and efficient code organization.</paragraph><paragraph>Clarity is to be viewed through the lens of the reader, not the author of the code. It is more important that code be easy to read than easy to write. Clarity in code has two distinct facets:</paragraph><heading level="4">What is the code actually doing?</heading><paragraph>Go is designed such that it should be relatively straightforward to see what the code is doing. In cases of uncertainty or where a reader may require prior knowledge in order to understand the code, it is worth investing time in order to make the code's purpose clearer for future readers. For example, it may help to:</paragraph><list type="ul"><item>Use more descriptive variable names</item><item>Add additional commentary</item><item>Break up the code with whitespace and comments</item><item>Refactor the code into separate functions/methods to make it more modular</item></list><paragraph>There is no one-size-fits-all approach here, but it is important to prioritize clarity when developing Go code.</paragraph><heading level="4">Why is the code doing what it does?</heading><paragraph>The code's rationale is often sufficiently communicated by the names of variables, functions, methods, or packages. Where it is not, it is important to add commentary. The "Why?" is especially important when the code contains nuances that a reader may not be familiar with, such as:</paragraph><list type="ul"><item>A nuance in the language, e.g., a closure will be capturing a loop variable, but the closure is many lines away</item><item>A nuance of the business logic, e.g., an access control check that needs to distinguish between the actual user and someone impersonating a user</item></list><paragraph>An API might require care to use correctly. For example, a piece of code may be intricate and difficult to follow for performance reasons, or a complex sequence of mathematical operations may use type conversions in an unexpected way. In these cases and many more, it is important that accompanying commentary and documentation explain these aspects so that future maintainers don't make a mistake and so that readers can understand the code without needing to reverse-engineer it.</paragraph><paragraph>It is also important to be aware that some attempts to provide clarity (such as adding extra commentary) can actually obscure the code's purpose by adding clutter, restating what the code already says, contradicting the code, or adding maintenance burden to keep the comments up-to-date. Allow the code to speak for itself (e.g., by making the symbol names themselves self-describing) rather than adding redundant comments. It is often better for comments to explain why something is done, not what the code is doing.</paragraph><paragraph>The Google codebase is largely uniform and consistent. It is often the case that code that stands out (e.g., by using an unfamiliar pattern) is doing so for a good reason, typically for performance. Maintaining this property is important to make it clear to readers where they should focus their attention when reading a new piece of code.</paragraph><paragraph>The standard library contains many examples of this principle in action. Among them:</paragraph><heading level="3">Simplicity</heading><paragraph>Your Go code should be simple for those using, reading, and maintaining it.</paragraph><paragraph>Go code should be written in the simplest way that accomplishes its goals, both in terms of behavior and performance. Within the Google Go codebase, simple code:</paragraph><list type="ul"><item>Is easy to read from top to bottom</item><item>Does not assume that you already know what it is doing</item><item>Does not assume that you can memorize all of the preceding code</item><item>Does not have unnecessary levels of abstraction</item><item>Does not have names that call attention to something mundane</item><item>Makes the propagation of values and decisions clear to the reader</item><item>Has comments that explain why, not what, the code is doing to avoid future deviation</item><item>Has documentation that stands on its own</item><item>Has useful errors and useful test failures</item><item>May often be mutually exclusive with "clever" code</item></list><paragraph>Tradeoffs can arise between code simplicity and API usage simplicity. For example, it may be worthwhile to have the code be more complex so that the end user of the API may more easily call the API correctly. In contrast, it may also be worthwhile to leave a bit of extra work to the end user of the API so that the code remains simple and easy to understand.</paragraph><paragraph>When code needs complexity, the complexity should be added deliberately. This is typically necessary if additional performance is required or where there are multiple disparate customers of a particular library or service. Complexity may be justified, but it should come with accompanying documentation so that clients and future maintainers are able to understand and navigate the complexity. This should be supplemented with tests and examples that demonstrate its correct usage, especially if there is both a "simple" and a "complex" way to use the code.</paragraph><paragraph>This principle does not imply that complex code cannot or should not be written in Go or that Go code is not allowed to be complex. We strive for a codebase that avoids unnecessary complexity so that when complexity does appear, it indicates that the code in question requires care to understand and maintain. Ideally, there should be accompanying commentary that explains the rationale and identifies the care that should be taken. This often arises when optimizing code for performance; doing so often requires a more complex approach, like preallocating a buffer and reusing it throughout a goroutine lifetime. When a maintainer sees this, it should be a clue that the code in question is performance-critical, and that should influence the care that is taken when making future changes. If employed unnecessarily, on the other hand, this complexity is a burden on those who need to read or change the code in the future.</paragraph><paragraph>If code turns out to be very complex when its purpose should be simple, this is often a signal to revisit the implementation to see if there is a simpler way to accomplish the same thing.</paragraph><heading level="4">Least mechanism</heading><paragraph>Where there are several ways to express the same idea, prefer the one that uses the most standard tools. Sophisticated machinery often exists, but should not be employed without reason. It is easy to add complexity to code as needed, whereas it is much harder to remove existing complexity after it has been found to be unnecessary.</paragraph><list type="ol"><item>Aim to use a core language construct (for example a channel, slice, map, loop, or struct) when sufficient for your use case.</item><item>If there isn't one, look for a tool within the standard library (like an HTTP client or a template engine).</item><item>Finally, consider whether there is a core library in the Google codebase that is sufficient before introducing a new dependency or creating your own.</item></list><paragraph>As an example, consider production code that contains a flag bound to a variable with a default value which must be overridden in tests. Unless intending to test the program's command-line interface itself (say, with os/exec), it is simpler and therefore preferable to override the bound value directly rather than by using flag.Set.</paragraph><paragraph>Similarly, if a piece of code requires a set membership check, a boolean-valued map (e.g., map[string]bool) often suffices. Libraries that provide set-like types and functionality should only be used if more complicated operations are required that are impossible or overly complicated with a map.</paragraph><heading level="3">Concision</heading><paragraph>Concise Go code has a high signal-to-noise ratio. It is easy to discern the relevant details, and the naming and structure guide the reader through these details.</paragraph><paragraph>There are many things that can get in the way of surfacing the most salient details at any given time:</paragraph><list type="ul"><item>Repetitive code</item><item>Extraneous syntax</item><item>Opaque names</item><item>Unnecessary abstraction</item><item>Whitespace</item></list><paragraph>Repetitive code especially obscures the differences between each nearly-identical section, and requires a reader to visually compare similar lines of code to find the changes. Table-driven testing is a good example of a mechanism that can concisely factor out the common code from the important details of each repetition, but the choice of which pieces to include in the table will have an impact on how easy the table is to understand.</paragraph><paragraph>When considering multiple ways to structure code, it is worth considering which way makes important details the most apparent.</paragraph><paragraph>Understanding and using common code constructions and idioms are also important for maintaining a high signal-to-noise ratio. For example, the following code block is very common in error handling, and the reader can quickly understand the purpose of this block.</paragraph><code language="javascript">// Good:
if err := doSomething(); err != nil {
    // ...
}
</code><paragraph>If code looks very similar to this but is subtly different, a reader may not notice the change. In cases like this, it is worth intentionally "boosting" the signal of the error check by adding a comment to call attention to it.</paragraph><code language="code">// Good:
if err := doSomething(); err == nil { // if NO error
    // ...
}
</code><heading level="3">Maintainability</heading><paragraph>Code is edited many more times than it is written. Readable code not only makes sense to a reader who is trying to understand how it works, but also to the programmer who needs to change it. Clarity is key.</paragraph><paragraph>Maintainable code:</paragraph><list type="ul"><item>Is easy for a future programmer to modify correctly</item><item>Has APIs that are structured so that they can grow gracefully</item><item>Is clear about the assumptions that it makes and chooses abstractions that map to the structure of the problem, not to the structure of the code</item><item>Avoids unnecessary coupling and doesn't include features that are not used</item><item>Has a comprehensive test suite to ensure promised behaviors are maintained and important logic is correct, and the tests provide clear, actionable diagnostics in case of failure</item></list><paragraph>When using abstractions like interfaces and types which by definition remove information from the context in which they are used, it is important to ensure that they provide sufficient benefit. Editors and IDEs can connect directly to a method definition and show the corresponding documentation when a concrete type is used, but can only refer to an interface definition otherwise. Interfaces are a powerful tool, but come with a cost, since the maintainer may need to understand the specifics of the underlying implementation in order to correctly use the interface, which must be explained within the interface documentation or at the call-site.</paragraph><paragraph>Maintainable code also avoids hiding important details in places that are easy to overlook. For example, in each of the following lines of code, the presence or lack of a single character is critical to understand the line:</paragraph><code language="javascript">// Bad:
// The use of = instead of := can change this line completely.
if user, err = db.UserByID(userID); err != nil {
    // ...
}
</code><code language="code">// Bad:
// The ! in the middle of this line is very easy to miss.
leap := (year%4 == 0) && (!(year%100 == 0) || (year%400 == 0))
</code><paragraph>Neither of these are incorrect, but both could be written in a more explicit fashion, or could have an accompanying comment that calls attention to the important behavior:</paragraph><code language="javascript">// Good:
u, err := db.UserByID(userID)
if err != nil {
    return fmt.Errorf("invalid origin user: %s", err)
}
user = u
</code><code language="javascript">// Good:
// Gregorian leap years aren't just year%4 == 0.
// See https://en.wikipedia.org/wiki/Leap_year#Algorithm.
var (
    leap4   = year%4 == 0
    leap100 = year%100 == 0
    leap400 = year%400 == 0
)
leap := leap4 && (!leap100 || leap400)
</code><paragraph>In the same way, a helper function that hides critical logic or an important edge-case could make it easy for a future change to fail to account for it properly.</paragraph><paragraph>Predictable names are another feature of maintainable code. A user of a package or a maintainer of a piece of code should be able to predict the name of a variable, method, or function in a given context. Function parameters and receiver names for identical concepts should typically share the same name, both to keep documentation understandable and to facilitate refactoring code with minimal overhead.</paragraph><paragraph>Maintainable code minimizes its dependencies (both implicit and explicit). Depending on fewer packages means fewer lines of code that can affect behavior. Avoiding dependencies on internal or undocumented behavior makes code less likely to impose a maintenance burden when those behaviors change in the future.</paragraph><paragraph>When considering how to structure or write code, it is worth taking the time to think through ways in which the code may evolve over time. If a given approach is more conducive to easier and safer future changes, that is often a good trade-off, even if it means a slightly more complicated design.</paragraph><heading level="3">Consistency</heading><paragraph>Consistent code is code that looks, feels, and behaves like similar code throughout the broader codebase, within the context of a team or package, and even within a single file.</paragraph><paragraph>Consistency concerns do not override any of the principles above, but if a tie must be broken, it is often beneficial to break it in favor of consistency.</paragraph><paragraph>Consistency within a package is often the most immediately important level of consistency. It can be very jarring if the same problem is approached in multiple ways throughout a package, or if the same concept has many names within a file. However, even this should not override documented style principles or global consistency.</paragraph><heading level="2">Core guidelines</heading><paragraph>These guidelines collect the most important aspects of Go style that all Go code is expected to follow. We expect that these principles be learned and followed by the time readability is granted. These are not expected to change frequently, and new additions will have to clear a high bar.</paragraph><paragraph>The guidelines below expand on the recommendations in Effective Go, which provide a common baseline for Go code across the entire community.</paragraph><heading level="3">Formatting</heading><paragraph>All Go source files must conform to the format outputted by the gofmt tool. This format is enforced by a presubmit check in the Google codebase. Generated code should generally also be formatted (e.g., by using format.Source), as it is also browsable in Code Search.</paragraph><heading level="3">MixedCaps</heading><paragraph>Go source code uses MixedCaps or mixedCaps (camel case) rather than underscores (snake case) when writing multi-word names.</paragraph><paragraph>This applies even when it breaks conventions in other languages. For example, a constant is MaxLength (not MAX_LENGTH) if exported and maxLength (not max_length) if unexported.</paragraph><paragraph>Local variables are considered unexported for the purpose of choosing the initial capitalization.</paragraph><heading level="3">Line length</heading><paragraph>There is no fixed line length for Go source code. If a line feels too long, prefer refactoring instead of splitting it. If it is already as short as it is practical for it to be, the line should be allowed to remain long.</paragraph><paragraph>Do not split a line:</paragraph><list type="ul"><item>Before an indentation change (e.g., function declaration, conditional)</item><item>To make a long string (e.g., a URL) fit into multiple shorter lines</item></list><heading level="3">Naming</heading><paragraph>Naming is more art than science. In Go, names tend to be somewhat shorter than in many other languages, but the same general guidelines apply. Names should:</paragraph><list type="ul"><item>Not feel repetitive when they are used</item><item>Take the context into consideration</item><item>Not repeat concepts that are already clear</item></list><paragraph>You can find more specific guidance on naming in decisions.</paragraph><heading level="3">Local consistency</heading><paragraph>Where the style guide has nothing to say about a particular point of style, authors are free to choose the style that they prefer, unless the code in close proximity (usually within the same file or package, but sometimes within a team or project directory) has taken a consistent stance on the issue.</paragraph><paragraph>Examples of valid local style considerations:</paragraph><list type="ul"><item>Use of %s or %v for formatted printing of errors</item><item>Usage of buffered channels in lieu of mutexes</item></list><paragraph>Examples of invalid local style considerations:</paragraph><list type="ul"><item>Line length restrictions for code</item><item>Use of assertion-based testing libraries</item></list><paragraph>If the local style disagrees with the style guide but the readability impact is limited to one file, it will generally be surfaced in a code review for which a consistent fix would be outside the scope of the CL in question. At that point, it is appropriate to file a bug to track the fix.</paragraph><paragraph>If a change would worsen an existing style deviation, expose it in more API surfaces, expand the number of files in which the deviation is present, or introduce an actual bug, then local consistency is no longer a valid justification for violating the style guide for new code. In these cases, it is appropriate for the author to clean up the existing codebase in the same CL, perform a refactor in advance of the current CL, or find an alternative that at least does not make the local problem worse.</paragraph></content>
</page>
<page url="https://google.github.io/closure-library/api/goog.asserts.html">
<title>goog.asserts</title>
<content></content>
</page>
<page url="https://google.github.io/styleguide/docguide/philosophy.html">
<title>Philosophy | styleguide</title>
<content><heading level="1">Philosophy</heading><paragraph>埏埴以為器，當其無，有器之用.</paragraph><paragraph>Clay becomes pottery through craft, but it's the emptiness that makes a pot useful.</paragraph><paragraph>- Laozi</paragraph><paragraph>Contents:</paragraph><list type="ol"><item>Radical simplicity</item><item>Readable source text</item><item>Minimum viable documentation</item><item>Better is better than best</item></list><heading level="2">Radical simplicity</heading><list type="ul"><item>Scalability and interoperability are more important than a menagerie of unessential features. Scale comes from simplicity, speed, and ease. Interoperability comes from unadorned, digestible content.</item><item>Fewer distractions make for better writing and more productive reading.</item><item>New features should never interfere with the simplest use case and should remain invisible to users who don't need them.</item><item>Markdown is designed for the average engineer – the busy, just-want-to-go-back-to-coding engineer. Large and complex documentation is possible but not the primary focus.</item><item>Minimizing context switching makes people happier. Engineers should be able to interact with documentation using the same tools they use to read and write code.</item></list><paragraph>Scalability and interoperability are more important than a menagerie of unessential features. Scale comes from simplicity, speed, and ease. Interoperability comes from unadorned, digestible content.</paragraph><paragraph>Fewer distractions make for better writing and more productive reading.</paragraph><paragraph>New features should never interfere with the simplest use case and should remain invisible to users who don't need them.</paragraph><paragraph>Markdown is designed for the average engineer – the busy, just-want-to-go-back-to-coding engineer. Large and complex documentation is possible but not the primary focus.</paragraph><paragraph>Minimizing context switching makes people happier. Engineers should be able to interact with documentation using the same tools they use to read and write code.</paragraph><heading level="2">Readable source text</heading><list type="ul"><item>Plain text not only suffices, it is superior. Markdown itself is not essential to this formula, but it is the best and most widely supported solution right now. HTML is generally not encouraged.</item><item>Content and presentation should not mingle. It should always be possible to ditch the renderer and read the essential information at source. Users should never have to touch the presentation layer if they don't want to.</item><item>Portability and future-proofing leave room for the unimagined integrations to come, and are best achieved by keeping the source as human-readable as possible.</item><item>Static content is better than dynamic, because content should not depend on the features of any one server. However, fresh is better than stale. We strive to balance these needs.</item></list><paragraph>Plain text not only suffices, it is superior. Markdown itself is not essential to this formula, but it is the best and most widely supported solution right now. HTML is generally not encouraged.</paragraph><paragraph>Content and presentation should not mingle. It should always be possible to ditch the renderer and read the essential information at source. Users should never have to touch the presentation layer if they don't want to.</paragraph><paragraph>Portability and future-proofing leave room for the unimagined integrations to come, and are best achieved by keeping the source as human-readable as possible.</paragraph><paragraph>Static content is better than dynamic, because content should not depend on the features of any one server. However, fresh is better than stale. We strive to balance these needs.</paragraph><heading level="2">Minimum viable documentation</heading><list type="ul"><item>Docs thrive when they're treated like tests: a necessary chore one learns to savor because it rewards over time. See Best Practices.</item><item>Brief and utilitarian is better than long and exhaustive. The vast majority of users need only a small fraction of the author's total knowledge, but they need it quickly and often.</item></list><paragraph>Docs thrive when they're treated like tests: a necessary chore one learns to savor because it rewards over time. See Best Practices.</paragraph><paragraph>Brief and utilitarian is better than long and exhaustive. The vast majority of users need only a small fraction of the author's total knowledge, but they need it quickly and often.</paragraph><heading level="2">Better is better than best</heading><list type="ul"><item>Incremental improvement is better than prolonged debate. Patience and tolerance of imperfection allow projects to evolve organically.</item><item>Don't lick the cookie, pass the plate. Ideas are cheap. We're drowning in potentially impactful projects. Choose only those you can really handle and release those you can't.</item></list><paragraph>Incremental improvement is better than prolonged debate. Patience and tolerance of imperfection allow projects to evolve organically.</paragraph><paragraph>Don't lick the cookie, pass the plate. Ideas are cheap. We're drowning in potentially impactful projects. Choose only those you can really handle and release those you can't.</paragraph></content>
</page>
<page url="https://google.github.io/styleguide/index">
<title>Google Style Guides | styleguide</title>
<content><heading level="1">Google Style Guides</heading><paragraph>Every major open-source project has its own style guide: a set of conventions (sometimes arbitrary) about how to write code for that project. It is much easier to understand a large codebase when all the code in it is in a consistent style.</paragraph><paragraph>"Style" covers a lot of ground, from "use camelCase for variable names" to "never use global variables" to "never use exceptions." This project (google/styleguide) links to the style guidelines we use for Google code. If you are modifying a project that originated at Google, you may be pointed to this page to see the style guides that apply to that project.</paragraph><paragraph>This project also contains google-c-style.el, an Emacs settings file for Google style.</paragraph><paragraph>We used to host the cpplint tool, but we stopped making internal updates public. An open source community has forked the project, so users are encouraged to use https://github.com/cpplint/cpplint instead.</paragraph><paragraph>If your project requires that you create a new XML document format, the XML Document Format Style Guide may be helpful. In addition to actual style rules, it also contains advice on designing your own vs. adapting an existing format, on XML instance document formatting, and on elements vs. attributes.</paragraph><paragraph>The style guides in this project are licensed under the CC-By 3.0 License, which encourages you to share these documents. See https://creativecommons.org/licenses/by/3.0/ for more details.</paragraph><paragraph>The following Google style guide lives outside of this project:</paragraph><paragraph>Since projects are largely maintained in a VCS, writing good commit messages is important to long term project health. Please refer to How to Write a Git Commit Message as an excellent resource. While it explicitly refers to the Git SCM, its principles apply to any system, and many Git conventions are trivial to translate to others.</paragraph><heading level="2">Contributing</heading><paragraph>With few exceptions, these style guides are copies of Google's internal style guides to assist developers working on Google owned and originated open source projects. Changes to the style guides are made to the internal style guides first and eventually copied into the versions found here. External contributions are not accepted. Pull requests are regularly closed without comment.</paragraph><paragraph>People can file issues using the GitHub tracker. Issues that raise questions, justify changes on technical merits, or point out obvious mistakes may get some engagement and could in theory lead to changes, but we are primarily optimizing for Google's internal needs.</paragraph></content>
</page>
</source>
</onefilellm_output>